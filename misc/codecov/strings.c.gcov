        -:    0:Source:strings.c
        -:    1:ï»¿/* strings.c -- misc string manipulation function */
        -:    2:
        -:    3:/*
        -:    4: * This file is part of CliFM
        -:    5: * 
        -:    6: * Copyright (C) 2016-2021, L. Abramovich <johndoe.arch@outlook.com>
        -:    7: * All rights reserved.
        -:    8:
        -:    9: * CliFM is free software; you can redistribute it and/or modify
        -:   10: * it under the terms of the GNU General Public License as published by
        -:   11: * the Free Software Foundation; either version 2 of the License, or
        -:   12: * (at your option) any later version.
        -:   13: *
        -:   14: * CliFM is distributed in the hope that it will be useful,
        -:   15: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   16: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   17: * GNU General Public License for more details.
        -:   18: *
        -:   19: * You should have received a copy of the GNU General Public License
        -:   20: * along with this program; if not, write to the Free Software
        -:   21: * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
        -:   22: * MA 02110-1301, USA.
        -:   23:*/
        -:   24:
        -:   25:#include "helpers.h"
        -:   26:
        -:   27:#include <glob.h>
        -:   28:#include <stdio.h>
        -:   29:#include <string.h>
        -:   30:#include <ctype.h>
        -:   31:#include <time.h>
        -:   32:#include <wchar.h>
        -:   33:#if !defined(__HAIKU__) && !defined(__OpenBSD__)
        -:   34:#include <wordexp.h>
        -:   35:#endif
        -:   36:#include "aux.h"
        -:   37:#include "checks.h"
        -:   38:#include "exec.h"
        -:   39:#include "navigation.h"
        -:   40:#include "readline.h"
        -:   41:
        -:   42:#ifndef _BE_POSIX
        -:   43:#define CMD_LEN_MAX (PATH_MAX + ((NAME_MAX + 1) << 1))
        -:   44:char len_buf[CMD_LEN_MAX] __attribute__((aligned));
        -:   45:#endif
        -:   46:
        -:   47:/* Taken from NNN's source code: very clever */
        -:   48:size_t
function xstrsncpy called 40271 returned 100% blocks executed 100%
    40271:   49:xstrsncpy(char *restrict dst, const char *restrict src, size_t n)
        -:   50:{
    40271:   51:	n++;
    40271:   52:	char *end = memccpy(dst, src, '\0', n);
    40271:   52-block  0
call    0 returned 40271
    40271:   53:	if (!end) {
branch  0 taken 75 (fallthrough)
branch  1 taken 40196
       75:   54:		dst[n - 1] = '\0';
       75:   55:		end = dst + n;
       75:   55-block  0
unconditional  0 taken 75
        -:   56:	}
        -:   57:
    40271:   58:	return (size_t)(end - dst - 1);
    40271:   58-block  0
unconditional  0 taken 40271
        -:   59:}
        -:   60:
        -:   61:size_t
function wc_xstrlen called 41181 returned 100% blocks executed 86%
    41181:   62:wc_xstrlen(const char *restrict str)
        -:   63:{
        -:   64:	size_t len, _len;
        -:   65:/*#ifndef _BE_POSIX */
    41181:   66:	wchar_t *const wbuf = (wchar_t *)len_buf;
        -:   67:
        -:   68:	/* Convert multi-byte to wide char */
    41181:   69:	_len = mbstowcs(wbuf, str, NAME_MAX);
    41181:   69-block  0
call    0 returned 41181
    41181:   70:	int p = wcswidth(wbuf, _len);
call    0 returned 41181
    41181:   71:	if (p != -1)
branch  0 taken 41181 (fallthrough)
branch  1 taken 0
    41181:   72:		len = (size_t)p;
    41181:   72-block  0
unconditional  0 taken 41181
        -:   73:	else
    #####:   74:		len = 0;
    %%%%%:   74-block  0
unconditional  0 never executed
        -:   75:/*#else
        -:   76:	len = u8_xstrlen(str);
        -:   77:#endif */
        -:   78:
    41181:   79:	return len;
    41181:   79-block  0
unconditional  0 taken 41181
        -:   80:}
        -:   81:
        -:   82:/* Truncate an UTF-8 string at length N. Returns zero if truncated and
        -:   83: * one if not */
        -:   84:int
function u8truncstr called 16 returned 100% blocks executed 86%
       16:   85:u8truncstr(char *restrict str, size_t n)
        -:   86:{
       16:   87:	size_t len = 0;
        -:   88:
      256:   89:	while (*(str++)) {
       16:   89-block  0
unconditional  0 taken 16
      256:   89-block  1
branch  1 taken 256
branch  2 taken 0 (fallthrough)
        -:   90:		/* Do not count continuation bytes (used by multibyte, that is,
        -:   91:		 * wide or non-ASCII characters) */
      256:   92:		if ((*str & 0xc0) != 0x80) {
      256:   92-block  0
branch  0 taken 256 (fallthrough)
branch  1 taken 0
      256:   93:			len++;
      256:   94:			if (len == n) {
      256:   94-block  0
branch  0 taken 16 (fallthrough)
branch  1 taken 240
       16:   95:				*str = '\0';
       16:   96:				return EXIT_SUCCESS;
       16:   96-block  0
unconditional  0 taken 16
        -:   97:			}
        -:   98:		}
        -:   99:	}
        -:  100:
    #####:  101:	return EXIT_FAILURE;
    %%%%%:  101-block  0
unconditional  0 never executed
        -:  102:}
        -:  103:
        -:  104:/* An strlen implementation able to handle unicode characters. Taken from:
        -:  105:* https://stackoverflow.com/questions/5117393/number-of-character-cells-used-by-string
        -:  106:* Explanation: strlen() counts bytes, not chars. Now, since ASCII chars
        -:  107:* take each 1 byte, the amount of bytes equals the amount of chars.
        -:  108:* However, non-ASCII or wide chars are multibyte chars, that is, one char
        -:  109:* takes more than 1 byte, and this is why strlen() does not work as
        -:  110:* expected for this kind of chars: a 6 chars string might take 12 or
        -:  111:* more bytes */
        -:  112:size_t
function u8_xstrlen called 0 returned 0% blocks executed 0%
    #####:  113:u8_xstrlen(const char *restrict str)
        -:  114:{
    #####:  115:	size_t len = 0;
        -:  116:
    #####:  117:	while (*(str++)) {
    %%%%%:  117-block  0
unconditional  0 never executed
    %%%%%:  117-block  1
branch  1 never executed
branch  2 never executed
    #####:  118:		if ((*str & 0xc0) != 0x80)
    %%%%%:  118-block  0
branch  0 never executed
branch  1 never executed
    #####:  119:			len++;
    %%%%%:  119-block  0
unconditional  0 never executed
        -:  120:	}
        -:  121:
    #####:  122:	return len;
    %%%%%:  122-block  0
unconditional  0 never executed
        -:  123:}
        -:  124:
        -:  125:/* Returns the index of the first appearance of c in str, if any, and
        -:  126: * -1 if c was not found or if no str. NOTE: Same thing as strchr(),
        -:  127: * except that returns an index, not a pointer */
        -:  128:int
function strcntchr called 84 returned 100% blocks executed 78%
       84:  129:strcntchr(const char *str, const char c)
        -:  130:{
       84:  131:	if (!str)
       84:  131-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 84
    #####:  132:		return -1;
    %%%%%:  132-block  0
unconditional  0 never executed
        -:  133:
       84:  134:	register int i = 0;
        -:  135:
      388:  136:	while (*str) {
       84:  136-block  0
unconditional  0 taken 84
      388:  136-block  1
branch  1 taken 388
branch  2 taken 0 (fallthrough)
      388:  137:		if (*str == c)
      388:  137-block  0
branch  0 taken 84 (fallthrough)
branch  1 taken 304
       84:  138:			return i;
       84:  138-block  0
unconditional  0 taken 84
      304:  139:		i++;
      304:  140:		str++;
      304:  140-block  0
unconditional  0 taken 304
        -:  141:	}
        -:  142:
    #####:  143:	return -1;
    %%%%%:  143-block  0
unconditional  0 never executed
        -:  144:}
        -:  145:
        -:  146:/* Returns the index of the last appearance of c in str, if any, and
        -:  147: * -1 if c was not found or if no str */
        -:  148:int
function strcntchrlst called 1512 returned 100% blocks executed 89%
     1512:  149:strcntchrlst(const char *str, const char c)
        -:  150:{
     1512:  151:	if (!str)
     1512:  151-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1512
    #####:  152:		return -1;
    %%%%%:  152-block  0
unconditional  0 never executed
        -:  153:
     1512:  154:	register int i = 0;
        -:  155:
     1512:  156:	int p = -1;
     5463:  157:	while (*str) {
     1512:  157-block  0
unconditional  0 taken 1512
     5463:  157-block  1
branch  1 taken 3951
branch  2 taken 1512 (fallthrough)
     3951:  158:		if (*str == c)
     3951:  158-block  0
branch  0 taken 554 (fallthrough)
branch  1 taken 3397
      554:  159:			p = i;
      554:  159-block  0
unconditional  0 taken 554
     3951:  160:		i++;
     3951:  161:		str++;
     3951:  161-block  0
unconditional  0 taken 3951
        -:  162:	}
        -:  163:
     1512:  164:	return p;
     1512:  164-block  0
unconditional  0 taken 1512
        -:  165:}
        -:  166:
        -:  167:/* Returns the string after the first appearance of a given char, or
        -:  168: * returns NULL if C is not found in STR or C is the last char in STR. */
        -:  169:char *
function straft called 60 returned 100% blocks executed 81%
       60:  170:straft(char *str, const char c)
        -:  171:{
       60:  172:	if (!str || !*str || !c)
       60:  172-block  0
branch  0 taken 60 (fallthrough)
branch  1 taken 0
       60:  172-block  1
branch  2 taken 60 (fallthrough)
branch  3 taken 0
       60:  172-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 60
    #####:  173:		return (char *)NULL;
    %%%%%:  173-block  0
unconditional  0 never executed
        -:  174:
       60:  175:	char *p = str, *q = (char *)NULL;
        -:  176:
      336:  177:	while (*p) {
       60:  177-block  0
unconditional  0 taken 60
      336:  177-block  1
branch  1 taken 336
branch  2 taken 0 (fallthrough)
      336:  178:		if (*p == c) {
      336:  178-block  0
branch  0 taken 60 (fallthrough)
branch  1 taken 276
       60:  179:			q = p;
       60:  180:			break;
       60:  180-block  0
unconditional  0 taken 60
        -:  181:		}
      276:  182:		p++;
      276:  182-block  0
unconditional  0 taken 276
        -:  183:	}
        -:  184:
        -:  185:	/* If C was not found or there is nothing after C */
       60:  186:	if (!q || !*(q + 1))
       60:  186-block  0
branch  0 taken 60 (fallthrough)
branch  1 taken 0
       60:  186-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 60
    #####:  187:		return (char *)NULL;
    %%%%%:  187-block  0
unconditional  0 never executed
        -:  188:
       60:  189:	char *buf = (char *)malloc(strlen(q + 1) + 1);
        -:  190:
       60:  191:	if (!buf)
       60:  191-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 60
    #####:  192:		return (char *)NULL;
    %%%%%:  192-block  0
unconditional  0 never executed
        -:  193:
       60:  194:	strcpy(buf, q + 1);
       60:  195:	return buf;
       60:  195-block  0
unconditional  0 taken 60
        -:  196:}
        -:  197:
        -:  198:/* Returns the string after the last appearance of a given char, or
        -:  199: * NULL if no match */
        -:  200:char *
function straftlst called 11 returned 100% blocks executed 81%
       11:  201:straftlst(char *str, const char c)
        -:  202:{
       11:  203:	if (!str || !*str || !c)
       11:  203-block  0
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11:  203-block  1
branch  2 taken 11 (fallthrough)
branch  3 taken 0
       11:  203-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 11
    #####:  204:		return (char *)NULL;
    %%%%%:  204-block  0
unconditional  0 never executed
        -:  205:
       11:  206:	char *p = str, *q = (char *)NULL;
        -:  207:
      468:  208:	while (*p) {
       11:  208-block  0
unconditional  0 taken 11
      468:  208-block  1
branch  1 taken 457
branch  2 taken 11 (fallthrough)
      457:  209:		if (*p == c)
      457:  209-block  0
branch  0 taken 66 (fallthrough)
branch  1 taken 391
       66:  210:			q = p;
       66:  210-block  0
unconditional  0 taken 66
      457:  211:		p++;
      457:  211-block  0
unconditional  0 taken 457
        -:  212:	}
        -:  213:
       11:  214:	if (!q || !*(q + 1))
       11:  214-block  0
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11:  214-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 11
    #####:  215:		return (char *)NULL;
    %%%%%:  215-block  0
unconditional  0 never executed
        -:  216:
       11:  217:	char *buf = (char *)malloc(strlen(q + 1) + 1);
        -:  218:
       11:  219:	if (!buf)
       11:  219-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:  220:		return (char *)NULL;
    %%%%%:  220-block  0
unconditional  0 never executed
        -:  221:
       11:  222:	strcpy(buf, q + 1);
       11:  223:	return buf;
       11:  223-block  0
unconditional  0 taken 11
        -:  224:}
        -:  225:
        -:  226:/* Returns the substring in str before the first appearance of c. If
        -:  227: * not found, or C is the first char in STR, returns NULL */
        -:  228:char *
function strbfr called 10 returned 100% blocks executed 88%
       10:  229:strbfr(char *str, const char c)
        -:  230:{
       10:  231:	if (!str || !*str || !c)
       10:  231-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 0
       10:  231-block  1
branch  2 taken 10 (fallthrough)
branch  3 taken 0
       10:  231-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 10
    #####:  232:		return (char *)NULL;
    %%%%%:  232-block  0
unconditional  0 never executed
        -:  233:
       10:  234:	char *p = str, *q = (char *)NULL;
       16:  235:	while (*p) {
       10:  235-block  0
unconditional  0 taken 10
       16:  235-block  1
branch  1 taken 16
branch  2 taken 0 (fallthrough)
       16:  236:		if (*p == c) {
       16:  236-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 6
       10:  237:			q = p; /* q is now a pointer to C in STR */
       10:  238:			break;
       10:  238-block  0
unconditional  0 taken 10
        -:  239:		}
        6:  240:		p++;
        6:  240-block  0
unconditional  0 taken 6
        -:  241:	}
        -:  242:
        -:  243:	/* C was not found or it was the first char in STR */
       10:  244:	if (!q || q == str)
       10:  244-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 0
       10:  244-block  1
branch  2 taken 5 (fallthrough)
branch  3 taken 5
        5:  245:		return (char *)NULL;
        5:  245-block  0
unconditional  0 taken 5
        -:  246:
        5:  247:	*q = '\0';
        -:  248:	/* Now C (because q points to C) is the null byte and STR ends in
        -:  249:	 * C, which is what we want */
        -:  250:
        5:  251:	char *buf = (char *)malloc((size_t)(q - str + 1));
        -:  252:
        5:  253:	if (!buf) { /* Memory allocation error */
        5:  253-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -:  254:		/* Give back to C its original value, so that STR is not
        -:  255:		 * modified in the process */
    #####:  256:		*q = c;
    #####:  257:		return (char *)NULL;
    %%%%%:  257-block  0
unconditional  0 never executed
        -:  258:	}
        -:  259:
        5:  260:	strcpy(buf, str);
        5:  261:	*q = c;
        5:  262:	return buf;
        5:  262-block  0
unconditional  0 taken 5
        -:  263:}
        -:  264:
        -:  265:/* Get substring in STR before the last appearance of C. Returns
        -:  266: * substring  if C is found and NULL if not (or if C was the first
        -:  267: * char in STR). */
        -:  268:char *
function strbfrlst called 21 returned 100% blocks executed 81%
       21:  269:strbfrlst(char *str, const char c)
        -:  270:{
       21:  271:	if (!str || !*str || !c)
       21:  271-block  0
branch  0 taken 21 (fallthrough)
branch  1 taken 0
       21:  271-block  1
branch  2 taken 21 (fallthrough)
branch  3 taken 0
       21:  271-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 21
    #####:  272:		return (char *)NULL;
    %%%%%:  272-block  0
unconditional  0 never executed
        -:  273:
       21:  274:	char *p = str, *q = (char *)NULL;
      895:  275:	while (*p) {
       21:  275-block  0
unconditional  0 taken 21
      895:  275-block  1
branch  1 taken 874
branch  2 taken 21 (fallthrough)
      874:  276:		if (*p == c)
      874:  276-block  0
branch  0 taken 126 (fallthrough)
branch  1 taken 748
      126:  277:			q = p;
      126:  277-block  0
unconditional  0 taken 126
      874:  278:		p++;
      874:  278-block  0
unconditional  0 taken 874
        -:  279:	}
        -:  280:
       21:  281:	if (!q || q == str)
       21:  281-block  0
branch  0 taken 21 (fallthrough)
branch  1 taken 0
       21:  281-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 21
    #####:  282:		return (char *)NULL;
    %%%%%:  282-block  0
unconditional  0 never executed
        -:  283:
       21:  284:	*q = '\0';
        -:  285:
       21:  286:	char *buf = (char *)malloc((size_t)(q - str + 1));
       21:  287:	if (!buf) {
       21:  287-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 21
    #####:  288:		*q = c;
    #####:  289:		return (char *)NULL;
    %%%%%:  289-block  0
unconditional  0 never executed
        -:  290:	}
        -:  291:
       21:  292:	strcpy(buf, str);
       21:  293:	*q = c;
       21:  294:	return buf;
       21:  294-block  0
unconditional  0 taken 21
        -:  295:}
        -:  296:
        -:  297:/* Returns the string between first ocurrence of A and the first
        -:  298: * ocurrence of B in STR, or NULL if: there is nothing between A and
        -:  299: * B, or A and/or B are not found */
        -:  300:char *
function strbtw called 171 returned 100% blocks executed 89%
      171:  301:strbtw(char *str, const char a, const char b)
        -:  302:{
      171:  303:	if (!str || !*str || !a || !b)
      171:  303-block  0
branch  0 taken 171 (fallthrough)
branch  1 taken 0
      171:  303-block  1
branch  2 taken 171 (fallthrough)
branch  3 taken 0
      171:  303-block  2
branch  4 taken 171 (fallthrough)
branch  5 taken 0
      171:  303-block  3
branch  6 taken 0 (fallthrough)
branch  7 taken 171
    #####:  304:		return (char *)NULL;
    %%%%%:  304-block  0
unconditional  0 never executed
        -:  305:
      171:  306:	char *p = str, *pa = (char *)NULL, *pb = (char *)NULL;
     1293:  307:	while (*p) {
      171:  307-block  0
unconditional  0 taken 171
     1293:  307-block  1
branch  1 taken 1277
branch  2 taken 16 (fallthrough)
     1277:  308:		if (!pa) {
     1277:  308-block  0
branch  0 taken 382 (fallthrough)
branch  1 taken 895
      382:  309:			if (*p == a)
      382:  309-block  0
branch  0 taken 171 (fallthrough)
branch  1 taken 211
      171:  310:				pa = p;
      171:  310-block  0
unconditional  0 taken 171
      895:  311:		} else if (*p == b) {
      895:  311-block  0
branch  0 taken 155 (fallthrough)
branch  1 taken 740
      155:  312:			pb = p;
      155:  313:			break;
      155:  313-block  0
unconditional  0 taken 155
        -:  314:		}
     1122:  315:		p++;
     1122:  315-block  0
unconditional  0 taken 1122
        -:  316:	}
        -:  317:
      171:  318:	if (!pb)
      171:  318-block  0
branch  0 taken 16 (fallthrough)
branch  1 taken 155
       16:  319:		return (char *)NULL;
       16:  319-block  0
unconditional  0 taken 16
        -:  320:
      155:  321:	*pb = '\0';
        -:  322:
      155:  323:	char *buf = (char *)malloc((size_t)(pb - pa));
        -:  324:
      155:  325:	if (!buf) {
      155:  325-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 155
    #####:  326:		*pb = b;
    #####:  327:		return (char *)NULL;
    %%%%%:  327-block  0
unconditional  0 never executed
        -:  328:	}
        -:  329:
      155:  330:	strcpy(buf, pa + 1);
      155:  331:	*pb = b;
      155:  332:	return buf;
      155:  332-block  0
unconditional  0 taken 155
        -:  333:}
        -:  334:
        -:  335:/* Replace the first occurrence of NEEDLE in HAYSTACK by REP */
        -:  336:char *
function replace_substr called 76 returned 100% blocks executed 87%
       76:  337:replace_substr(char *haystack, char *needle, char *rep)
        -:  338:{
       76:  339:	if (!haystack || !*haystack || !needle || !*needle || !rep)
       76:  339-block  0
branch  0 taken 76 (fallthrough)
branch  1 taken 0
       76:  339-block  1
branch  2 taken 76 (fallthrough)
branch  3 taken 0
       76:  339-block  2
branch  4 taken 76 (fallthrough)
branch  5 taken 0
       76:  339-block  3
branch  6 taken 76 (fallthrough)
branch  7 taken 0
       76:  339-block  4
branch  8 taken 0 (fallthrough)
branch  9 taken 76
    #####:  340:		return (char *)NULL;
    %%%%%:  340-block  0
unconditional  0 never executed
        -:  341:
       76:  342:	char *ret = strstr(haystack, needle);
       76:  343:	if (!ret)
       76:  343-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 76
    #####:  344:		return (char *)NULL;
    %%%%%:  344-block  0
unconditional  0 never executed
        -:  345:
       76:  346:	char *needle_end = ret + strlen(needle);
       76:  347:	*ret = '\0';
        -:  348:
       76:  349:	if (*needle_end) {
       76:  349-block  0
branch  0 taken 19 (fallthrough)
branch  1 taken 57
       19:  350:		size_t rem_len = strlen(needle_end);
       19:  351:		char *rem = (char *)xnmalloc(rem_len + 1, sizeof(char));
       19:  351-block  0
call    0 returned 19
       19:  352:		strcpy(rem, needle_end);
        -:  353:
       19:  354:		char *new_str = (char *)xnmalloc(strlen(haystack) + strlen(rep)
       19:  355:						+ rem_len + 1, sizeof(char));
call    0 returned 19
       19:  356:		strcpy(new_str, haystack);
       19:  357:		strcat(new_str, rep);
       19:  358:		strcat(new_str, rem);
       19:  359:		free(rem);
       19:  360:		return new_str;
unconditional  0 taken 19
        -:  361:	}
        -:  362:
       57:  363:	char *new_str = (char *)xnmalloc(strlen(haystack) + strlen(rep)
       57:  363-block  0
call    0 returned 57
        -:  364:					+ 1, sizeof(char));
       57:  365:	strcpy(new_str, haystack);
       57:  366:	strcat(new_str, rep);
       57:  367:	return new_str;
unconditional  0 taken 57
        -:  368:}
        -:  369:
        -:  370:/* Generate a random string of LEN bytes using characters from CHARSET */
        -:  371:char *
function gen_rand_str called 7 returned 100% blocks executed 83%
        7:  372:gen_rand_str(size_t len)
        -:  373:{
        7:  374:	char charset[] = "0123456789#%-_"
        -:  375:			 "abcdefghijklmnopqrstuvwxyz"
        -:  376:			 "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        -:  377:
        7:  378:	srand((unsigned int)time(NULL));
        7:  378-block  0
call    0 returned 7
call    1 returned 7
        -:  379:
        7:  380:	char *str = (char *)malloc((len + 1) * sizeof(char));
        7:  381:	char *p = str;
        -:  382:
        7:  383:	if (!p) {
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  384:		fprintf(stderr, "Error allocating %zu bytes\n", len);
    %%%%%:  384-block  0
call    0 never executed
    #####:  385:		return (char *)NULL;
unconditional  0 never executed
        -:  386:	}
        -:  387:
       49:  388:	while (len--) {
        7:  388-block  0
unconditional  0 taken 7
       49:  388-block  1
branch  1 taken 42
branch  2 taken 7 (fallthrough)
       42:  389:		int i = rand() % (int)(sizeof(charset) - 1);
       42:  389-block  0
call    0 returned 42
       42:  390:		*p++ = charset[i];
unconditional  0 taken 42
        -:  391:	}
        -:  392:
        7:  393:	*p = '\0';
        7:  394:	return str;
        7:  394-block  0
unconditional  0 taken 7
        -:  395:}
        -:  396:
        -:  397:/* Removes end of line char and quotes (single and double) from STR.
        -:  398: * Returns a pointer to the modified STR if the result is non-blank
        -:  399: * or NULL */
        -:  400:char *
function remove_quotes called 325 returned 100% blocks executed 88%
      325:  401:remove_quotes(char *str)
        -:  402:{
      325:  403:	if (!str || !*str)
      325:  403-block  0
branch  0 taken 325 (fallthrough)
branch  1 taken 0
      325:  403-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 325
    #####:  404:		return (char *)NULL;
    %%%%%:  404-block  0
unconditional  0 never executed
        -:  405:
      325:  406:	char *p = str;
      325:  407:	size_t len = strlen(p);
        -:  408:
      325:  409:	if (len > 0 && p[len - 1] == '\n') {
      325:  409-block  0
branch  0 taken 325 (fallthrough)
branch  1 taken 0
      325:  409-block  1
branch  2 taken 97 (fallthrough)
branch  3 taken 228
       97:  410:		p[len - 1] = '\0';
       97:  411:		len--;
       97:  411-block  0
unconditional  0 taken 97
        -:  412:	}
        -:  413:
      325:  414:	if (len > 0 && (p[len - 1] == '\'' || p[len - 1] == '"'))
      325:  414-block  0
branch  0 taken 293 (fallthrough)
branch  1 taken 32
      293:  414-block  1
branch  2 taken 245 (fallthrough)
branch  3 taken 48
      245:  414-block  2
branch  4 taken 38 (fallthrough)
branch  5 taken 207
       86:  415:		p[len - 1] = '\0';
       86:  415-block  0
unconditional  0 taken 86
        -:  416:
      325:  417:	if (*p == '\'' || *p == '"')
      325:  417-block  0
branch  0 taken 277 (fallthrough)
branch  1 taken 48
      277:  417-block  1
branch  2 taken 38 (fallthrough)
branch  3 taken 239
       86:  418:		p++;
       86:  418-block  0
unconditional  0 taken 86
        -:  419:
      325:  420:	if (!*p)
      325:  420-block  0
branch  0 taken 32 (fallthrough)
branch  1 taken 293
       32:  421:		return (char *)NULL;
       32:  421-block  0
unconditional  0 taken 32
        -:  422:
      293:  423:	char *q = p;
      293:  424:	int blank = 1;
        -:  425:
      293:  426:	while (*q) {
      293:  426-block  0
unconditional  0 taken 293
      293:  426-block  1
branch  1 taken 293
branch  2 taken 0 (fallthrough)
      293:  427:		if (*q != ' ' && *q != '\n' && *q != '\t') {
      293:  427-block  0
branch  0 taken 293 (fallthrough)
branch  1 taken 0
      293:  427-block  1
branch  2 taken 293 (fallthrough)
branch  3 taken 0
      293:  427-block  2
branch  4 taken 293 (fallthrough)
branch  5 taken 0
      293:  428:			blank = 0;
      293:  429:			break;
      293:  429-block  0
unconditional  0 taken 293
        -:  430:		}
    #####:  431:		q++;
    %%%%%:  431-block  0
unconditional  0 never executed
        -:  432:	}
        -:  433:
      293:  434:	if (!blank)
      293:  434-block  0
branch  0 taken 293 (fallthrough)
branch  1 taken 0
      293:  435:		return p;
      293:  435-block  0
unconditional  0 taken 293
    #####:  436:	return (char *)NULL;
    %%%%%:  436-block  0
unconditional  0 never executed
        -:  437:}
        -:  438:
        -:  439:/* This function takes a string as argument and split it into substrings
        -:  440: * taking tab, new line char, and space as word delimiters, except when
        -:  441: * they are preceded by a quote char (single or double quotes) or in
        -:  442: * case of command substitution ($(cmd) or `cmd`), in which case
        -:  443: * eveything after the corresponding closing char is taken as one single
        -:  444: * string. It also escapes spaecial chars. It returns an array of
        -:  445: * splitted strings (without leading and terminating spaces) or NULL if
        -:  446: * str is NULL or if no substring was found, i.e., if str contains
        -:  447: * only spaces. */
        -:  448:char **
function split_str called 500 returned 100% blocks executed 41%
      500:  449:split_str(const char *str)
        -:  450:{
      500:  451:	if (!str)
      500:  451-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 500
    #####:  452:		return (char **)NULL;
    %%%%%:  452-block  0
unconditional  0 never executed
        -:  453:
      500:  454:	size_t buf_len = 0, words = 0, str_len = 0;
      500:  455:	char *buf = (char *)NULL;
      500:  456:	buf = (char *)xnmalloc(1, sizeof(char));
      500:  456-block  0
call    0 returned 500
      500:  457:	int quote = 0, close = 0;
      500:  458:	char **substr = (char **)NULL;
        -:  459:
     2583:  460:	while (*str) {
unconditional  0 taken 500
     2583:  460-block  0
branch  1 taken 2083
branch  2 taken 500 (fallthrough)
     2083:  461:		switch (*str) {
     2083:  461-block  0
branch  0 taken 2
branch  1 taken 0
branch  2 taken 223
branch  3 taken 1858
        -:  462:		/* Command substitution */
        2:  463:		case '$': /* fallthrough */
        -:  464:		case '`':
        -:  465:			/* Define the closing char: If "$(" then ')', else '`' */
        2:  466:			if (*str == '$') {
        2:  466-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -:  467:				/* If escaped, it has no special meaning */
        2:  468:				if ((str_len && *(str - 1) == '\\') || *(str + 1) != '(') {
        2:  468-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  468-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2:  468-block  2
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        2:  469:					buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
        2:  469-block  0
call    0 returned 2
        2:  470:					buf[buf_len++] = *str;
        2:  471:					break;
unconditional  0 taken 2
        -:  472:				} else {
    #####:  473:					close = ')';
    %%%%%:  473-block  0
unconditional  0 never executed
        -:  474:				}
        -:  475:			} else {
        -:  476:				/* If escaped, it has no special meaning */
    #####:  477:				if (str_len && *(str - 1) == '\\') {
    %%%%%:  477-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  477-block  1
branch  2 never executed
branch  3 never executed
    #####:  478:					buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
    %%%%%:  478-block  0
call    0 never executed
    #####:  479:					buf[buf_len++] = *str;
    #####:  480:					break;
unconditional  0 never executed
        -:  481:				} else {
        -:  482:					/* If '`' advance one char. Otherwise the while
        -:  483:					 * below will stop at first char, which is not
        -:  484:					 * what we want */
    #####:  485:					close = *str;
    #####:  486:					str++;
    #####:  487:					buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
    %%%%%:  487-block  0
call    0 never executed
    #####:  488:					buf[buf_len++] = '`';
unconditional  0 never executed
        -:  489:				}
        -:  490:			}
        -:  491:
        -:  492:			/* Copy everything until null byte or closing char */
    #####:  493:			while (*str && *str != close) {
    %%%%%:  493-block  0
unconditional  0 never executed
    %%%%%:  493-block  1
branch  1 never executed
branch  2 never executed
    %%%%%:  493-block  2
branch  3 never executed
branch  4 never executed
    #####:  494:				buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
    %%%%%:  494-block  0
call    0 never executed
    #####:  495:				buf[buf_len++] = *(str++);
unconditional  0 never executed
        -:  496:			}
        -:  497:
        -:  498:			/* If the while loop stopped with a null byte, there was
        -:  499:			 * no ending close (either ')' or '`')*/
    #####:  500:			if (!*str) {
    %%%%%:  500-block  0
branch  0 never executed
branch  1 never executed
    #####:  501:				fprintf(stderr, _("%s: Missing '%c'\n"), PROGRAM_NAME,
    %%%%%:  501-block  0
call    0 never executed
call    1 never executed
        -:  502:				    close);
        -:  503:
    #####:  504:				free(buf);
    #####:  505:				buf = (char *)NULL;
    #####:  506:				int i = (int)words;
        -:  507:
    #####:  508:				while (--i >= 0)
unconditional  0 never executed
    %%%%%:  508-block  0
branch  1 never executed
branch  2 never executed
    #####:  509:					free(substr[i]);
    %%%%%:  509-block  0
unconditional  0 never executed
    #####:  510:				free(substr);
        -:  511:
    #####:  512:				return (char **)NULL;
    %%%%%:  512-block  0
unconditional  0 never executed
        -:  513:			}
        -:  514:
        -:  515:			/* Copy the closing char and add an space: this function
        -:  516:			 * takes space as word breaking char, so that everything
        -:  517:			 * in the buffer will be copied as one single word */
    #####:  518:			buf = (char *)xrealloc(buf, (buf_len + 2) * sizeof(char *));
    %%%%%:  518-block  0
call    0 never executed
    #####:  519:			buf[buf_len++] = *str;
    #####:  520:			buf[buf_len] = ' ';
        -:  521:
    #####:  522:			break;
unconditional  0 never executed
        -:  523:
    #####:  524:		case '\'': /* fallthrough */
        -:  525:		case '"':
        -:  526:			/* If the quote is escaped, it has no special meaning */
    #####:  527:			if (str_len && *(str - 1) == '\\') {
    %%%%%:  527-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  527-block  1
branch  2 never executed
branch  3 never executed
    #####:  528:				buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
    %%%%%:  528-block  0
call    0 never executed
    #####:  529:				buf[buf_len++] = *str;
    #####:  530:				break;
unconditional  0 never executed
        -:  531:			}
        -:  532:
        -:  533:			/* If not escaped, move on to the next char */
    #####:  534:			quote = *str;
    #####:  535:			str++;
        -:  536:
        -:  537:			/* Copy into the buffer whatever is after the first quote
        -:  538:			 * up to the last quote or NULL */
    #####:  539:			while (*str && *str != quote) {
    %%%%%:  539-block  0
unconditional  0 never executed
    %%%%%:  539-block  1
branch  1 never executed
branch  2 never executed
    %%%%%:  539-block  2
branch  3 never executed
branch  4 never executed
        -:  540:				/* If char has special meaning, escape it */
    #####:  541:				if (is_quote_char(*str)) {
    %%%%%:  541-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  542:					buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
    %%%%%:  542-block  0
call    0 never executed
    #####:  543:					buf[buf_len++] = '\\';
unconditional  0 never executed
        -:  544:				}
        -:  545:
    #####:  546:				buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
    %%%%%:  546-block  0
call    0 never executed
    #####:  547:				buf[buf_len++] = *(str++);
unconditional  0 never executed
        -:  548:			}
        -:  549:
        -:  550:			/* The above while breaks with NULL or quote, so that if
        -:  551:			 * *str is a null byte there was not ending quote */
    #####:  552:			if (!*str) {
    %%%%%:  552-block  0
branch  0 never executed
branch  1 never executed
    #####:  553:				fprintf(stderr, _("%s: Missing '%c'\n"), PROGRAM_NAME, quote);
    %%%%%:  553-block  0
call    0 never executed
call    1 never executed
        -:  554:				/* Free the current buffer and whatever was already
        -:  555:				 * allocated */
    #####:  556:				free(buf);
    #####:  557:				buf = (char *)NULL;
    #####:  558:				int i = (int)words;
        -:  559:
    #####:  560:				while (--i >= 0)
unconditional  0 never executed
    %%%%%:  560-block  0
branch  1 never executed
branch  2 never executed
    #####:  561:					free(substr[i]);
    %%%%%:  561-block  0
unconditional  0 never executed
    #####:  562:				free(substr);
    #####:  563:				return (char **)NULL;
    %%%%%:  563-block  0
unconditional  0 never executed
        -:  564:			}
    #####:  565:			break;
    %%%%%:  565-block  0
unconditional  0 never executed
        -:  566:
        -:  567:		/* TAB, new line char, and space are taken as word breaking
        -:  568:		 * characters */
      223:  569:		case '\t':
        -:  570:		case '\n':
        -:  571:		case ' ':
        -:  572:			/* If escaped, just copy it into the buffer */
      223:  573:			if (str_len && *(str - 1) == '\\') {
      223:  573-block  0
branch  0 taken 223 (fallthrough)
branch  1 taken 0
      223:  573-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 223
    #####:  574:				buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
    %%%%%:  574-block  0
call    0 never executed
    #####:  575:				buf[buf_len++] = *str;
unconditional  0 never executed
        -:  576:			} else {
        -:  577:				/* If not escaped, break the string */
        -:  578:				/* Add a terminating null byte to the buffer, and, if
        -:  579:				 * not empty, dump the buffer into the substrings
        -:  580:				 * array */
      223:  581:				buf[buf_len] = '\0';
        -:  582:
      223:  583:				if (buf_len > 0) {
      223:  583-block  0
branch  0 taken 223 (fallthrough)
branch  1 taken 0
      223:  584:					substr = (char **)xrealloc(substr, (words + 1) * sizeof(char *));
      223:  584-block  0
call    0 returned 223
      223:  585:					substr[words] = savestring(buf, buf_len);
call    0 returned 223
      223:  586:					words++;
unconditional  0 taken 223
        -:  587:				}
        -:  588:
        -:  589:				/* Clear te buffer to get a new string */
      223:  590:				memset(buf, '\0', buf_len);
      223:  591:				buf_len = 0;
      223:  591-block  0
unconditional  0 taken 223
        -:  592:			}
      223:  593:			break;
      223:  593-block  0
unconditional  0 taken 223
        -:  594:
        -:  595:		/* If neither a quote nor a breaking word char nor command
        -:  596:		 * substitution, just dump it into the buffer */
     1858:  597:		default:
     1858:  598:			buf = (char *)xrealloc(buf, (buf_len + 1) * sizeof(char *));
     1858:  598-block  0
call    0 returned 1858
     1858:  599:			buf[buf_len++] = *str;
     1858:  600:			break;
unconditional  0 taken 1858
        -:  601:		}
        -:  602:
     2083:  603:		str++;
     2083:  604:		str_len++;
     2083:  604-block  0
unconditional  0 taken 2083
        -:  605:	}
        -:  606:
        -:  607:	/* The while loop stops when the null byte is reached, so that the
        -:  608:	 * last substring is not printed, but still stored in the buffer.
        -:  609:	 * Therefore, we need to add it, if not empty, to our subtrings
        -:  610:	 * array */
      500:  611:	buf[buf_len] = '\0';
        -:  612:
      500:  613:	if (buf_len > 0) {
      500:  613-block  0
branch  0 taken 478 (fallthrough)
branch  1 taken 22
      478:  614:		if (!words)
      478:  614-block  0
branch  0 taken 322 (fallthrough)
branch  1 taken 156
      322:  615:			substr = (char **)xcalloc(words + 1, sizeof(char *));
      322:  615-block  0
call    0 returned 322
unconditional  1 taken 322
        -:  616:		else
      156:  617:			substr = (char **)xrealloc(substr, (words + 1) * sizeof(char *));
      156:  617-block  0
call    0 returned 156
unconditional  1 taken 156
        -:  618:
      478:  619:		substr[words] = savestring(buf, buf_len);
      478:  619-block  0
call    0 returned 478
      478:  620:		words++;
unconditional  0 taken 478
        -:  621:	}
        -:  622:
      500:  623:	free(buf);
      500:  624:	buf = (char *)NULL;
        -:  625:
      500:  626:	if (words) {
      500:  626-block  0
branch  0 taken 500 (fallthrough)
branch  1 taken 0
        -:  627:		/* Add a final null string to the array */
      500:  628:		substr = (char **)xrealloc(substr, (words + 1) * sizeof(char *));
      500:  628-block  0
call    0 returned 500
      500:  629:		substr[words] = (char *)NULL;
        -:  630:
      500:  631:		args_n = words - 1;
      500:  632:		return substr;
unconditional  0 taken 500
        -:  633:	} else {
    #####:  634:		args_n = 0; /* Just in case, but I think it's not needed */
    #####:  635:		return (char **)NULL;
    %%%%%:  635-block  0
unconditional  0 never executed
        -:  636:	}
        -:  637:}
        -:  638:
        -:  639:/* Return 1 if STR contains only numbers of a range of number, and zero
        -:  640: * if not */
        -:  641:static int
function check_fused_param called 181 returned 100% blocks executed 75%
      181:  642:check_fused_param(const char *str)
        -:  643:{
      181:  644:	char *p = (char *)str;
      181:  645:	size_t c = 0, i = 0;
      181:  646:	int ok = 1;
        -:  647:
      204:  648:	while (*p) {
      181:  648-block  0
unconditional  0 taken 181
      204:  648-block  1
branch  1 taken 199
branch  2 taken 5 (fallthrough)
     199*:  649:		if (i && *p == '-' && *(p - 1) >= '0' && *(p - 1) <= '9'
      199:  649-block  0
branch  0 taken 18 (fallthrough)
branch  1 taken 181
       18:  649-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 18
    %%%%%:  649-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  649-block  3
branch  6 never executed
branch  7 never executed
    #####:  650:		&& *(p + 1) >= '1' && *(p + 1) <= '9') {
    %%%%%:  650-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  650-block  1
branch  2 never executed
branch  3 never executed
    #####:  651:			c++;
    %%%%%:  651-block  0
unconditional  0 never executed
      199:  652:		} else if (*p == ' ') {
      199:  652-block  0
branch  0 taken 20 (fallthrough)
branch  1 taken 179
       20:  653:			break;
       20:  653-block  0
unconditional  0 taken 20
      179:  654:		} else if (*p < '0' || *p > '9') {
      179:  654-block  0
branch  0 taken 152 (fallthrough)
branch  1 taken 27
      152:  654-block  1
branch  2 taken 129 (fallthrough)
branch  3 taken 23
      156:  655:			ok = 0;
      156:  656:			break;
      156:  656-block  0
unconditional  0 taken 156
        -:  657:		}
       23:  658:		p++;
       23:  659:		i++;
       23:  659-block  0
unconditional  0 taken 23
        -:  660:	}
        -:  661:
      181:  662:	if (ok && c <= 1)
      181:  662-block  0
branch  0 taken 25 (fallthrough)
branch  1 taken 156
       25:  662-block  1
branch  2 taken 25 (fallthrough)
branch  3 taken 0
       25:  663:		return 1;
       25:  663-block  0
unconditional  0 taken 25
      156:  664:	return 0;
      156:  664-block  0
unconditional  0 taken 156
        -:  665:}
        -:  666:
        -:  667:static char *
function split_fusedcmd called 14 returned 100% blocks executed 73%
       14:  668:split_fusedcmd(char *str)
        -:  669:{
       14:  670:	if (!str || !*str || *str == ';' || *str == ':' || *str == '\\')
       14:  670-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14:  670-block  1
branch  2 taken 14 (fallthrough)
branch  3 taken 0
       14:  670-block  2
branch  4 taken 14 (fallthrough)
branch  5 taken 0
       14:  670-block  3
branch  6 taken 14 (fallthrough)
branch  7 taken 0
       14:  670-block  4
branch  8 taken 0 (fallthrough)
branch  9 taken 14
    #####:  671:		return (char *)NULL;
    %%%%%:  671-block  0
unconditional  0 never executed
        -:  672:
       14:  673:	char *space = strchr(str, ' ');
       14:  674:	char *slash = strchr(str, '/');
        -:  675:
       14:  676:	if (!space && slash) /* If "/some/path/" */
       14:  676-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 8
        6:  676-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 4
        2:  677:		return (char *)NULL;
        2:  677-block  0
unconditional  0 taken 2
        -:  678:
       12:  679:	if (space && slash && slash < space) /* If "/some/string something" */
       12:  679-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 4
        8:  679-block  1
branch  2 taken 5 (fallthrough)
branch  3 taken 3
        5:  679-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 5
    #####:  680:		return (char *)NULL;
    %%%%%:  680-block  0
unconditional  0 never executed
        -:  681:
        -:  682:	/* The buffer size is the double of STR, just in case each subtr
        -:  683:	 * needs to be splitted */
       12:  684:	char *buf = (char *)xnmalloc(((strlen(str) * 2) + 2), sizeof(char));
       12:  684-block  0
call    0 returned 12
        -:  685:
       12:  686:	char *p = str, *pp = str;
       12:  687:	char *q = buf;
       12:  688:	char *s = (char *)NULL;
       12:  689:	size_t word_n = 1;
       12:  690:	size_t c = 0;
        -:  691:
      193:  692:	while (*p) {
unconditional  0 taken 12
      193:  692-block  0
branch  1 taken 181
branch  2 taken 12 (fallthrough)
      181:  693:		switch(*p) {
      181:  693-block  0
branch  0 taken 14
branch  1 taken 0
branch  2 taken 167
       14:  694:		case ' ':
        -:  695:			/* We only allow splitting for first command word */
       14:  696:			s = p; /* Pointer to last space */
       14:  697:			if (c && *(p - 1) != ' ' && *(p - 1) != '|'
       14:  697-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14:  697-block  1
branch  2 taken 14 (fallthrough)
branch  3 taken 0
       14:  697-block  2
branch  4 taken 14 (fallthrough)
branch  5 taken 0
       14:  698:			&& *(p - 1) != '&' && *(p - 1) != ';')
       14:  698-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14:  698-block  1
branch  2 taken 14 (fallthrough)
branch  3 taken 0
       14:  699:				word_n++;
       14:  699-block  0
unconditional  0 taken 14
       14:  700:			break;
       14:  700-block  0
unconditional  0 taken 14
    #####:  701:		case '|': /* fallthrough */
        -:  702:		case '&': /* fallthrough */
    #####:  703:		case ';': word_n = 1; break;
    %%%%%:  703-block  0
unconditional  0 never executed
      167:  704:		default: break;
      167:  704-block  0
unconditional  0 taken 167
        -:  705:		}
        -:  706:
        -:  707:		/* Transform "cmdeln" into "cmd eln" */
      181:  708:		if (check_fused_param(p)) {
      181:  708-block  0
call    0 returned 181
branch  1 taken 25 (fallthrough)
branch  2 taken 156
        -:  709:			/* If a number, move from last to next space/nul looking for
        -:  710:			 * a slash. If found, do nothing */
       25:  711:			if (s) {
       25:  711-block  0
branch  0 taken 21 (fallthrough)
branch  1 taken 4
       21:  712:				if (word_n > 1) {
       21:  712-block  0
branch  0 taken 21 (fallthrough)
branch  1 taken 0
       21:  713:					*(q++) = *(p++);
       21:  714:					continue;
       21:  714-block  0
unconditional  0 taken 21
        -:  715:				}
        -:  716:
    #####:  717:				int _cont = 0;
    #####:  718:				char *ss = s + 1;
    #####:  719:				while (*ss && *ss != ' ') {
    %%%%%:  719-block  0
unconditional  0 never executed
    %%%%%:  719-block  1
branch  1 never executed
branch  2 never executed
    %%%%%:  719-block  2
branch  3 never executed
branch  4 never executed
    #####:  720:					if (*ss == '/') {
    %%%%%:  720-block  0
branch  0 never executed
branch  1 never executed
    #####:  721:						_cont = 1;
    #####:  722:						break;
    %%%%%:  722-block  0
unconditional  0 never executed
        -:  723:					}
    #####:  724:					ss++;
    %%%%%:  724-block  0
unconditional  0 never executed
        -:  725:				}
    #####:  726:				if (_cont) {
    %%%%%:  726-block  0
branch  0 never executed
branch  1 never executed
    #####:  727:					*(q++) = *(p++);
    #####:  728:					continue;
    %%%%%:  728-block  0
unconditional  0 never executed
        -:  729:				}
        -:  730:			}
        -:  731:
        4:  732:			char tmp = *p;
        4:  733:			*p = '\0';
        -:  734:
       4*:  735:			if (!is_internal_c(pp)) {
        4:  735-block  0
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
    #####:  736:				*p = tmp;
    #####:  737:				*(q++) = *(p++);
    #####:  738:				continue;
    %%%%%:  738-block  0
unconditional  0 never executed
        -:  739:			}
        -:  740:
        4:  741:			*p = tmp;
        4:  742:			*(q++) = ' ';
        4:  743:			*(q++) = *(p++);
        4:  743-block  0
unconditional  0 taken 4
        -:  744:		}
        -:  745:
        -:  746:		else {
     156*:  747:			if (*p == ' ' && *(p + 1))
      156:  747-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 156
    %%%%%:  747-block  1
branch  2 never executed
branch  3 never executed
    #####:  748:				pp = p + 1;
    %%%%%:  748-block  0
unconditional  0 never executed
      156:  749:			*(q++) = *(p++);
      156:  749-block  0
unconditional  0 taken 156
        -:  750:		}
        -:  751:
      160:  752:		c++;
      160:  752-block  0
unconditional  0 taken 160
        -:  753:	}
        -:  754:
       12:  755:	*q = '\0';
        -:  756:
        -:  757:	/* Readjust the buffer size */
       12:  758:	size_t len = strlen(buf);
       12:  759:	buf = (char *)xrealloc(buf, (len + 1) * sizeof(char));
       12:  759-block  0
call    0 returned 12
       12:  760:	return buf;
unconditional  0 taken 12
        -:  761:}
        -:  762:
        -:  763:/*
        -:  764: * This function is one of the keys of CliFM. It will perform a series of
        -:  765: * actions:
        -:  766: * 1) Take the string stored by readline and get its substrings without
        -:  767: * spaces.
        -:  768: * 2) In case of user defined variable (var=value), it will pass the
        -:  769: * whole string to exec_cmd(), which will take care of storing the
        -:  770: * variable;
        -:  771: * 3) If the input string begins with ';' or ':' the whole string is
        -:  772: * send to exec_cmd(), where it will be directly executed by the system
        -:  773: * shell (via launch_execle()) to prevent all of the expansions made
        -:  774: * here.
        -:  775: * 4) The following expansions (especific to CLiFM) are performed here:
        -:  776: * ELN's, "sel" keyword, ranges of numbers (ELN's), pinned dir and
        -:  777: * bookmark names, and, for internal commands only, tilde, braces,
        -:  778: * wildcards, command and paramenter substitution, and regex expansion
        -:  779: * are performed here as well.
        -:  780: * These expansions are the most import part of this function.
        -:  781: */
        -:  782:
        -:  783:/* NOTE: Though file names could consist of everything except of slash
        -:  784: * and null characters, POSIX.1 recommends restricting file names to
        -:  785: * consist of the following characters: letters (a-z, A-Z), numbers
        -:  786: * (0-9), period (.), dash (-), and underscore ( _ ).
        -:  787:
        -:  788: * NOTE 2: There is no any need to pass anything to this function, since
        -:  789: * the input string I need here is already in the readline buffer. So,
        -:  790: * instead of taking the buffer from a function parameter (str) I could
        -:  791: * simply use rl_line_buffer. However, since I use this function to
        -:  792: * parse other strings, like history lines, I need to keep the str
        -:  793: * argument */
        -:  794:char **
function parse_input_str called 503 returned 100% blocks executed 53%
      503:  795:parse_input_str(char *str)
        -:  796:{
      503:  797:	register size_t i = 0;
      503:  798:	int fusedcmd_ok = 0;
        -:  799:
        -:  800:	/** ###################### */
        -:  801:	/* Before splitting 'CMDNUM' into 'CMD NUM', make sure CMDNUM is not
        -:  802:	 * a cmd in PATH (for example, md5sum) */
      503:  803:	if (digit_found(str) && !is_bin_cmd(str)) {
      503:  803-block  0
call    0 returned 503
branch  1 taken 15 (fallthrough)
branch  2 taken 488
       15:  803-block  1
call    3 returned 15
branch  4 taken 14 (fallthrough)
branch  5 taken 1
       14:  804:		char *p = split_fusedcmd(str);
       14:  804-block  0
call    0 returned 14
       14:  805:		if (p) {
branch  0 taken 12 (fallthrough)
branch  1 taken 2
       12:  806:			fusedcmd_ok = 1;
       12:  807:			str = p;
       12:  808:			p = (char *)NULL;
       12:  808-block  0
unconditional  0 taken 12
        -:  809:		}
        -:  810:	}
        -:  811:	/** ###################### */
        -:  812:
        -:  813:			/* ########################################
        -:  814:			* #    0) CHECK FOR SPECIAL FUNCTIONS    #
        -:  815:			* ########################################*/
        -:  816:
      503:  817:	int chaining = 0, cond_cmd = 0, send_shell = 0;
        -:  818:
        -:  819:				/* ###########################
        -:  820:				 * #  0.a) RUN AS EXTERNAL   #
        -:  821:				 * ###########################*/
        -:  822:
        -:  823:	/* If invoking a command via ';' or ':' set the send_shell flag to
        -:  824:	 * true and send the whole string to exec_cmd(), in which case no
        -:  825:	 * expansion is made: the command is send to the system shell as
        -:  826:	 * is. */
      503:  827:	if (*str == ';' || *str == ':')
      503:  827-block  0
branch  0 taken 501 (fallthrough)
branch  1 taken 2
      501:  827-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 500
        3:  828:		send_shell = 1;
        3:  828-block  0
unconditional  0 taken 3
        -:  829:
      503:  830:	if (!send_shell) {
      503:  830-block  0
branch  0 taken 500 (fallthrough)
branch  1 taken 3
     2583:  831:		for (i = 0; str[i]; i++) {
      500:  831-block  0
unconditional  0 taken 500
     2083:  831-block  1
unconditional  1 taken 2083
     2583:  831-block  2
branch  2 taken 2083
branch  3 taken 500 (fallthrough)
        -:  832:
        -:  833:				/* ##################################
        -:  834:				 * #   0.b) CONDITIONAL EXECUTION   #
        -:  835:				 * ##################################*/
        -:  836:
        -:  837:			/* Check for chained commands (cmd1;cmd2) */
    2083*:  838:			if (!chaining && str[i] == ';' && i > 0 && str[i - 1] != '\\')
     2083:  838-block  0
branch  0 taken 2083 (fallthrough)
branch  1 taken 0
     2083:  838-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2083
    %%%%%:  838-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  838-block  3
branch  6 never executed
branch  7 never executed
    #####:  839:				chaining = 1;
    %%%%%:  839-block  0
unconditional  0 never executed
        -:  840:
        -:  841:			/* Check for conditional execution (cmd1 && cmd 2)*/
     2083:  842:			if (!cond_cmd && str[i] == '&' && i > 0 && str[i - 1] != '\\'
     2083:  842-block  0
branch  0 taken 2083 (fallthrough)
branch  1 taken 0
     2083:  842-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 2081
        2:  842-block  2
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        2:  842-block  3
branch  6 taken 2 (fallthrough)
branch  7 taken 0
       2*:  843:			&& str[i + 1] && str[i + 1] == '&')
        2:  843-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  843-block  1
branch  2 never executed
branch  3 never executed
    #####:  844:				cond_cmd = 1;
    %%%%%:  844-block  0
unconditional  0 never executed
        -:  845:
        -:  846:				/* ##################################
        -:  847:				 * #   0.c) USER DEFINED VARIABLE   #
        -:  848:				 * ##################################*/
        -:  849:
        -:  850:			/* If user defined variable send the whole string to
        -:  851:			 * exec_cmd(), which will take care of storing the
        -:  852:			 * variable. */
    2083*:  853:			if (!(flags & IS_USRVAR_DEF) && str[i] == '=' && i > 0
     2083:  853-block  0
branch  0 taken 2083 (fallthrough)
branch  1 taken 0
     2083:  853-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2083
    %%%%%:  853-block  2
branch  4 never executed
branch  5 never executed
    #####:  854:			&& str[i - 1] != '\\' && str[0] != '=') {
    %%%%%:  854-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  854-block  1
branch  2 never executed
branch  3 never executed
        -:  855:				/* Remove leading spaces. This: '   a="test"' should be
        -:  856:				 * taken as a valid variable declaration */
    #####:  857:				char *p = str;
    #####:  858:				while (*p == ' ' || *p == '\t')
    %%%%%:  858-block  0
unconditional  0 never executed
    %%%%%:  858-block  1
branch  1 never executed
branch  2 never executed
    %%%%%:  858-block  2
branch  3 never executed
branch  4 never executed
    #####:  859:					p++;
    %%%%%:  859-block  0
unconditional  0 never executed
        -:  860:
        -:  861:				/* If first non-space is a number, it's not a variable
        -:  862:				 * name */
    #####:  863:				if (!_ISDIGIT(*p)) {
    %%%%%:  863-block  0
branch  0 never executed
branch  1 never executed
    #####:  864:					int space_found = 0;
        -:  865:					/* If there are no spaces before '=', take it as a
        -:  866:					 * variable. This check is done in order to avoid
        -:  867:					 * taking as a variable things like:
        -:  868:					 * 'ls -color=auto' */
    #####:  869:					while (*p != '=') {
    %%%%%:  869-block  0
unconditional  0 never executed
    %%%%%:  869-block  1
branch  1 never executed
branch  2 never executed
    #####:  870:						if (*(p++) == ' ')
    %%%%%:  870-block  0
branch  0 never executed
branch  1 never executed
    #####:  871:							space_found = 1;
    %%%%%:  871-block  0
unconditional  0 never executed
        -:  872:					}
        -:  873:
    #####:  874:					if (!space_found)
    %%%%%:  874-block  0
branch  0 never executed
branch  1 never executed
    #####:  875:						flags |= IS_USRVAR_DEF;
    %%%%%:  875-block  0
unconditional  0 never executed
        -:  876:				}
        -:  877:
    #####:  878:				p = (char *)NULL;
    %%%%%:  878-block  0
unconditional  0 never executed
        -:  879:			}
        -:  880:		}
        -:  881:	}
        -:  882:
        -:  883:	/* If chained commands, check each of them. If at least one of them
        -:  884:	 * is internal, take care of the job (the system shell does not know
        -:  885:	 * our internal commands and therefore cannot execute them); else,
        -:  886:	 * if no internal command is found, let it to the system shell */
      503:  887:	if (chaining || cond_cmd) {
      503:  887-block  0
branch  0 taken 503 (fallthrough)
branch  1 taken 0
      503:  887-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 503
        -:  888:		/* User defined variables are always internal, so that there is
        -:  889:		 * no need to check whatever else is in the command string */
    #####:  890:		if (flags & IS_USRVAR_DEF) {
    %%%%%:  890-block  0
branch  0 never executed
branch  1 never executed
    #####:  891:			exec_chained_cmds(str);
    %%%%%:  891-block  0
call    0 never executed
    #####:  892:			if (fusedcmd_ok)
branch  0 never executed
branch  1 never executed
    #####:  893:				free(str);
    %%%%%:  893-block  0
unconditional  0 never executed
    #####:  894:			return (char **)NULL;
    %%%%%:  894-block  0
unconditional  0 never executed
        -:  895:		}
        -:  896:
    #####:  897:		register size_t j = 0;
    #####:  898:		size_t str_len = strlen(str), len = 0, internal_ok = 0;
    #####:  899:		char *buf = (char *)NULL;
        -:  900:
        -:  901:		/* Get each word (cmd) in STR */
    #####:  902:		buf = (char *)xcalloc(str_len + 1, sizeof(char));
    %%%%%:  902-block  0
call    0 never executed
    #####:  903:		for (j = 0; j < str_len; j++) {
unconditional  0 never executed
    %%%%%:  903-block  0
branch  1 never executed
branch  2 never executed
    #####:  904:			while (str[j] && str[j] != ' ' && str[j] != ';' && str[j] != '&') {
    %%%%%:  904-block  0
unconditional  0 never executed
    %%%%%:  904-block  1
branch  1 never executed
branch  2 never executed
    %%%%%:  904-block  2
branch  3 never executed
branch  4 never executed
    %%%%%:  904-block  3
branch  5 never executed
branch  6 never executed
    %%%%%:  904-block  4
branch  7 never executed
branch  8 never executed
    #####:  905:				buf[len++] = str[j++];
    %%%%%:  905-block  0
unconditional  0 never executed
        -:  906:			}
        -:  907:
    #####:  908:			if (strcmp(buf, "&&") != 0) {
    %%%%%:  908-block  0
branch  0 never executed
branch  1 never executed
    #####:  909:				if (is_internal_c(buf)) {
    %%%%%:  909-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  910:					internal_ok = 1;
    #####:  911:					break;
    %%%%%:  911-block  0
unconditional  0 never executed
        -:  912:				}
        -:  913:			}
        -:  914:
    #####:  915:			memset(buf, '\0', len);
    #####:  916:			len = 0;
    %%%%%:  916-block  0
unconditional  0 never executed
        -:  917:		}
        -:  918:
    #####:  919:		free(buf);
    #####:  920:		buf = (char *)NULL;
        -:  921:
    #####:  922:		if (internal_ok) {
    %%%%%:  922-block  0
branch  0 never executed
branch  1 never executed
    #####:  923:			exec_chained_cmds(str);
    %%%%%:  923-block  0
call    0 never executed
    #####:  924:			if (fusedcmd_ok)
branch  0 never executed
branch  1 never executed
    #####:  925:				free(str);
    %%%%%:  925-block  0
unconditional  0 never executed
    #####:  926:			return (char **)NULL;
    %%%%%:  926-block  0
unconditional  0 never executed
        -:  927:		}
        -:  928:	}
        -:  929:
      503:  930:	if (flags & IS_USRVAR_DEF || send_shell) {
      503:  930-block  0
branch  0 taken 503 (fallthrough)
branch  1 taken 0
      503:  930-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 500
        -:  931:		/* Remove leading spaces, again */
        3:  932:		char *p = str;
        3:  933:		while (*p == ' ' || *p == '\t')
        3:  933-block  0
unconditional  0 taken 3
        3:  933-block  1
branch  1 taken 0
branch  2 taken 3 (fallthrough)
        3:  933-block  2
branch  3 taken 0
branch  4 taken 3 (fallthrough)
    #####:  934:			p++;
    %%%%%:  934-block  0
unconditional  0 never executed
        -:  935:
        3:  936:		args_n = 0;
        -:  937:
        3:  938:		char **cmd = (char **)NULL;
        3:  939:		cmd = (char **)xnmalloc(2, sizeof(char *));
        3:  939-block  0
call    0 returned 3
        3:  940:		cmd[0] = savestring(p, strlen(p));
call    0 returned 3
        3:  941:		cmd[1] = (char *)NULL;
        -:  942:
        3:  943:		p = (char *)NULL;
        -:  944:
        3:  945:		if (fusedcmd_ok)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  946:			free(str);
    %%%%%:  946-block  0
unconditional  0 never executed
        -:  947:
        3:  948:		return cmd;
        3:  948-block  0
unconditional  0 taken 3
        -:  949:		/* If ";cmd" or ":cmd" the whole input line will be send to
        -:  950:		 * exec_cmd() and will be executed by the system shell via
        -:  951:		 * execle(). Since we don't run split_str() here, dequoting
        -:  952:		 * and deescaping is performed directly by the system shell */
        -:  953:	}
        -:  954:
        -:  955:		/* ################################################
        -:  956:		 * #     1) SPLIT INPUT STRING INTO SUBSTRINGS    #
        -:  957:		 * ################################################ */
        -:  958:
        -:  959:	/* split_str() returns an array of strings without leading,
        -:  960:	 * terminating and double spaces. */
      500:  961:	char **substr = split_str(str);
      500:  961-block  0
call    0 returned 500
        -:  962:
        -:  963:	/** ###################### */
      500:  964:	if (fusedcmd_ok) /* Just in case split_fusedcmd returned NULL */
branch  0 taken 12 (fallthrough)
branch  1 taken 488
       12:  965:		free(str);
       12:  965-block  0
unconditional  0 taken 12
        -:  966:	/** ###################### */
        -:  967:
        -:  968:	/* NOTE: isspace() not only checks for space, but also for new line,
        -:  969:	 * carriage return, vertical and horizontal TAB. Be careful when
        -:  970:	 * replacing this function. */
        -:  971:
      500:  972:	if (!substr)
      500:  972-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 500
    #####:  973:		return (char **)NULL;
    %%%%%:  973-block  0
unconditional  0 never executed
        -:  974:
        -:  975:	/* Handle background/foreground process */
      500:  976:	bg_proc = 0;
        -:  977:
      500:  978:	if (*substr[args_n] == '&' && !*(substr[args_n] + 1)) {
      500:  978-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 499
        1:  978-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  979:		bg_proc = 1;
        1:  980:		free(substr[args_n]);
        1:  981:		substr[args_n--] = (char *)NULL;
        1:  981-block  0
unconditional  0 taken 1
        -:  982:	} else {
      499:  983:		size_t len = strlen(substr[args_n]);
      499:  984:		if (substr[args_n][len - 1] == '&' && !substr[args_n][len]) {
      499:  984-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 498
        1:  984-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  985:			substr[args_n][len - 1] = '\0';
        1:  986:			bg_proc = 1;
        1:  986-block  0
unconditional  0 taken 1
        -:  987:		}
        -:  988:	}
        -:  989:
        -:  990:					/* ######################
        -:  991:					 * #     TRASH AS RM    #
        -:  992:					 * ###################### */
        -:  993:#ifndef _NO_TRASH
     500*:  994:	if (tr_as_rm && substr[0] && *substr[0] == 'r' && !substr[0][1]) {
      500:  994-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 500
    %%%%%:  994-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  994-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  994-block  3
branch  6 never executed
branch  7 never executed
    #####:  995:		substr[0] = (char *)xrealloc(substr[0], 3 * sizeof(char));
    %%%%%:  995-block  0
call    0 never executed
    #####:  996:		*substr[0] = 't';
    #####:  997:		substr[0][1] = 'r';
    #####:  998:		substr[0][2] = '\0';
unconditional  0 never executed
        -:  999:	}
        -: 1000:#endif
        -: 1001:				/* ##############################
        -: 1002:				 * #   2) BUILTIN EXPANSIONS    #
        -: 1003:				 * ##############################
        -: 1004:
        -: 1005:	 * Ranges, sel, ELN, pinned dirs, bookmarks, and internal variables.
        -: 1006:	 * These expansions are specific to CliFM. To be able to use them
        -: 1007:	 * even with external commands, they must be expanded here, before
        -: 1008:	 * sending the input string, in case the command is external, to
        -: 1009:	 * the system shell */
        -: 1010:
      500: 1011:	is_sel = 0, sel_is_last = 0;
        -: 1012:
      500: 1013:	size_t int_array_max = 10, ranges_ok = 0;
      500: 1014:	int *range_array = (int *)xnmalloc(int_array_max, sizeof(int));
      500: 1014-block  0
call    0 returned 500
        -: 1015:
     1200: 1016:	for (i = 0; i <= args_n; i++) {
unconditional  0 taken 500
      700: 1016-block  0
unconditional  1 taken 700
     1200: 1016-block  1
branch  2 taken 700
branch  3 taken 500 (fallthrough)
     700*: 1017:		if (!substr[i])
      700: 1017-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 700
    #####: 1018:			continue;
    %%%%%: 1018-block  0
unconditional  0 never executed
        -: 1019:
      700: 1020:		register size_t j = 0;
        -: 1021:		/* Replace . and .. by absolute paths */
      700: 1022:		if (*substr[i] == '.' && (!substr[i][1] || (substr[i][1] == '.'
      700: 1022-block  0
branch  0 taken 16 (fallthrough)
branch  1 taken 684
       16: 1022-block  1
branch  2 taken 13 (fallthrough)
branch  3 taken 3
       13: 1022-block  2
branch  4 taken 12 (fallthrough)
branch  5 taken 1
       12: 1023:		&& !substr[i][2]))) {
       12: 1023-block  0
branch  0 taken 11 (fallthrough)
branch  1 taken 1
       14: 1024:			char *tmp = (char *)NULL;
       14: 1025:			tmp = realpath(substr[i], NULL);
       14: 1025-block  0
call    0 returned 14
       14: 1026:			substr[i] = (char *)xrealloc(substr[i], (strlen(tmp) + 1)
call    0 returned 14
        -: 1027:											* sizeof(char));
       14: 1028:			strcpy(substr[i], tmp);
       14: 1029:			free(tmp);
unconditional  0 taken 14
        -: 1030:		}
        -: 1031:
        -: 1032:			/* ######################################
        -: 1033:			 * #     2.a) FASTBACK EXPANSION        #
        -: 1034:			 * ###################################### */
        -: 1035:
      700: 1036:		if (*substr[i] == '.' && substr[i][1] == '.' && substr[i][2] == '.') {
      700: 1036-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 698
        2: 1036-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        1: 1036-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1: 1037:			char *tmp = fastback(substr[i]);
        1: 1037-block  0
call    0 returned 1
        1: 1038:			if (tmp) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1039:				substr[i] = (char *)xrealloc(substr[i], (strlen(tmp) + 1)
        1: 1039-block  0
call    0 returned 1
        -: 1040:														* sizeof(char));
        1: 1041:				strcpy(substr[i], tmp);
        1: 1042:				free(tmp);
unconditional  0 taken 1
        -: 1043:			}
        -: 1044:		}
        -: 1045:
        -: 1046:			/* ######################################
        -: 1047:			 * #     2.b) PINNED DIR EXPANSION      #
        -: 1048:			 * ###################################### */
        -: 1049:
      700: 1050:		if (*substr[i] == ',' && !substr[i][1] && pinned_dir) {
      700: 1050-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 697
        3: 1050-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3: 1050-block  2
branch  4 taken 3 (fallthrough)
branch  5 taken 0
        3: 1051:			substr[i] = (char *)xrealloc(substr[i], (strlen(pinned_dir) + 1)
        3: 1051-block  0
call    0 returned 3
        -: 1052:													* sizeof(char));
        3: 1053:			strcpy(substr[i], pinned_dir);
unconditional  0 taken 3
        -: 1054:		}
        -: 1055:
        -: 1056:			/* ######################################
        -: 1057:			 * #      2.c) BOOKMARKS EXPANSION      #
        -: 1058:			 * ###################################### */
        -: 1059:
        -: 1060:		/* Expand bookmark names into paths */
      700: 1061:		if (expand_bookmarks) {
      700: 1061-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 700
    #####: 1062:			int bm_exp = 0;
        -: 1063:
    #####: 1064:			for (j = 0; j < bm_n; j++) {
    %%%%%: 1064-block  0
unconditional  0 never executed
    %%%%%: 1064-block  1
unconditional  1 never executed
    %%%%%: 1064-block  2
branch  2 never executed
branch  3 never executed
    #####: 1065:				if (bookmarks[j].name && *substr[i] == *bookmarks[j].name
    %%%%%: 1065-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1065-block  1
branch  2 never executed
branch  3 never executed
    #####: 1066:				&& strcmp(substr[i], bookmarks[j].name) == 0) {
    %%%%%: 1066-block  0
branch  0 never executed
branch  1 never executed
        -: 1067:
        -: 1068:					/* Do not expand bookmark names that conflicts
        -: 1069:					 * with a file name in CWD */
    #####: 1070:					int conflict = 0, k = (int)files;
    #####: 1071:					while (--k >= 0) {
    %%%%%: 1071-block  0
unconditional  0 never executed
    %%%%%: 1071-block  1
branch  1 never executed
branch  2 never executed
    #####: 1072:						if (*bookmarks[j].name == *file_info[k].name
    %%%%%: 1072-block  0
branch  0 never executed
branch  1 never executed
    #####: 1073:						&& strcmp(bookmarks[j].name, file_info[k].name) == 0) {
    %%%%%: 1073-block  0
branch  0 never executed
branch  1 never executed
    #####: 1074:							conflict = 1;
    #####: 1075:							break;
    %%%%%: 1075-block  0
unconditional  0 never executed
        -: 1076:						}
        -: 1077:					}
        -: 1078:
    #####: 1079:					if (!conflict && bookmarks[j].path) {
    %%%%%: 1079-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1079-block  1
branch  2 never executed
branch  3 never executed
    #####: 1080:						substr[i] = (char *)xrealloc(substr[i],
    #####: 1081:						    (strlen(bookmarks[j].path) + 1) * sizeof(char));
    %%%%%: 1081-block  0
call    0 never executed
    #####: 1082:						strcpy(substr[i], bookmarks[j].path);
        -: 1083:
    #####: 1084:						bm_exp = 1;
        -: 1085:
    #####: 1086:						break;
unconditional  0 never executed
        -: 1087:					}
        -: 1088:				}
        -: 1089:			}
        -: 1090:
        -: 1091:			/* Do not perform further checks on the expanded bookmark */
    #####: 1092:			if (bm_exp)
    %%%%%: 1092-block  0
branch  0 never executed
branch  1 never executed
    #####: 1093:				continue;
    %%%%%: 1093-block  0
unconditional  0 never executed
        -: 1094:		}
        -: 1095:
        -: 1096:		/* ############################################# */
        -: 1097:
      700: 1098:		size_t substr_len = strlen(substr[i]);
        -: 1099:
        -: 1100:		/* Check for ranges */
      805: 1101:		for (j = 0; substr[i][j]; j++) {
      700: 1101-block  0
unconditional  0 taken 700
      105: 1101-block  1
unconditional  1 taken 105
      805: 1101-block  2
branch  2 taken 732
branch  3 taken 73 (fallthrough)
        -: 1102:			/* If some alphabetic char, besides '-', is found in the
        -: 1103:			 * string, we have no range */
      732: 1104:			if (substr[i][j] != '-' && !_ISDIGIT(substr[i][j]))
      732: 1104-block  0
branch  0 taken 712 (fallthrough)
branch  1 taken 20
      712: 1104-block  1
branch  2 taken 627 (fallthrough)
branch  3 taken 85
      627: 1105:				break;
      627: 1105-block  0
unconditional  0 taken 627
        -: 1106:
        -: 1107:			/* If a range is found, store its index */
      105: 1108:			if (j > 0 && j < substr_len && substr[i][j] == '-' &&
      105: 1108-block  0
branch  0 taken 24 (fallthrough)
branch  1 taken 81
       24: 1108-block  1
branch  2 taken 24 (fallthrough)
branch  3 taken 0
       24: 1108-block  2
branch  4 taken 9 (fallthrough)
branch  5 taken 15
        9: 1109:			    _ISDIGIT(substr[i][j - 1]) && _ISDIGIT(substr[i][j + 1]))
        9: 1109-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 5
        4: 1109-block  1
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        4: 1110:				if (ranges_ok < int_array_max)
        4: 1110-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1111:					range_array[ranges_ok++] = (int)i;
        4: 1111-block  0
unconditional  0 taken 4
        -: 1112:		}
        -: 1113:
        -: 1114:		/* Expand 'sel' only as an argument, not as command */
      700: 1115:		if (i > 0 && *substr[i] == 's' && strcmp(substr[i], "sel") == 0)
      700: 1115-block  0
branch  0 taken 200 (fallthrough)
branch  1 taken 500
      200: 1115-block  1
branch  2 taken 18 (fallthrough)
branch  3 taken 182
       18: 1115-block  2
branch  4 taken 9 (fallthrough)
branch  5 taken 9
        9: 1116:			is_sel = (short)i;
        9: 1116-block  0
unconditional  0 taken 9
        -: 1117:	}
        -: 1118:
        -: 1119:			/* ####################################
        -: 1120:			 * #       2.d) RANGES EXPANSION      #
        -: 1121:			 * ####################################*/
        -: 1122:
        -: 1123:	/* Expand expressions like "1-3" to "1 2 3" if all the numbers in
        -: 1124:	  * the range correspond to an ELN */
        -: 1125:
      500: 1126:	if (ranges_ok) {
      500: 1126-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 496
        4: 1127:		size_t old_ranges_n = 0;
        4: 1128:		register size_t r = 0;
        -: 1129:
        8: 1130:		for (r = 0; r < ranges_ok; r++) {
        4: 1130-block  0
unconditional  0 taken 4
        8: 1130-block  1
branch  1 taken 4
branch  2 taken 4 (fallthrough)
        4: 1131:			size_t ranges_n = 0;
        4: 1132:			int *ranges = expand_range(substr[range_array[r] +
        4: 1133:							  (int)old_ranges_n], 1);
        4: 1133-block  0
call    0 returned 4
        4: 1134:			if (ranges) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1135:				register size_t j = 0;
        -: 1136:
       18: 1137:				for (ranges_n = 0; ranges[ranges_n]; ranges_n++);
        4: 1137-block  0
unconditional  0 taken 4
       14: 1137-block  1
unconditional  1 taken 14
       18: 1137-block  2
branch  2 taken 14
branch  3 taken 4 (fallthrough)
        -: 1138:
        4: 1139:				char **ranges_cmd = (char **)NULL;
        4: 1140:				ranges_cmd = (char **)xcalloc(args_n + ranges_n + 2,
        4: 1140-block  0
call    0 returned 4
        -: 1141:				    sizeof(char *));
        -: 1142:
        8: 1143:				for (i = 0; i < (size_t)range_array[r] + old_ranges_n; i++)
unconditional  0 taken 4
        8: 1143-block  0
branch  1 taken 4
branch  2 taken 4 (fallthrough)
        4: 1144:					ranges_cmd[j++] = savestring(substr[i], strlen(substr[i]));
        4: 1144-block  0
call    0 returned 4
unconditional  1 taken 4
        -: 1145:
       18: 1146:				for (i = 0; i < ranges_n; i++) {
        4: 1146-block  0
unconditional  0 taken 4
       18: 1146-block  1
branch  1 taken 14
branch  2 taken 4 (fallthrough)
      14*: 1147:					ranges_cmd[j] = (char *)xcalloc((size_t)DIGINUM(ranges[i])
       14: 1147-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 14
    %%%%%: 1147-block  1
unconditional  2 never executed
       14: 1147-block  2
unconditional  3 taken 14
       14: 1147-block  3
call    4 returned 14
    #####: 1148:													+ 1, sizeof(int));
    %%%%%: 1148-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1148-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1148-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1148-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1148-block  4
branch  8 never executed
branch  9 never executed
    %%%%%: 1148-block  5
branch 10 never executed
branch 11 never executed
    %%%%%: 1148-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1148-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1148-block  8
unconditional 16 never executed
    %%%%%: 1148-block  9
unconditional 17 never executed
    %%%%%: 1148-block 10
unconditional 18 never executed
    %%%%%: 1148-block 11
unconditional 19 never executed
    %%%%%: 1148-block 12
unconditional 20 never executed
    %%%%%: 1148-block 13
unconditional 21 never executed
    %%%%%: 1148-block 14
unconditional 22 never executed
    %%%%%: 1148-block 15
unconditional 23 never executed
    %%%%%: 1148-block 16
unconditional 24 never executed
    %%%%%: 1148-block 17
unconditional 25 never executed
    %%%%%: 1148-block 18
unconditional 26 never executed
    %%%%%: 1148-block 19
unconditional 27 never executed
    %%%%%: 1148-block 20
unconditional 28 never executed
    %%%%%: 1148-block 21
unconditional 29 never executed
    %%%%%: 1148-block 22
unconditional 30 never executed
    %%%%%: 1148-block 23
unconditional 31 never executed
       14: 1149:					sprintf(ranges_cmd[j++], "%d", ranges[i]);
unconditional  0 taken 14
        -: 1150:				}
        -: 1151:
        4: 1152:				for (i = (size_t)range_array[r] + old_ranges_n + 1;
        4: 1152-block  0
unconditional  0 taken 4
       4*: 1153:				     i <= args_n; i++) {
        4: 1153-block  0
branch  0 taken 0
branch  1 taken 4 (fallthrough)
    #####: 1154:					ranges_cmd[j++] = savestring(substr[i],
unconditional  0 never executed
    #####: 1155:					    strlen(substr[i]));
    %%%%%: 1155-block  0
call    0 never executed
        -: 1156:				}
        -: 1157:
        4: 1158:				ranges_cmd[j] = NULL;
        4: 1159:				free(ranges);
        -: 1160:
       12: 1161:				for (i = 0; i <= args_n; i++)
        4: 1161-block  0
unconditional  0 taken 4
       12: 1161-block  1
branch  1 taken 8
branch  2 taken 4 (fallthrough)
        8: 1162:					free(substr[i]);
        8: 1162-block  0
unconditional  0 taken 8
        -: 1163:
        4: 1164:				substr = (char **)xrealloc(substr, (args_n + ranges_n + 2)
        4: 1164-block  0
call    0 returned 4
        -: 1165:													* sizeof(char *));
        -: 1166:
       22: 1167:				for (i = 0; i < j; i++) {
unconditional  0 taken 4
       22: 1167-block  0
branch  1 taken 18
branch  2 taken 4 (fallthrough)
       18: 1168:					substr[i] = savestring(ranges_cmd[i], strlen(ranges_cmd[i]));
       18: 1168-block  0
call    0 returned 18
       18: 1169:					free(ranges_cmd[i]);
unconditional  0 taken 18
        -: 1170:				}
        -: 1171:
        4: 1172:				free(ranges_cmd);
        4: 1173:				args_n = j - 1;
        4: 1173-block  0
unconditional  0 taken 4
        -: 1174:			}
        -: 1175:
        4: 1176:			old_ranges_n += (ranges_n - 1);
        4: 1176-block  0
unconditional  0 taken 4
        -: 1177:		}
        -: 1178:	}
        -: 1179:
      500: 1180:	free(range_array);
        -: 1181:
        -: 1182:				/* ##########################
        -: 1183:				 * #   2.e) SEL EXPANSION   #
        -: 1184:				 * ##########################*/
        -: 1185:
        -: 1186:	/*  if (is_sel && *substr[0] != '/') { */
      500: 1187:	if (is_sel) {
      500: 1187-block  0
branch  0 taken 9 (fallthrough)
branch  1 taken 491
        9: 1188:		if ((size_t)is_sel == args_n)
        9: 1188-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8: 1189:			sel_is_last = 1;
        8: 1189-block  0
unconditional  0 taken 8
        -: 1190:
        9: 1191:		if (sel_n) {
        9: 1191-block  0
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9: 1192:			register size_t j = 0;
        9: 1193:			char **sel_array = (char **)NULL;
        9: 1194:			sel_array = (char **)xnmalloc(args_n + sel_n + 2, sizeof(char *));
        9: 1194-block  0
call    0 returned 9
        -: 1195:
       18: 1196:			for (i = 0; i < (size_t)is_sel; i++) {
unconditional  0 taken 9
        9: 1196-block  0
unconditional  1 taken 9
       18: 1196-block  1
branch  2 taken 9
branch  3 taken 9 (fallthrough)
       9*: 1197:				if (!substr[i])
        9: 1197-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####: 1198:					continue;
    %%%%%: 1198-block  0
unconditional  0 never executed
        9: 1199:				sel_array[j++] = savestring(substr[i], strlen(substr[i]));
        9: 1199-block  0
call    0 returned 9
unconditional  1 taken 9
        -: 1200:			}
        -: 1201:
       29: 1202:			for (i = 0; i < sel_n; i++) {
        9: 1202-block  0
unconditional  0 taken 9
       20: 1202-block  1
unconditional  1 taken 20
       29: 1202-block  2
branch  2 taken 20
branch  3 taken 9 (fallthrough)
        -: 1203:				/* Escape selected file names and copy them into tmp
        -: 1204:				 * array */
       20: 1205:				char *esc_str = escape_str(sel_elements[i]);
       20: 1205-block  0
call    0 returned 20
       20: 1206:				if (esc_str) {
branch  0 taken 20 (fallthrough)
branch  1 taken 0
       20: 1207:					sel_array[j++] = savestring(esc_str, strlen(esc_str));
       20: 1207-block  0
call    0 returned 20
       20: 1208:					free(esc_str);
       20: 1209:					esc_str = (char *)NULL;
unconditional  0 taken 20
        -: 1210:				} else {
    #####: 1211:					fprintf(stderr, _("%s: %s: Error quoting file name\n"),
call    0 never executed
    #####: 1212:					    PROGRAM_NAME, sel_elements[j]);
    %%%%%: 1212-block  0
call    0 never executed
        -: 1213:					/* Free elements selected thus far and and all the
        -: 1214:					 * input substrings */
    #####: 1215:					register size_t k = 0;
    #####: 1216:					for (k = 0; k < j; k++)
unconditional  0 never executed
    %%%%%: 1216-block  0
branch  1 never executed
branch  2 never executed
    #####: 1217:						free(sel_array[k]);
    %%%%%: 1217-block  0
unconditional  0 never executed
    #####: 1218:					free(sel_array);
        -: 1219:
    #####: 1220:					for (k = 0; k <= args_n; k++)
    %%%%%: 1220-block  0
unconditional  0 never executed
    %%%%%: 1220-block  1
branch  1 never executed
branch  2 never executed
    #####: 1221:						free(substr[k]);
    %%%%%: 1221-block  0
unconditional  0 never executed
    #####: 1222:					free(substr);
        -: 1223:
    #####: 1224:					return (char **)NULL;
    %%%%%: 1224-block  0
unconditional  0 never executed
        -: 1225:				}
        -: 1226:			}
        -: 1227:
       10: 1228:			for (i = (size_t)is_sel + 1; i <= args_n; i++)
        9: 1228-block  0
unconditional  0 taken 9
       10: 1228-block  1
branch  1 taken 1
branch  2 taken 9 (fallthrough)
        1: 1229:				sel_array[j++] = savestring(substr[i], strlen(substr[i]));
        1: 1229-block  0
call    0 returned 1
unconditional  1 taken 1
        -: 1230:
       28: 1231:			for (i = 0; i <= args_n; i++)
        9: 1231-block  0
unconditional  0 taken 9
       28: 1231-block  1
branch  1 taken 19
branch  2 taken 9 (fallthrough)
       19: 1232:				free(substr[i]);
       19: 1232-block  0
unconditional  0 taken 19
        -: 1233:
        9: 1234:			substr = (char **)xrealloc(substr, (args_n + sel_n + 2)
        9: 1234-block  0
call    0 returned 9
        -: 1235:										* sizeof(char *));
        -: 1236:
       39: 1237:			for (i = 0; i < j; i++) {
unconditional  0 taken 9
       39: 1237-block  0
branch  1 taken 30
branch  2 taken 9 (fallthrough)
       30: 1238:				substr[i] = savestring(sel_array[i], strlen(sel_array[i]));
       30: 1238-block  0
call    0 returned 30
       30: 1239:				free(sel_array[i]);
unconditional  0 taken 30
        -: 1240:			}
        -: 1241:
        9: 1242:			free(sel_array);
        9: 1243:			substr[i] = (char *)NULL;
        9: 1244:			args_n = j - 1;
        9: 1244-block  0
unconditional  0 taken 9
        -: 1245:		}
        -: 1246:
        -: 1247:		else {
        -: 1248:			/* 'sel' is an argument, but there are no selected files. */
    #####: 1249:			fprintf(stderr, _("%c%s: There are no selected files%c"),
    %%%%%: 1249-block  0
unconditional  0 never executed
    %%%%%: 1249-block  1
unconditional  1 never executed
    %%%%%: 1249-block  2
unconditional  2 never executed
    %%%%%: 1249-block  3
unconditional  3 never executed
    %%%%%: 1249-block  4
call    4 never executed
call    5 never executed
    #####: 1250:			    kb_shortcut ? '\n' : '\0', PROGRAM_NAME,
    %%%%%: 1250-block  0
branch  0 never executed
branch  1 never executed
    #####: 1251:			    kb_shortcut ? '\0' : '\n');
    %%%%%: 1251-block  0
branch  0 never executed
branch  1 never executed
        -: 1252:
    #####: 1253:			register size_t j = 0;
    #####: 1254:			for (j = 0; j <= args_n; j++)
unconditional  0 never executed
    %%%%%: 1254-block  0
branch  1 never executed
branch  2 never executed
    #####: 1255:				free(substr[j]);
    %%%%%: 1255-block  0
unconditional  0 never executed
    #####: 1256:			free(substr);
        -: 1257:
    #####: 1258:			return (char **)NULL;
    %%%%%: 1258-block  0
unconditional  0 never executed
        -: 1259:		}
        -: 1260:	}
        -: 1261:
      500: 1262:	int stdin_dir_ok = 0;
     500*: 1263:	if (stdin_tmp_dir && strcmp(ws[cur_ws].path, stdin_tmp_dir) == 0)
      500: 1263-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 500
    %%%%%: 1263-block  1
branch  2 never executed
branch  3 never executed
    #####: 1264:		stdin_dir_ok = 1;
    %%%%%: 1264-block  0
unconditional  0 never executed
        -: 1265:
     1221: 1266:	for (i = 0; i <= args_n; i++) {
      500: 1266-block  0
unconditional  0 taken 500
      721: 1266-block  1
unconditional  1 taken 721
     1221: 1266-block  2
branch  2 taken 721
branch  3 taken 500 (fallthrough)
     721*: 1267:		if (!substr[i])
      721: 1267-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 721
    #####: 1268:			continue;
    %%%%%: 1268-block  0
unconditional  0 never executed
        -: 1269:
        -: 1270:				/* ##########################
        -: 1271:				 * #   2.f) ELN EXPANSION   #
        -: 1272:				 * ##########################*/
        -: 1273:
        -: 1274:		/* If autocd is set to false, i must be bigger than zero because
        -: 1275:		 * the first string in comm_array, the command name, should NOT
        -: 1276:		 * be expanded, but only arguments. Otherwise, if the expanded
        -: 1277:		 * ELN happens to be a program name as well, this program will
        -: 1278:		 * be executed, and this, for sure, is to be avoided */
        -: 1279:
        -: 1280:		/* The 'sort', 'mf', 'ws', and 'jo' commands take digits as
        -: 1281:		 * arguments. So, do not expand ELN's in these cases */
      721: 1282:		if (substr[0] && strcmp(substr[0], "mf") != 0
      721: 1282-block  0
branch  0 taken 721 (fallthrough)
branch  1 taken 0
      721: 1282-block  1
branch  2 taken 717 (fallthrough)
branch  3 taken 4
      717: 1283:		&& strcmp(substr[0], "st") != 0 && strcmp(substr[0], "ws") != 0
      717: 1283-block  0
branch  0 taken 702 (fallthrough)
branch  1 taken 15
      702: 1283-block  1
branch  2 taken 666 (fallthrough)
branch  3 taken 36
      666: 1284:		&& strcmp(substr[0], "sort") != 0 && strcmp(substr[0], "jo") != 0) {
      666: 1284-block  0
branch  0 taken 666 (fallthrough)
branch  1 taken 0
      666: 1284-block  1
branch  2 taken 666 (fallthrough)
branch  3 taken 0
        -: 1285:
      666: 1286:			if (is_number(substr[i])) {
      666: 1286-block  0
call    0 returned 666
branch  1 taken 61 (fallthrough)
branch  2 taken 605
        -: 1287:				/* Expand first word only if autocd is set to true */
      61*: 1288:				if ((i == 0 && !autocd && !auto_open) || !substr[i])
       61: 1288-block  0
branch  0 taken 26 (fallthrough)
branch  1 taken 35
       26: 1288-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 25
        1: 1288-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
       61: 1288-block  3
branch  6 taken 0 (fallthrough)
branch  7 taken 61
    #####: 1289:					continue;
    %%%%%: 1289-block  0
unconditional  0 never executed
        -: 1290:
       61: 1291:				int num = atoi(substr[i]);
        -: 1292:				/* Expand numbers only if there is a corresponding ELN */
        -: 1293:
        -: 1294:				/* Do not expand ELN if there is a file named as the
        -: 1295:				 * ELN */
       61: 1296:				if (eln_as_file_n) {
       61: 1296-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 61
    #####: 1297:					int conflict = 0;
    #####: 1298:					if (eln_as_file_n > 1) {
    %%%%%: 1298-block  0
branch  0 never executed
branch  1 never executed
        -: 1299:						size_t j;
        -: 1300:
    #####: 1301:						for (j = 0; j < eln_as_file_n; j++) {
    %%%%%: 1301-block  0
unconditional  0 never executed
    %%%%%: 1301-block  1
unconditional  1 never executed
    %%%%%: 1301-block  2
branch  2 never executed
branch  3 never executed
    #####: 1302:							if (atoi(file_info[eln_as_file[j]].name) == num) {
    %%%%%: 1302-block  0
branch  0 never executed
branch  1 never executed
    #####: 1303:								conflict = num;
        -: 1304:								/* One conflicting file name is enough */
    #####: 1305:								break;
    %%%%%: 1305-block  0
unconditional  0 never executed
        -: 1306:							}
        -: 1307:						}
        -: 1308:					} else {
    #####: 1309:						if (atoi(file_info[eln_as_file[0]].name) == num)
    %%%%%: 1309-block  0
branch  0 never executed
branch  1 never executed
    #####: 1310:							conflict = num;
    %%%%%: 1310-block  0
unconditional  0 never executed
        -: 1311:					}
        -: 1312:
    #####: 1313:					if (conflict) {
    %%%%%: 1313-block  0
branch  0 never executed
branch  1 never executed
        -: 1314:						size_t j;
        -: 1315:
    #####: 1316:						for (j = 0; j <= args_n; j++)
    %%%%%: 1316-block  0
unconditional  0 never executed
    %%%%%: 1316-block  1
branch  1 never executed
branch  2 never executed
    #####: 1317:							free(substr[j]);
    %%%%%: 1317-block  0
unconditional  0 never executed
    #####: 1318:						free(substr);
        -: 1319:
    #####: 1320:						fprintf(stderr, _("%s: %d: ELN-filename "
    %%%%%: 1320-block  0
call    0 never executed
call    1 never executed
        -: 1321:							"conflict. Bypass internal expansions "
        -: 1322:							"to fix this issue: ';CMD "
        -: 1323:							"FILENAME'\n"), PROGRAM_NAME, conflict);
    #####: 1324:						return (char **)NULL;
unconditional  0 never executed
        -: 1325:					}
        -: 1326:				}
        -: 1327:
       61: 1328:				if (num > 0 && num <= (int)files) {
       61: 1328-block  0
branch  0 taken 61 (fallthrough)
branch  1 taken 0
       61: 1328-block  1
branch  2 taken 61 (fallthrough)
branch  3 taken 0
        -: 1329:					/* Replace the ELN by the corresponding escaped
        -: 1330:					 * file name */
       61: 1331:					int j = num - 1;
       61: 1332:					char *esc_str = escape_str(file_info[j].name);
       61: 1332-block  0
call    0 returned 61
        -: 1333:
       61: 1334:					if (esc_str) {
branch  0 taken 61 (fallthrough)
branch  1 taken 0
       61: 1335:						if (file_info[j].dir &&
       61: 1335-block  0
branch  0 taken 24 (fallthrough)
branch  1 taken 37
       24: 1336:						    file_info[j].name[file_info[j].len - 1] != '/') {
       24: 1336-block  0
branch  0 taken 24 (fallthrough)
branch  1 taken 0
       48: 1337:							substr[i] = (char *)xrealloc(substr[i],
       24: 1338:							    (strlen(esc_str) + 2) * sizeof(char));
       24: 1338-block  0
call    0 returned 24
       24: 1339:							sprintf(substr[i], "%s/", esc_str);
unconditional  0 taken 24
        -: 1340:						} else {
       74: 1341:							substr[i] = (char *)xrealloc(substr[i],
       37: 1342:							    (strlen(esc_str) + 1) * sizeof(char));
       37: 1342-block  0
call    0 returned 37
       37: 1343:							strcpy(substr[i], esc_str);
unconditional  0 taken 37
        -: 1344:						}
        -: 1345:
       61: 1346:						free(esc_str);
       61: 1347:						esc_str = (char *)NULL;
       61: 1347-block  0
unconditional  0 taken 61
        -: 1348:					} else {
    #####: 1349:						fprintf(stderr, _("%s: %s: Error quoting "
call    0 never executed
        -: 1350:								"file name\n"),
    #####: 1351:								PROGRAM_NAME, file_info[num - 1].name);
    %%%%%: 1351-block  0
call    0 never executed
        -: 1352:						/* Free whatever was allocated thus far */
        -: 1353:
    #####: 1354:						for (j = 0; j <= (int)args_n; j++)
unconditional  0 never executed
    %%%%%: 1354-block  0
branch  1 never executed
branch  2 never executed
    #####: 1355:							free(substr[j]);
    %%%%%: 1355-block  0
unconditional  0 never executed
    #####: 1356:						free(substr);
    #####: 1357:						return (char **)NULL;
    %%%%%: 1357-block  0
unconditional  0 never executed
        -: 1358:					}
        -: 1359:				}
        -: 1360:			}
        -: 1361:		}
        -: 1362:
        -: 1363:		/* #############################################
        -: 1364:		 * #   2.g) USER DEFINED VARIABLES EXPANSION   #
        -: 1365:		 * #############################################*/
        -: 1366:
     721*: 1367:		if (substr[i][0] == '$' && substr[i][1] != '(' && substr[i][1] != '{') {
      721: 1367-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 721
    %%%%%: 1367-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1367-block  2
branch  4 never executed
branch  5 never executed
    #####: 1368:			char *var_name = strchr(substr[i], '$');
    #####: 1369:			if (var_name && *(++var_name)) {
    %%%%%: 1369-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1369-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1369-block  2
unconditional  4 never executed
    #####: 1370:				int j = (int)usrvar_n;
    #####: 1371:				while (--j >= 0) {
    %%%%%: 1371-block  0
unconditional  0 never executed
    %%%%%: 1371-block  1
branch  1 never executed
branch  2 never executed
    #####: 1372:					if (*var_name == *usr_var[j].name
    %%%%%: 1372-block  0
branch  0 never executed
branch  1 never executed
    #####: 1373:					&& strcmp(var_name, usr_var[j].name) == 0) {
    %%%%%: 1373-block  0
branch  0 never executed
branch  1 never executed
    #####: 1374:						substr[i] = (char *)xrealloc(substr[i],
    #####: 1375:						    (strlen(usr_var[j].value) + 1) * sizeof(char));
    %%%%%: 1375-block  0
call    0 never executed
    #####: 1376:						strcpy(substr[i], usr_var[j].value);
    #####: 1377:						break;
unconditional  0 never executed
        -: 1378:					}
        -: 1379:				}
        -: 1380:			} else {
    #####: 1381:				fprintf(stderr, _("%s: %s: Error getting variable name\n"),
call    0 never executed
    #####: 1382:						PROGRAM_NAME, substr[i]);
    %%%%%: 1382-block  0
call    0 never executed
        -: 1383:				size_t j;
    #####: 1384:				for (j = 0; j <= args_n; j++)
unconditional  0 never executed
    %%%%%: 1384-block  0
branch  1 never executed
branch  2 never executed
    #####: 1385:					free(substr[j]);
    %%%%%: 1385-block  0
unconditional  0 never executed
    #####: 1386:				free(substr);
    #####: 1387:				return (char **)NULL;
    %%%%%: 1387-block  0
unconditional  0 never executed
        -: 1388:			}
        -: 1389:		}
        -: 1390:
        -: 1391:		/* We are in STDIN_TMP_DIR: Expand symlinks to target */
      721: 1392:		if (stdin_dir_ok) {
      721: 1392-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 721
    #####: 1393:			char *real_path = realpath(substr[i], NULL);
    %%%%%: 1393-block  0
call    0 never executed
    #####: 1394:			if (real_path) {
branch  0 never executed
branch  1 never executed
    #####: 1395:				substr[i] = (char *)xrealloc(substr[i],
    #####: 1396:				    (strlen(real_path) + 1) * sizeof(char));
    %%%%%: 1396-block  0
call    0 never executed
    #####: 1397:				strcpy(substr[i], real_path);
    #####: 1398:				free(real_path);
unconditional  0 never executed
        -: 1399:			}
        -: 1400:		}
        -: 1401:	}
        -: 1402:
        -: 1403:	/* #### 3) NULL TERMINATE THE INPUT STRING ARRAY #### */
      500: 1404:	substr = (char **)xrealloc(substr, sizeof(char *) * (args_n + 2));
      500: 1404-block  0
call    0 returned 500
      500: 1405:	substr[args_n + 1] = (char *)NULL;
        -: 1406:
      500: 1407:	if (!is_internal(substr[0]))
call    0 returned 500
branch  1 taken 426 (fallthrough)
branch  2 taken 74
      426: 1408:		return substr;
      426: 1408-block  0
unconditional  0 taken 426
        -: 1409:
        -: 1410:	/* #############################################################
        -: 1411:	 * #               ONLY FOR INTERNAL COMMANDS                  #
        -: 1412:	 * #############################################################*/
        -: 1413:
        -: 1414:	/* Some functions of CliFM are purely internal, that is, they are not
        -: 1415:	 * wrappers of a shell command and do not call the system shell at all.
        -: 1416:	 * For this reason, some expansions normally made by the system shell
        -: 1417:	 * must be made here (in the lobby [got it?]) in order to be able to
        -: 1418:	 * understand these expansions at all. */
        -: 1419:
        -: 1420:		/* ###############################################
        -: 1421:		 * #   3) WILDCARD, BRACE, AND TILDE EXPANSION   #
        -: 1422:		 * ############################################### */
        -: 1423:
       74: 1424:	int *glob_array = (int *)xnmalloc(int_array_max, sizeof(int));
       74: 1424-block  0
call    0 returned 74
       74: 1425:	size_t glob_n = 0;
        -: 1426:#if !defined(__HAIKU__) && !defined(__OpenBSD__)
       74: 1427:	int *word_array = (int *)xnmalloc(int_array_max, sizeof(int));
call    0 returned 74
       74: 1428:	size_t word_n = 0;
        -: 1429:#endif
        -: 1430:
      235: 1431:	for (i = 0; substr[i]; i++) {
unconditional  0 taken 74
      161: 1431-block  0
unconditional  1 taken 161
      235: 1431-block  1
branch  2 taken 161
branch  3 taken 74 (fallthrough)
        -: 1432:
        -: 1433:		/* Do not perform any of the expansions below for selected
        -: 1434:		 * elements: they are full path file names that, as such, do not
        -: 1435:		 * need any expansion */
      161: 1436:		if (is_sel) { /* is_sel is true only for the current input and if
      161: 1436-block  0
branch  0 taken 19 (fallthrough)
branch  1 taken 142
        -: 1437:			there was some "sel" keyword in it */
        -: 1438:			/* Strings between is_sel and sel_n are selected file names */
       19: 1439:			if (i >= (size_t)is_sel && i <= sel_n)
       19: 1439-block  0
branch  0 taken 13 (fallthrough)
branch  1 taken 6
       13: 1439-block  1
branch  2 taken 13 (fallthrough)
branch  3 taken 0
       13: 1440:				continue;
       13: 1440-block  0
unconditional  0 taken 13
        -: 1441:		}
        -: 1442:
        -: 1443:		/* Ignore the first string of the search function: it will be
        -: 1444:		 * expanded by the search function itself */
      148: 1445:		if (substr[0][0] == '/' && i == 0)
      148: 1445-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 140
        8: 1445-block  1
branch  2 taken 5 (fallthrough)
branch  3 taken 3
        5: 1446:			continue;
        5: 1446-block  0
unconditional  0 taken 5
        -: 1447:
        -: 1448:		/* Tilde expansion is made by glob() */
      143: 1449:		if (*substr[i] == '~') {
      143: 1449-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 143
    #####: 1450:			if (glob_n < int_array_max)
    %%%%%: 1450-block  0
branch  0 never executed
branch  1 never executed
    #####: 1451:				glob_array[glob_n++] = (int)i;
    %%%%%: 1451-block  0
unconditional  0 never executed
        -: 1452:		}
        -: 1453:
      143: 1454:		register size_t j = 0;
      784: 1455:		for (j = 0; substr[i][j]; j++) {
      143: 1455-block  0
unconditional  0 taken 143
      641: 1455-block  1
unconditional  1 taken 641
      784: 1455-block  2
branch  2 taken 641
branch  3 taken 143 (fallthrough)
        -: 1456:			/* Brace and wildcard expansion is made by glob()
        -: 1457:			 * as well */
      641: 1458:			if ((substr[i][j] == '*' || substr[i][j] == '?'
      641: 1458-block  0
branch  0 taken 630 (fallthrough)
branch  1 taken 11
      630: 1458-block  1
branch  2 taken 630 (fallthrough)
branch  3 taken 0
      630: 1459:			|| substr[i][j] == '[' || substr[i][j] == '{')
      630: 1459-block  0
branch  0 taken 630 (fallthrough)
branch  1 taken 0
      630: 1459-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 630
       11: 1460:			&& substr[i][j + 1] != ' ') {
       11: 1460-block  0
branch  0 taken 11 (fallthrough)
branch  1 taken 0
        -: 1461:				/* Strings containing these characters are taken as
        -: 1462:			 * wildacard patterns and are expanded by the glob
        -: 1463:			 * function. See man (7) glob */
       11: 1464:				if (glob_n < int_array_max)
       11: 1464-block  0
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11: 1465:					glob_array[glob_n++] = (int)i;
       11: 1465-block  0
unconditional  0 taken 11
        -: 1466:			}
        -: 1467:
        -: 1468:#if !defined(__HAIKU__) && !defined(__OpenBSD__)
        -: 1469:			/* Command substitution is made by wordexp() */
     641*: 1470:			if (substr[i][j] == '$' && (substr[i][j + 1] == '('
      641: 1470-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 641
    %%%%%: 1470-block  1
branch  2 never executed
branch  3 never executed
    #####: 1471:			|| substr[i][j + 1] == '{')) {
    %%%%%: 1471-block  0
branch  0 never executed
branch  1 never executed
    #####: 1472:				if (word_n < int_array_max)
    %%%%%: 1472-block  0
branch  0 never executed
branch  1 never executed
    #####: 1473:					word_array[word_n++] = (int)i;
    %%%%%: 1473-block  0
unconditional  0 never executed
        -: 1474:			}
        -: 1475:
     641*: 1476:			if (substr[i][j] == '`' && substr[i][j + 1] != ' ') {
      641: 1476-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 641
    %%%%%: 1476-block  1
branch  2 never executed
branch  3 never executed
    #####: 1477:				if (word_n < int_array_max)
    %%%%%: 1477-block  0
branch  0 never executed
branch  1 never executed
    #####: 1478:					word_array[word_n++] = (int)i;
    %%%%%: 1478-block  0
unconditional  0 never executed
        -: 1479:			}
        -: 1480:#endif /* __HAIKU__ */
        -: 1481:		}
        -: 1482:	}
        -: 1483:
        -: 1484:	/* Do not expand if command is deselect, sel or untrash, just to
        -: 1485:	 * allow the use of "*" for desel and untrash ("ds *" and "u *")
        -: 1486:	 * and to let the sel function handle patterns itself */
       74: 1487:	if (glob_n && strcmp(substr[0], "s") != 0 && strcmp(substr[0], "sel") != 0
       74: 1487-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 66
        8: 1487-block  1
branch  2 taken 5 (fallthrough)
branch  3 taken 3
        5: 1487-block  2
branch  4 taken 2 (fallthrough)
branch  5 taken 3
        2: 1488:	&& strcmp(substr[0], "ds") != 0 && strcmp(substr[0], "desel") != 0
        2: 1488-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1488-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 1489:	&& strcmp(substr[0], "u") != 0 && strcmp(substr[0], "undel") != 0
        2: 1489-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1489-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 1490:	&& strcmp(substr[0], "untrash") != 0) {
        2: 1490-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -: 1491:		/* 1) Expand glob
        -: 1492:		2) Create a new array, say comm_array_glob, large enough to store
        -: 1493:		   the expanded glob and the remaining (non-glob) arguments
        -: 1494:		   (args_n+gl_pathc)
        -: 1495:		3) Copy into this array everything before the glob
        -: 1496:		   (i=0;i<glob_char;i++)
        -: 1497:		4) Copy the expanded elements (if none, copy the original element,
        -: 1498:		   comm_array[glob_char])
        -: 1499:		5) Copy the remaining elements (i=glob_char+1;i<=args_n;i++)
        -: 1500:		6) Free the old comm_array and fill it with comm_array_glob
        -: 1501:	  */
        2: 1502:		size_t old_pathc = 0;
        -: 1503:		/* glob_array stores the index of the globbed strings. However,
        -: 1504:		 * once the first expansion is done, the index of the next globbed
        -: 1505:		 * string has changed. To recover the next globbed string, and
        -: 1506:		 * more precisely, its index, we only need to add the amount of
        -: 1507:		 * files matched by the previous instances of glob(). Example:
        -: 1508:		 * if original indexes were 2 and 4, once 2 is expanded 4 stores
        -: 1509:		 * now some of the files expanded in 2. But if we add to 4 the
        -: 1510:		 * amount of files expanded in 2 (gl_pathc), we get now the
        -: 1511:		 * original globbed string pointed by 4.
        -: 1512:		*/
        2: 1513:		register size_t g = 0;
        4: 1514:		for (g = 0; g < (size_t)glob_n; g++) {
        2: 1514-block  0
unconditional  0 taken 2
        2: 1514-block  1
unconditional  1 taken 2
        4: 1514-block  2
branch  2 taken 2
branch  3 taken 2 (fallthrough)
        -: 1515:			glob_t globbuf;
        -: 1516:
       2*: 1517:			if (glob(substr[glob_array[g] + (int)old_pathc],
        2: 1517-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -: 1518:				GLOB_BRACE | GLOB_TILDE, NULL, &globbuf) != EXIT_SUCCESS) {
    #####: 1519:				globfree(&globbuf);
    %%%%%: 1519-block  0
call    0 never executed
    #####: 1520:				continue;
unconditional  0 never executed
        -: 1521:			}
        -: 1522:
        2: 1523:			if (globbuf.gl_pathc) {
        2: 1523-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1524:				register size_t j = 0;
        2: 1525:				char **glob_cmd = (char **)NULL;
        2: 1526:				glob_cmd = (char **)xcalloc(args_n + globbuf.gl_pathc + 1,
        2: 1526-block  0
call    0 returned 2
        -: 1527:											sizeof(char *));
        -: 1528:
        4: 1529:				for (i = 0; i < ((size_t)glob_array[g] + old_pathc); i++)
unconditional  0 taken 2
        4: 1529-block  0
branch  1 taken 2
branch  2 taken 2 (fallthrough)
        2: 1530:					glob_cmd[j++] = savestring(substr[i], strlen(substr[i]));
        2: 1530-block  0
call    0 returned 2
unconditional  1 taken 2
        -: 1531:
        8: 1532:				for (i = 0; i < globbuf.gl_pathc; i++) {
        2: 1532-block  0
unconditional  0 taken 2
        6: 1532-block  1
unconditional  1 taken 6
        8: 1532-block  2
branch  2 taken 6
branch  3 taken 2 (fallthrough)
        -: 1533:					/* Do not match "." or ".." */
       6*: 1534:					if (strcmp(globbuf.gl_pathv[i], ".") == 0
        6: 1534-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6: 1535:					|| strcmp(globbuf.gl_pathv[i], "..") == 0)
        6: 1535-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 1536:						continue;
    %%%%%: 1536-block  0
unconditional  0 never executed
        -: 1537:
        -: 1538:					/* Escape the globbed file name and copy it */
        6: 1539:					char *esc_str = escape_str(globbuf.gl_pathv[i]);
        6: 1539-block  0
call    0 returned 6
        6: 1540:					if (esc_str) {
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6: 1541:						glob_cmd[j++] = savestring(esc_str, strlen(esc_str));
        6: 1541-block  0
call    0 returned 6
        6: 1542:						free(esc_str);
unconditional  0 taken 6
        -: 1543:					} else {
    #####: 1544:						fprintf(stderr, _("%s: %s: Error quoting "
call    0 never executed
    #####: 1545:							"file name\n"), PROGRAM_NAME, globbuf.gl_pathv[i]);
    %%%%%: 1545-block  0
call    0 never executed
    #####: 1546:						register size_t k = 0;
    #####: 1547:						for (k = 0; k < j; k++)
unconditional  0 never executed
    %%%%%: 1547-block  0
branch  1 never executed
branch  2 never executed
    #####: 1548:							free(glob_cmd[k]);
    %%%%%: 1548-block  0
unconditional  0 never executed
    #####: 1549:						free(glob_cmd);
    #####: 1550:						glob_cmd = (char **)NULL;
        -: 1551:
    #####: 1552:						for (k = 0; k <= args_n; k++)
    %%%%%: 1552-block  0
unconditional  0 never executed
    %%%%%: 1552-block  1
branch  1 never executed
branch  2 never executed
    #####: 1553:							free(substr[k]);
    %%%%%: 1553-block  0
unconditional  0 never executed
    #####: 1554:						free(substr);
    #####: 1555:						globfree(&globbuf);
    %%%%%: 1555-block  0
call    0 never executed
    #####: 1556:						return (char **)NULL;
unconditional  0 never executed
        -: 1557:					}
        -: 1558:				}
        -: 1559:
        2: 1560:				for (i = (size_t)glob_array[g] + old_pathc + 1;
        2: 1560-block  0
unconditional  0 taken 2
       2*: 1561:				i <= args_n; i++)
        2: 1561-block  0
branch  0 taken 0
branch  1 taken 2 (fallthrough)
    #####: 1562:					glob_cmd[j++] = savestring(substr[i], strlen(substr[i]));
    %%%%%: 1562-block  0
call    0 never executed
unconditional  1 never executed
        -: 1563:
        2: 1564:				glob_cmd[j] = (char *)NULL;
        -: 1565:
        6: 1566:				for (i = 0; i <= args_n; i++)
        2: 1566-block  0
unconditional  0 taken 2
        6: 1566-block  1
branch  1 taken 4
branch  2 taken 2 (fallthrough)
        4: 1567:					free(substr[i]);
        4: 1567-block  0
unconditional  0 taken 4
        2: 1568:				free(substr);
        -: 1569:
        2: 1570:				substr = glob_cmd;
        2: 1571:				glob_cmd = (char **)NULL;
        2: 1572:				args_n = j - 1;
        2: 1572-block  0
unconditional  0 taken 2
        -: 1573:			}
        -: 1574:
        2: 1575:			old_pathc += (globbuf.gl_pathc - 1);
        2: 1576:			globfree(&globbuf);
        2: 1576-block  0
call    0 returned 2
        -: 1577:		}
        -: 1578:	}
        -: 1579:
       74: 1580:	free(glob_array);
        -: 1581:
        -: 1582:		/* #############################################
        -: 1583:		 * #    4) COMMAND & PARAMETER SUBSTITUTION    #
        -: 1584:		 * ############################################# */
        -: 1585:#if !defined(__HAIKU__) && !defined(__OpenBSD__)
       74: 1586:	if (word_n) {
       74: 1586-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 74
    #####: 1587:		size_t old_pathc = 0;
    #####: 1588:		register size_t w = 0;
    #####: 1589:		for (w = 0; w < (size_t)word_n; w++) {
    %%%%%: 1589-block  0
unconditional  0 never executed
    %%%%%: 1589-block  1
unconditional  1 never executed
    %%%%%: 1589-block  2
branch  2 never executed
branch  3 never executed
        -: 1590:			wordexp_t wordbuf;
    #####: 1591:			if (wordexp(substr[word_array[w] + (int)old_pathc],
    %%%%%: 1591-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1592:				&wordbuf, 0) != EXIT_SUCCESS) {
    #####: 1593:				wordfree(&wordbuf);
    %%%%%: 1593-block  0
call    0 never executed
    #####: 1594:				continue;
unconditional  0 never executed
        -: 1595:			}
        -: 1596:
    #####: 1597:			if (wordbuf.we_wordc) {
    %%%%%: 1597-block  0
branch  0 never executed
branch  1 never executed
    #####: 1598:				register size_t j = 0;
    #####: 1599:				char **word_cmd = (char **)NULL;
        -: 1600:
    #####: 1601:				word_cmd = (char **)xcalloc(args_n + wordbuf.we_wordc + 1,
    %%%%%: 1601-block  0
call    0 never executed
        -: 1602:											sizeof(char *));
        -: 1603:
    #####: 1604:				for (i = 0; i < ((size_t)word_array[w] + old_pathc); i++)
unconditional  0 never executed
    %%%%%: 1604-block  0
branch  1 never executed
branch  2 never executed
    #####: 1605:					word_cmd[j++] = savestring(substr[i], strlen(substr[i]));
    %%%%%: 1605-block  0
call    0 never executed
unconditional  1 never executed
        -: 1606:
    #####: 1607:				for (i = 0; i < wordbuf.we_wordc; i++) {
    %%%%%: 1607-block  0
unconditional  0 never executed
    %%%%%: 1607-block  1
unconditional  1 never executed
    %%%%%: 1607-block  2
branch  2 never executed
branch  3 never executed
        -: 1608:					/* Escape the globbed file name and copy it*/
    #####: 1609:					char *esc_str = escape_str(wordbuf.we_wordv[i]);
    %%%%%: 1609-block  0
call    0 never executed
    #####: 1610:					if (esc_str) {
branch  0 never executed
branch  1 never executed
    #####: 1611:						word_cmd[j++] = savestring(esc_str, strlen(esc_str));
    %%%%%: 1611-block  0
call    0 never executed
    #####: 1612:						free(esc_str);
unconditional  0 never executed
        -: 1613:					} else {
    #####: 1614:						fprintf(stderr, _("%s: %s: Error quoting "
call    0 never executed
    #####: 1615:							"file name\n"), PROGRAM_NAME, wordbuf.we_wordv[i]);
    %%%%%: 1615-block  0
call    0 never executed
        -: 1616:
    #####: 1617:						register size_t k = 0;
    #####: 1618:						for (k = 0; k < j; k++)
unconditional  0 never executed
    %%%%%: 1618-block  0
branch  1 never executed
branch  2 never executed
    #####: 1619:							free(word_cmd[k]);
    %%%%%: 1619-block  0
unconditional  0 never executed
    #####: 1620:						free(word_cmd);
        -: 1621:
    #####: 1622:						word_cmd = (char **)NULL;
        -: 1623:
    #####: 1624:						for (k = 0; k <= args_n; k++)
    %%%%%: 1624-block  0
unconditional  0 never executed
    %%%%%: 1624-block  1
branch  1 never executed
branch  2 never executed
    #####: 1625:							free(substr[k]);
    %%%%%: 1625-block  0
unconditional  0 never executed
    #####: 1626:						free(substr);
    #####: 1627:						return (char **)NULL;
    %%%%%: 1627-block  0
unconditional  0 never executed
        -: 1628:					}
        -: 1629:				}
        -: 1630:
    #####: 1631:				for (i = (size_t)word_array[w] + old_pathc + 1;
    %%%%%: 1631-block  0
unconditional  0 never executed
    #####: 1632:				i <= args_n; i++)
    %%%%%: 1632-block  0
branch  0 never executed
branch  1 never executed
    #####: 1633:					word_cmd[j++] = savestring(substr[i], strlen(substr[i]));
    %%%%%: 1633-block  0
call    0 never executed
unconditional  1 never executed
        -: 1634:
    #####: 1635:				word_cmd[j] = (char *)NULL;
        -: 1636:
    #####: 1637:				for (i = 0; i <= args_n; i++)
    %%%%%: 1637-block  0
unconditional  0 never executed
    %%%%%: 1637-block  1
branch  1 never executed
branch  2 never executed
    #####: 1638:					free(substr[i]);
    %%%%%: 1638-block  0
unconditional  0 never executed
    #####: 1639:				free(substr);
    #####: 1640:				substr = word_cmd;
    #####: 1641:				word_cmd = (char **)NULL;
    #####: 1642:				args_n = j - 1;
    %%%%%: 1642-block  0
unconditional  0 never executed
        -: 1643:			}
        -: 1644:
    #####: 1645:			old_pathc += (wordbuf.we_wordc - 1);
    #####: 1646:			wordfree(&wordbuf);
    %%%%%: 1646-block  0
call    0 never executed
        -: 1647:		}
        -: 1648:	}
        -: 1649:
       74: 1650:	free(word_array);
        -: 1651:#endif /* __HAIKU__ */
        -: 1652:
       74: 1653:	if (substr[0] && (*substr[0] == 'd' || *substr[0] == 'u')
       74: 1653-block  0
branch  0 taken 74 (fallthrough)
branch  1 taken 0
       74: 1653-block  1
branch  2 taken 74 (fallthrough)
branch  3 taken 0
       74: 1653-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 74
    #####: 1654:	&& (strcmp(substr[0], "desel") == 0 || strcmp(substr[0], "undel") == 0
    %%%%%: 1654-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1654-block  1
branch  2 never executed
branch  3 never executed
    #####: 1655:	|| strcmp(substr[0], "untrash") == 0)) {
    %%%%%: 1655-block  0
branch  0 never executed
branch  1 never executed
        -: 1656:		/* Null terminate the input string array (again) */
    #####: 1657:		substr = (char **)xrealloc(substr, (args_n + 2) * sizeof(char *));
    %%%%%: 1657-block  0
call    0 never executed
    #####: 1658:		substr[args_n + 1] = (char *)NULL;
    #####: 1659:		return substr;
unconditional  0 never executed
        -: 1660:	}
        -: 1661:
        -: 1662:		/* #############################################
        -: 1663:		 * #             5) REGEX EXPANSION            #
        -: 1664:		 * ############################################# */
        -: 1665:
       74: 1666:	if (*substr[0] == 's' && (!substr[0][1] || strcmp(substr[0], "sel") == 0))
       74: 1666-block  0
branch  0 taken 13 (fallthrough)
branch  1 taken 61
       13: 1666-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 10
        3: 1666-block  2
branch  4 taken 3 (fallthrough)
branch  5 taken 0
       13: 1667:		return substr;
       13: 1667-block  0
unconditional  0 taken 13
        -: 1668:
       61: 1669:	char **regex_files = (char **)xnmalloc(files + args_n + 2, sizeof(char *));
       61: 1669-block  0
call    0 returned 61
       61: 1670:	size_t j, r_files = 0;
        -: 1671:
      188: 1672:	for (i = 0; substr[i]; i++) {
unconditional  0 taken 61
      127: 1672-block  0
unconditional  1 taken 127
      188: 1672-block  1
branch  2 taken 127
branch  3 taken 61 (fallthrough)
      127: 1673:		if (r_files > (files + args_n))
      127: 1673-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 127
    #####: 1674:			break;
    %%%%%: 1674-block  0
unconditional  0 never executed
        -: 1675:
        -: 1676:		/* Ignore the first string of the search function: it will be
        -: 1677:		 * expanded by the search function itself */
      127: 1678:		if (*substr[0] == '/') {
      127: 1678-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 119
        8: 1679:			regex_files[r_files++] = substr[i];
      127: 1680:			continue;
        8: 1680-block  0
unconditional  0 taken 8
      127: 1680-block  1
unconditional  1 taken 127
        -: 1681:		}
        -: 1682:
      119: 1683:		if (check_regex(substr[i]) != EXIT_SUCCESS) {
      119: 1683-block  0
call    0 returned 119
branch  1 taken 119 (fallthrough)
branch  2 taken 0
      119: 1684:			regex_files[r_files++] = substr[i];
      119: 1685:			continue;
      119: 1685-block  0
unconditional  0 taken 119
        -: 1686:		}
        -: 1687:
        -: 1688:		regex_t regex;
    #####: 1689:		if (regcomp(&regex, substr[i], REG_NOSUB | REG_EXTENDED) != EXIT_SUCCESS) {
    %%%%%: 1689-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1690:			/*          fprintf(stderr, "%s: %s: Invalid regular expression",
        -: 1691:					PROGRAM_NAME, substr[i]); */
    #####: 1692:			regfree(&regex);
    %%%%%: 1692-block  0
call    0 never executed
    #####: 1693:			regex_files[r_files++] = substr[i];
    #####: 1694:			continue;
unconditional  0 never executed
        -: 1695:		}
        -: 1696:
    #####: 1697:		int reg_found = 0;
        -: 1698:
    #####: 1699:		for (j = 0; j < files; j++) {
    %%%%%: 1699-block  0
unconditional  0 never executed
    %%%%%: 1699-block  1
unconditional  1 never executed
    %%%%%: 1699-block  2
branch  2 never executed
branch  3 never executed
    #####: 1700:			if (regexec(&regex, file_info[j].name, 0, NULL, 0) == EXIT_SUCCESS) {
    %%%%%: 1700-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1701:				regex_files[r_files++] = file_info[j].name;
    #####: 1702:				reg_found = 1;
    %%%%%: 1702-block  0
unconditional  0 never executed
        -: 1703:			}
        -: 1704:		}
        -: 1705:
    #####: 1706:		if (!reg_found)
    %%%%%: 1706-block  0
branch  0 never executed
branch  1 never executed
    #####: 1707:			regex_files[r_files++] = substr[i];
    %%%%%: 1707-block  0
unconditional  0 never executed
        -: 1708:
    #####: 1709:		regfree(&regex);
    %%%%%: 1709-block  0
call    0 never executed
        -: 1710:	}
        -: 1711:
       61: 1712:	if (r_files) {
       61: 1712-block  0
branch  0 taken 61 (fallthrough)
branch  1 taken 0
       61: 1713:		regex_files[r_files] = (char *)NULL;
       61: 1714:		char **tmp_files = (char **)xnmalloc(r_files + 2, sizeof(char *));
       61: 1714-block  0
call    0 returned 61
       61: 1715:		size_t k = 0;
      188: 1716:		for (j = 0; regex_files[j]; j++)
unconditional  0 taken 61
      188: 1716-block  0
branch  1 taken 127
branch  2 taken 61 (fallthrough)
      127: 1717:			tmp_files[k++] = savestring(regex_files[j], strlen(regex_files[j]));
      127: 1717-block  0
call    0 returned 127
unconditional  1 taken 127
       61: 1718:		tmp_files[k] = (char *)NULL;
        -: 1719:
      188: 1720:		for (j = 0; j <= args_n; j++)
       61: 1720-block  0
unconditional  0 taken 61
      188: 1720-block  1
branch  1 taken 127
branch  2 taken 61 (fallthrough)
      127: 1721:			free(substr[j]);
      127: 1721-block  0
unconditional  0 taken 127
       61: 1722:		free(substr);
        -: 1723:
       61: 1724:		substr = tmp_files;
       61: 1725:		tmp_files = (char **)NULL;
       61: 1726:		args_n = k - 1;
       61: 1727:		free(tmp_files);
       61: 1727-block  0
unconditional  0 taken 61
        -: 1728:	}
        -: 1729:
       61: 1730:	free(regex_files);
       61: 1731:	substr = (char **)xrealloc(substr, (args_n + 2) * sizeof(char *));
       61: 1731-block  0
call    0 returned 61
       61: 1732:	substr[args_n + 1] = (char *)NULL;
       61: 1733:	return substr;
unconditional  0 taken 61
        -: 1734:}
        -: 1735:
        -: 1736:/* Reduce "$HOME" to tilde ("~"). The new_path variable is always either
        -: 1737: * "$HOME" or "$HOME/file", that's why there's no need to check for
        -: 1738: * "/file" */
        -: 1739:char *
function home_tilde called 1101 returned 100% blocks executed 94%
     1101: 1740:home_tilde(const char *new_path)
        -: 1741:{
     1101: 1742:	if (!home_ok || !new_path || !*new_path || !user.home)
     1101: 1742-block  0
branch  0 taken 1101 (fallthrough)
branch  1 taken 0
     1101: 1742-block  1
branch  2 taken 1101 (fallthrough)
branch  3 taken 0
     1101: 1742-block  2
branch  4 taken 1101 (fallthrough)
branch  5 taken 0
     1101: 1742-block  3
branch  6 taken 0 (fallthrough)
branch  7 taken 1101
    #####: 1743:		return (char *)NULL;
    %%%%%: 1743-block  0
unconditional  0 never executed
        -: 1744:
     1101: 1745:	char *path_tilde = (char *)NULL;
        -: 1746:
        -: 1747:	/* If path == HOME */
     1101: 1748:	if (new_path[1] == user.home[1] && strcmp(new_path, user.home) == 0) {
     1101: 1748-block  0
branch  0 taken 1073 (fallthrough)
branch  1 taken 28
     1073: 1748-block  1
branch  2 taken 127 (fallthrough)
branch  3 taken 946
      127: 1749:		path_tilde = (char *)xnmalloc(2, sizeof(char));
      127: 1749-block  0
call    0 returned 127
      127: 1750:		path_tilde[0] = '~';
      127: 1751:		path_tilde[1] = '\0';
unconditional  0 taken 127
      974: 1752:	} else if (new_path[1] == user.home[1]
      974: 1752-block  0
branch  0 taken 946 (fallthrough)
branch  1 taken 28
      946: 1753:	&& strncmp(new_path, user.home, user.home_len) == 0) {
      946: 1753-block  0
branch  0 taken 946 (fallthrough)
branch  1 taken 0
        -: 1754:		/* If path == HOME/file */
      946: 1755:		path_tilde = (char *)xnmalloc(strlen(new_path + user.home_len + 1) + 3,
      946: 1755-block  0
call    0 returned 946
        -: 1756:										sizeof(char));
      946: 1757:		sprintf(path_tilde, "~/%s", new_path + user.home_len + 1);
unconditional  0 taken 946
        -: 1758:	} else {
       28: 1759:		path_tilde = (char *)xnmalloc(strlen(new_path) + 1, sizeof(char));
       28: 1759-block  0
call    0 returned 28
       28: 1760:		strcpy(path_tilde, new_path);
unconditional  0 taken 28
        -: 1761:	}
        -: 1762:
     1101: 1763:	return path_tilde;
     1101: 1763-block  0
unconditional  0 taken 1101
        -: 1764:}
        -: 1765:
        -: 1766:/* Expand a range of numbers given by str. It will expand the range
        -: 1767: * provided that both extremes are numbers, bigger than zero, equal or
        -: 1768: * smaller than the amount of files currently listed on the screen, and
        -: 1769: * the second (right) extreme is bigger than the first (left). Returns
        -: 1770: * an array of int's with the expanded range or NULL if one of the
        -: 1771: * above conditions is not met */
        -: 1772:int *
function expand_range called 4 returned 100% blocks executed 73%
        4: 1773:expand_range(char *str, int listdir)
        -: 1774:{
        4: 1775:	if (strcntchr(str, '-') == -1)
        4: 1775-block  0
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
    #####: 1776:		return (int *)NULL;
    %%%%%: 1776-block  0
unconditional  0 never executed
        -: 1777:
        4: 1778:	char *first = (char *)NULL;
        4: 1779:	first = strbfr(str, '-');
        4: 1779-block  0
call    0 returned 4
        -: 1780:
        4: 1781:	if (!first)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1782:		return (int *)NULL;
    %%%%%: 1782-block  0
unconditional  0 never executed
        -: 1783:
        4: 1784:	if (!is_number(first)) {
        4: 1784-block  0
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
    #####: 1785:		free(first);
    #####: 1786:		return (int *)NULL;
    %%%%%: 1786-block  0
unconditional  0 never executed
        -: 1787:	}
        -: 1788:
        4: 1789:	char *second = (char *)NULL;
        4: 1790:	second = straft(str, '-');
        4: 1790-block  0
call    0 returned 4
        -: 1791:
        4: 1792:	if (!second) {
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####: 1793:		free(first);
    #####: 1794:		return (int *)NULL;
    %%%%%: 1794-block  0
unconditional  0 never executed
        -: 1795:	}
        -: 1796:
        4: 1797:	if (!is_number(second)) {
        4: 1797-block  0
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
    #####: 1798:		free(first);
    #####: 1799:		free(second);
    #####: 1800:		return (int *)NULL;
    %%%%%: 1800-block  0
unconditional  0 never executed
        -: 1801:	}
        -: 1802:
        4: 1803:	int afirst = atoi(first), asecond = atoi(second);
        4: 1804:	free(first);
        4: 1805:	free(second);
        -: 1806:
        4: 1807:	if (listdir) {
        4: 1807-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1808:		if (afirst <= 0 || afirst > (int)files || asecond <= 0
        4: 1808-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1808-block  1
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        4: 1808-block  2
branch  4 taken 4 (fallthrough)
branch  5 taken 0
        4: 1809:		|| asecond > (int)files || afirst >= asecond)
        4: 1809-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1809-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 4
    #####: 1810:			return (int *)NULL;
    %%%%%: 1810-block  0
unconditional  0 never executed
        -: 1811:	} else {
    #####: 1812:		if (afirst >= asecond)
    %%%%%: 1812-block  0
branch  0 never executed
branch  1 never executed
    #####: 1813:			return (int *)NULL;
    %%%%%: 1813-block  0
unconditional  0 never executed
        -: 1814:	}
        -: 1815:
        4: 1816:	int *buf = (int *)NULL;
        4: 1817:	buf = (int *)xcalloc((size_t)(asecond - afirst) + 2, sizeof(int));
        4: 1817-block  0
call    0 returned 4
        -: 1818:
        4: 1819:	size_t i, j = 0;
       18: 1820:	for (i = (size_t)afirst; i <= (size_t)asecond; i++)
unconditional  0 taken 4
       18: 1820-block  0
branch  1 taken 14
branch  2 taken 4 (fallthrough)
       14: 1821:		buf[j++] = (int)i;
       14: 1821-block  0
unconditional  0 taken 14
        -: 1822:
        4: 1823:	return buf;
        4: 1823-block  0
unconditional  0 taken 4
        -: 1824:}
        -: 1825:
        -: 1826:/* used a lot.
        -: 1827: * creates a copy of a string */
        -: 1828:char *
function savestring called 95251 returned 100% blocks executed 67%
    95251: 1829:savestring(const char *restrict str, size_t size)
        -: 1830:{
    95251: 1831:	if (!str)
    95251: 1831-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 95251
    #####: 1832:		return (char *)NULL;
    %%%%%: 1832-block  0
unconditional  0 never executed
        -: 1833:
    95251: 1834:	char *ptr = (char *)NULL;
    95251: 1835:	ptr = (char *)malloc((size + 1) * sizeof(char));
        -: 1836:
    95251: 1837:	if (!ptr)
    95251: 1837-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 95251
    #####: 1838:		return (char *)NULL;
    %%%%%: 1838-block  0
unconditional  0 never executed
    95251: 1839:	strcpy(ptr, str);
        -: 1840:
    95251: 1841:	return ptr;
    95251: 1841-block  0
unconditional  0 taken 95251
        -: 1842:}
        -: 1843:
        -: 1844:/* Take a string and returns the same string escaped. If nothing to be
        -: 1845: * escaped, the original string is returned */
        -: 1846:char *
function escape_str called 139 returned 100% blocks executed 91%
      139: 1847:escape_str(const char *str)
        -: 1848:{
      139: 1849:	if (!str)
      139: 1849-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 139
    #####: 1850:		return (char *)NULL;
    %%%%%: 1850-block  0
unconditional  0 never executed
        -: 1851:
      139: 1852:	size_t len = 0;
      139: 1853:	char *buf = (char *)NULL;
        -: 1854:
      139: 1855:	buf = (char *)xnmalloc(strlen(str) * 2 + 1, sizeof(char));
      139: 1855-block  0
call    0 returned 139
        -: 1856:
     2620: 1857:	while (*str) {
unconditional  0 taken 139
     2620: 1857-block  0
branch  1 taken 2481
branch  2 taken 139 (fallthrough)
     2481: 1858:		if (is_quote_char(*str))
     2481: 1858-block  0
call    0 returned 2481
branch  1 taken 1 (fallthrough)
branch  2 taken 2480
        1: 1859:			buf[len++] = '\\';
        1: 1859-block  0
unconditional  0 taken 1
     2481: 1860:		buf[len++] = *(str++);
     2481: 1860-block  0
unconditional  0 taken 2481
        -: 1861:	}
        -: 1862:
      139: 1863:	buf[len] = '\0';
      139: 1864:	return buf;
      139: 1864-block  0
unconditional  0 taken 139
        -: 1865:}
        -: 1866:
        -: 1867:/* Get all substrings from STR using IFS as substring separator, and,
        -: 1868: * if there is a range, expand it. Returns an array containing all
        -: 1869: * substrings in STR plus expandes ranges, or NULL if: STR is NULL or
        -: 1870: * empty, STR contains only IFS(s), or in case of memory allocation
        -: 1871: * error */
        -: 1872:char **
function get_substr called 53 returned 100% blocks executed 35%
       53: 1873:get_substr(char *str, const char ifs)
        -: 1874:{
       53: 1875:	if (!str || *str == '\0')
       53: 1875-block  0
branch  0 taken 53 (fallthrough)
branch  1 taken 0
       53: 1875-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 53
    #####: 1876:		return (char **)NULL;
    %%%%%: 1876-block  0
unconditional  0 never executed
        -: 1877:
        -: 1878:	/* ############## SPLIT THE STRING #######################*/
        -: 1879:
       53: 1880:	char **substr = (char **)NULL;
       53: 1881:	void *p = (char *)NULL;
       53: 1882:	size_t str_len = strlen(str);
       53: 1883:	size_t length = 0, substr_n = 0;
       53: 1884:	char *buf = (char *)xnmalloc(str_len + 1, sizeof(char));
       53: 1884-block  0
call    0 returned 53
        -: 1885:
      172: 1886:	while (*str) {
unconditional  0 taken 53
      172: 1886-block  0
branch  1 taken 119
branch  2 taken 53 (fallthrough)
      261: 1887:		while (*str != ifs && *str != '\0' && length < (str_len + 1))
      119: 1887-block  0
unconditional  0 taken 119
      261: 1887-block  1
branch  1 taken 195 (fallthrough)
branch  2 taken 66
      195: 1887-block  2
branch  3 taken 142 (fallthrough)
branch  4 taken 53
      142: 1887-block  3
branch  5 taken 142
branch  6 taken 0 (fallthrough)
      142: 1888:			buf[length++] = *(str++);
      142: 1888-block  0
unconditional  0 taken 142
      119: 1889:		if (length) {
      119: 1889-block  0
branch  0 taken 86 (fallthrough)
branch  1 taken 33
       86: 1890:			buf[length] = '\0';
       86: 1891:			p = (char *)realloc(substr, (substr_n + 1) * sizeof(char *));
       86: 1892:			if (!p) {
       86: 1892-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 86
        -: 1893:				/* Free whatever was allocated so far */
        -: 1894:				size_t i;
    #####: 1895:				for (i = 0; i < substr_n; i++)
    %%%%%: 1895-block  0
unconditional  0 never executed
    %%%%%: 1895-block  1
branch  1 never executed
branch  2 never executed
    #####: 1896:					free(substr[i]);
    %%%%%: 1896-block  0
unconditional  0 never executed
    #####: 1897:				free(substr);
    #####: 1898:				return (char **)NULL;
    %%%%%: 1898-block  0
unconditional  0 never executed
        -: 1899:			}
       86: 1900:			substr = (char **)p;
       86: 1901:			p = (char *)malloc(length + 1);
        -: 1902:
       86: 1903:			if (!p) {
       86: 1903-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 86
        -: 1904:				size_t i;
    #####: 1905:				for (i = 0; i < substr_n; i++)
    %%%%%: 1905-block  0
unconditional  0 never executed
    %%%%%: 1905-block  1
branch  1 never executed
branch  2 never executed
    #####: 1906:					free(substr[i]);
    %%%%%: 1906-block  0
unconditional  0 never executed
    #####: 1907:				free(substr);
    #####: 1908:				return (char **)NULL;
    %%%%%: 1908-block  0
unconditional  0 never executed
        -: 1909:			}
        -: 1910:
       86: 1911:			substr[substr_n] = p;
       86: 1912:			p = (char *)NULL;
       86: 1913:			xstrsncpy(substr[substr_n++], buf, length);
       86: 1913-block  0
call    0 returned 86
       86: 1914:			length = 0;
unconditional  0 taken 86
        -: 1915:		} else {
       33: 1916:			str++;
       33: 1916-block  0
unconditional  0 taken 33
        -: 1917:		}
        -: 1918:	}
        -: 1919:
       53: 1920:	free(buf);
        -: 1921:
       53: 1922:	if (!substr_n)
       53: 1922-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 53
    #####: 1923:		return (char **)NULL;
    %%%%%: 1923-block  0
unconditional  0 never executed
        -: 1924:
       53: 1925:	size_t i = 0, j = 0;
       53: 1926:	p = (char *)realloc(substr, (substr_n + 1) * sizeof(char *));
       53: 1927:	if (!p) {
       53: 1927-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 53
    #####: 1928:		for (i = 0; i < substr_n; i++)
    %%%%%: 1928-block  0
unconditional  0 never executed
    %%%%%: 1928-block  1
branch  1 never executed
branch  2 never executed
    #####: 1929:			free(substr[i]);
    %%%%%: 1929-block  0
unconditional  0 never executed
    #####: 1930:		free(substr);
    #####: 1931:		substr = (char **)NULL;
    #####: 1932:		return (char **)NULL;
    %%%%%: 1932-block  0
unconditional  0 never executed
        -: 1933:	}
        -: 1934:
       53: 1935:	substr = (char **)p;
       53: 1936:	p = (char *)NULL;
       53: 1937:	substr[substr_n] = (char *)NULL;
        -: 1938:
        -: 1939:	/* ################### EXPAND RANGES ######################*/
        -: 1940:
       53: 1941:	int afirst = 0, asecond = 0;
        -: 1942:
      139: 1943:	for (i = 0; substr[i]; i++) {
       53: 1943-block  0
unconditional  0 taken 53
       86: 1943-block  1
unconditional  1 taken 86
      139: 1943-block  2
branch  2 taken 86
branch  3 taken 53 (fallthrough)
        -: 1944:		/* Check if substr is a valid range */
       86: 1945:		int ranges_ok = 0;
        -: 1946:		/* If range, get both extremes of it */
      127: 1947:		for (j = 1; substr[i][j]; j++) {
       86: 1947-block  0
unconditional  0 taken 86
       41: 1947-block  1
unconditional  1 taken 41
      127: 1947-block  2
branch  2 taken 46
branch  3 taken 81 (fallthrough)
       46: 1948:			if (substr[i][j] == '-') {
       46: 1948-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 41
        -: 1949:				/* Get strings before and after the dash */
        5: 1950:				char *first = strbfr(substr[i], '-');
        5: 1950-block  0
call    0 returned 5
        5: 1951:				if (!first)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 1952:					break;
        5: 1952-block  0
unconditional  0 taken 5
        -: 1953:
    #####: 1954:				char *second = straft(substr[i], '-');
    %%%%%: 1954-block  0
call    0 never executed
    #####: 1955:				if (!second) {
branch  0 never executed
branch  1 never executed
    #####: 1956:					free(first);
    #####: 1957:					break;
    %%%%%: 1957-block  0
unconditional  0 never executed
        -: 1958:				}
        -: 1959:
        -: 1960:				/* Make sure it is a valid range */
    #####: 1961:				if (is_number(first) && is_number(second)) {
    %%%%%: 1961-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 1961-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1962:					afirst = atoi(first), asecond = atoi(second);
    #####: 1963:					if (asecond <= afirst) {
    %%%%%: 1963-block  0
branch  0 never executed
branch  1 never executed
    #####: 1964:						free(first);
    #####: 1965:						free(second);
    #####: 1966:						break;
    %%%%%: 1966-block  0
unconditional  0 never executed
        -: 1967:					}
        -: 1968:
        -: 1969:					/* We have a valid range */
    #####: 1970:					ranges_ok = 1;
    #####: 1971:					free(first);
    #####: 1972:					free(second);
    %%%%%: 1972-block  0
unconditional  0 never executed
        -: 1973:				} else {
    #####: 1974:					free(first);
    #####: 1975:					free(second);
    #####: 1976:					break;
    %%%%%: 1976-block  0
unconditional  0 never executed
        -: 1977:				}
        -: 1978:			}
        -: 1979:		}
        -: 1980:
       86: 1981:		if (!ranges_ok)
       86: 1981-block  0
branch  0 taken 86 (fallthrough)
branch  1 taken 0
       86: 1982:			continue;
       86: 1982-block  0
unconditional  0 taken 86
        -: 1983:
        -: 1984:		/* If a valid range */
    #####: 1985:		size_t k = 0, next = 0;
    #####: 1986:		char **rbuf = (char **)NULL;
    #####: 1987:		rbuf = (char **)xnmalloc((substr_n + (size_t)(asecond - afirst) + 1),
    %%%%%: 1987-block  0
call    0 never executed
        -: 1988:								sizeof(char *));
        -: 1989:		/* Copy everything before the range expression
        -: 1990:		 * into the buffer */
    #####: 1991:		for (j = 0; j < i; j++)
unconditional  0 never executed
    %%%%%: 1991-block  0
branch  1 never executed
branch  2 never executed
    #####: 1992:			rbuf[k++] = savestring(substr[j], strlen(substr[j]));
    %%%%%: 1992-block  0
call    0 never executed
unconditional  1 never executed
        -: 1993:
        -: 1994:		/* Copy the expanded range into the buffer */
    #####: 1995:		for (j = (size_t)afirst; j <= (size_t)asecond; j++) {
    %%%%%: 1995-block  0
unconditional  0 never executed
    %%%%%: 1995-block  1
branch  1 never executed
branch  2 never executed
    #####: 1996:			rbuf[k] = (char *)xnmalloc((size_t)DIGINUM((int)j) + 1, sizeof(char));
    %%%%%: 1996-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1996-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1996-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1996-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1996-block  4
branch  8 never executed
branch  9 never executed
    %%%%%: 1996-block  5
branch 10 never executed
branch 11 never executed
    %%%%%: 1996-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1996-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1996-block  8
branch 16 never executed
branch 17 never executed
    %%%%%: 1996-block  9
unconditional 18 never executed
    %%%%%: 1996-block 10
unconditional 19 never executed
    %%%%%: 1996-block 11
unconditional 20 never executed
    %%%%%: 1996-block 12
unconditional 21 never executed
    %%%%%: 1996-block 13
unconditional 22 never executed
    %%%%%: 1996-block 14
unconditional 23 never executed
    %%%%%: 1996-block 15
unconditional 24 never executed
    %%%%%: 1996-block 16
unconditional 25 never executed
    %%%%%: 1996-block 17
unconditional 26 never executed
    %%%%%: 1996-block 18
unconditional 27 never executed
    %%%%%: 1996-block 19
unconditional 28 never executed
    %%%%%: 1996-block 20
unconditional 29 never executed
    %%%%%: 1996-block 21
unconditional 30 never executed
    %%%%%: 1996-block 22
unconditional 31 never executed
    %%%%%: 1996-block 23
unconditional 32 never executed
    %%%%%: 1996-block 24
unconditional 33 never executed
    %%%%%: 1996-block 25
unconditional 34 never executed
    %%%%%: 1996-block 26
unconditional 35 never executed
    %%%%%: 1996-block 27
call   36 never executed
    #####: 1997:			sprintf(rbuf[k++], "%zu", j);
unconditional  0 never executed
        -: 1998:		}
        -: 1999:
        -: 2000:		/* Copy everything after the range expression into
        -: 2001:		 * the buffer, if anything */
    #####: 2002:		if (substr[i + 1]) {
    %%%%%: 2002-block  0
branch  0 never executed
branch  1 never executed
    #####: 2003:			next = k;
    #####: 2004:			for (j = (i + 1); substr[j]; j++) {
    %%%%%: 2004-block  0
unconditional  0 never executed
    %%%%%: 2004-block  1
branch  1 never executed
branch  2 never executed
    #####: 2005:				rbuf[k++] = savestring(substr[j], strlen(substr[j]));
    %%%%%: 2005-block  0
call    0 never executed
unconditional  1 never executed
        -: 2006:			}
        -: 2007:		} else { /* If there's nothing after last range, there's no next
        -: 2008:		either */
    #####: 2009:			next = 0;
    %%%%%: 2009-block  0
unconditional  0 never executed
        -: 2010:		}
        -: 2011:
        -: 2012:		/* Repopulate the original array with the expanded range and
        -: 2013:		 * remaining strings */
    #####: 2014:		substr_n = k;
    #####: 2015:		for (j = 0; substr[j]; j++)
    %%%%%: 2015-block  0
unconditional  0 never executed
    %%%%%: 2015-block  1
branch  1 never executed
branch  2 never executed
    #####: 2016:			free(substr[j]);
    %%%%%: 2016-block  0
unconditional  0 never executed
        -: 2017:
    #####: 2018:		substr = (char **)xrealloc(substr, (substr_n + 1) * sizeof(char *));
    %%%%%: 2018-block  0
call    0 never executed
        -: 2019:
    #####: 2020:		for (j = 0; j < substr_n; j++) {
unconditional  0 never executed
    %%%%%: 2020-block  0
branch  1 never executed
branch  2 never executed
    #####: 2021:			substr[j] = savestring(rbuf[j], strlen(rbuf[j]));
    %%%%%: 2021-block  0
call    0 never executed
    #####: 2022:			free(rbuf[j]);
unconditional  0 never executed
        -: 2023:		}
    #####: 2024:		free(rbuf);
        -: 2025:
    #####: 2026:		substr[j] = (char *)NULL;
        -: 2027:
        -: 2028:		/* Proceede only if there's something after the last range */
    #####: 2029:		if (next)
    %%%%%: 2029-block  0
branch  0 never executed
branch  1 never executed
    #####: 2030:			i = next;
    %%%%%: 2030-block  0
unconditional  0 never executed
        -: 2031:		else
    #####: 2032:			break;
    %%%%%: 2032-block  0
unconditional  0 never executed
        -: 2033:	}
        -: 2034:
        -: 2035:	/* ############## REMOVE DUPLICATES ###############*/
        -: 2036:
       53: 2037:	char **dstr = (char **)NULL;
       53: 2038:	size_t len = 0, d;
        -: 2039:
      139: 2040:	for (i = 0; i < substr_n; i++) {
       53: 2040-block  0
unconditional  0 taken 53
       86: 2040-block  1
unconditional  1 taken 86
      139: 2040-block  2
branch  2 taken 86
branch  3 taken 53 (fallthrough)
       86: 2041:		int duplicate = 0;
      119: 2042:		for (d = (i + 1); d < substr_n; d++) {
       86: 2042-block  0
unconditional  0 taken 86
       33: 2042-block  1
unconditional  1 taken 33
      119: 2042-block  2
branch  2 taken 33
branch  3 taken 86 (fallthrough)
      33*: 2043:			if (*substr[i] == *substr[d] && strcmp(substr[i], substr[d]) == 0) {
       33: 2043-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 33
    %%%%%: 2043-block  1
branch  2 never executed
branch  3 never executed
    #####: 2044:				duplicate = 1;
    #####: 2045:				break;
    %%%%%: 2045-block  0
unconditional  0 never executed
        -: 2046:			}
        -: 2047:		}
        -: 2048:
      86*: 2049:		if (duplicate) {
       86: 2049-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 86
    #####: 2050:			free(substr[i]);
    #####: 2051:			continue;
    %%%%%: 2051-block  0
unconditional  0 never executed
        -: 2052:		}
        -: 2053:
       86: 2054:		dstr = (char **)xrealloc(dstr, (len + 1) * sizeof(char *));
       86: 2054-block  0
call    0 returned 86
       86: 2055:		dstr[len++] = savestring(substr[i], strlen(substr[i]));
call    0 returned 86
       86: 2056:		free(substr[i]);
unconditional  0 taken 86
        -: 2057:	}
        -: 2058:
       53: 2059:	free(substr);
       53: 2060:	dstr = (char **)xrealloc(dstr, (len + 1) * sizeof(char *));
       53: 2060-block  0
call    0 returned 53
       53: 2061:	dstr[len] = (char *)NULL;
       53: 2062:	return dstr;
unconditional  0 taken 53
        -: 2063:}
        -: 2064:
        -: 2065:/* This function simply deescapes whatever escaped chars it founds in
        -: 2066: * TEXT, so that readline can compare it to system file names when
        -: 2067: * completing paths. Returns a string containing text without escape
        -: 2068: * sequences */
        -: 2069:char *
function dequote_str called 14 returned 100% blocks executed 79%
       14: 2070:dequote_str(char *text, int mt)
        -: 2071:{
        -: 2072:	UNUSED(mt);
       14: 2073:	if (!text || !*text)
       14: 2073-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14: 2073-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 14
    #####: 2074:		return (char *)NULL;
    %%%%%: 2074-block  0
unconditional  0 never executed
        -: 2075:
        -: 2076:	/* At most, we need as many bytes as text (in case no escape sequence
        -: 2077:	 * is found)*/
       14: 2078:	char *buf = (char *)NULL;
       14: 2079:	buf = (char *)xnmalloc(strlen(text) + 1, sizeof(char));
       14: 2079-block  0
call    0 returned 14
       14: 2080:	size_t len = 0;
        -: 2081:
      331: 2082:	while (*text) {
unconditional  0 taken 14
      331: 2082-block  0
branch  1 taken 317
branch  2 taken 14 (fallthrough)
      317: 2083:		switch (*text) {
      317: 2083-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 317
    #####: 2084:		case '\\':
    #####: 2085:			buf[len++] = *(++text);
    #####: 2086:			break;
    %%%%%: 2086-block  0
unconditional  0 never executed
      317: 2087:		default:
      317: 2088:			buf[len++] = *text;
      317: 2089:			break;
      317: 2089-block  0
unconditional  0 taken 317
        -: 2090:		}
      317: 2091:		if (!*text)
      317: 2091-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 317
    #####: 2092:			break;
    %%%%%: 2092-block  0
unconditional  0 never executed
      317: 2093:		text++;
      317: 2093-block  0
unconditional  0 taken 317
        -: 2094:	}
        -: 2095:
       14: 2096:	buf[len] = '\0';
       14: 2097:	return buf;
       14: 2097-block  0
unconditional  0 taken 14
        -: 2098:}
