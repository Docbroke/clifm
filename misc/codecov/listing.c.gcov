        -:    0:Source:listing.c
        -:    1:/* listing.c -- functions controlling what is listed on the screen */
        -:    2:
        -:    3:/*
        -:    4: * This file is part of CliFM
        -:    5: * 
        -:    6: * Copyright (C) 2016-2021, L. Abramovich <johndoe.arch@outlook.com>
        -:    7: * All rights reserved.
        -:    8:
        -:    9: * CliFM is free software; you can redistribute it and/or modify
        -:   10: * it under the terms of the GNU General Public License as published by
        -:   11: * the Free Software Foundation; either version 2 of the License, or
        -:   12: * (at your option) any later version.
        -:   13: *
        -:   14: * CliFM is distributed in the hope that it will be useful,
        -:   15: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   16: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   17: * GNU General Public License for more details.
        -:   18: *
        -:   19: * You should have received a copy of the GNU General Public License
        -:   20: * along with this program; if not, write to the Free Software
        -:   21: * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
        -:   22: * MA 02110-1301, USA.
        -:   23:*/
        -:   24:
        -:   25:#include "helpers.h"
        -:   26:
        -:   27:#include <stdio.h>
        -:   28:#include <sys/stat.h>
        -:   29:#include <sys/statvfs.h>
        -:   30:#include <sys/types.h>
        -:   31:#include <unistd.h>
        -:   32:#ifdef __linux__
        -:   33:#include <sys/capability.h>
        -:   34:#endif
        -:   35:#include <dirent.h>
        -:   36:#include <errno.h>
        -:   37:#include <fcntl.h>
        -:   38:#include <string.h>
        -:   39:#include <sys/ioctl.h>
        -:   40:
        -:   41:#ifdef _LIST_SPEED
        -:   42:#include <time.h>
        -:   43:#endif
        -:   44:
        -:   45:#ifdef TOURBIN_QSORT
        -:   46:#include "qsort.h"
        -:   47:#define ENTLESS(i, j) (entrycmp(file_info + (i), file_indo + (j)) < 0)
        -:   48:#define ENTSWAP(i, j) (swap_ent((i), (j)))
        -:   49:#define ENTSORT(file_info, n, entrycmp) QSORT((n), ENTLESS, ENTSWAP)
        -:   50:#else
        -:   51:#define ENTSORT(file_info, n, entrycmp) qsort((file_info), (n), sizeof(*(file_info)), (entrycmp))
        -:   52:#endif
        -:   53:
        -:   54:#include "aux.h"
        -:   55:#include "colors.h"
        -:   56:#include "misc.h"
        -:   57:#include "properties.h"
        -:   58:#include "sort.h"
        -:   59:
        -:   60:#include "checks.h"
        -:   61:
        -:   62:#ifndef _NO_ICONS
        -:   63:#include "icons.h"
        -:   64:#endif
        -:   65:
        -:   66:#ifdef _PALAND_PRINTF
        -:   67:#include "printf.h"
        -:   68:#define xprintf printf_
        -:   69:#else
        -:   70:#define xprintf printf
        -:   71:#endif
        -:   72:
        -:   73:static void
function print_sort_method called 22 returned 100% blocks executed 76%
       22:   74:print_sort_method(void)
        -:   75:{
       22:   76:	printf(_("%s->%s Sorted by: "), mi_c, df_c);
       22:   76-block  0
call    0 returned 22
call    1 returned 22
        -:   77:
       22:   78:	switch (sort) {
branch  0 taken 2
branch  1 taken 8
branch  2 taken 3
branch  3 taken 1
branch  4 taken 1
branch  5 taken 1
branch  6 taken 1
branch  7 taken 1
branch  8 taken 1
branch  9 taken 1
branch 10 taken 1
branch 11 taken 1
branch 12 taken 0
        2:   79:	case SNONE:
        2:   80:		puts(_("none"));
        2:   80-block  0
call    0 returned 2
call    1 returned 2
        2:   81:		break;
unconditional  0 taken 2
        8:   82:	case SNAME:
        8:   83:		printf(_("name %s\n"), (sort_reverse) ? "[rev]" : "");
        8:   83-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 6
        2:   83-block  1
unconditional  2 taken 2
        6:   83-block  2
unconditional  3 taken 6
        8:   83-block  3
call    4 returned 8
call    5 returned 8
        8:   84:		break;
unconditional  0 taken 8
        3:   85:	case SSIZE:
       3*:   86:		printf(_("size %s\n"), (sort_reverse) ? "[rev]" : "");
        3:   86-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:   86-block  1
unconditional  2 never executed
        3:   86-block  2
unconditional  3 taken 3
        3:   86-block  3
call    4 returned 3
call    5 returned 3
        3:   87:		break;
unconditional  0 taken 3
        1:   88:	case SATIME:
       1*:   89:		printf(_("atime %s\n"), (sort_reverse) ? "[rev]" : "");
        1:   89-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:   89-block  1
unconditional  2 never executed
        1:   89-block  2
unconditional  3 taken 1
        1:   89-block  3
call    4 returned 1
call    5 returned 1
        1:   90:		break;
unconditional  0 taken 1
        1:   91:	case SBTIME:
        -:   92:#if defined(HAVE_ST_BIRTHTIME) || defined(__BSD_VISIBLE) || defined(_STATX)
       1*:   93:		printf(_("btime %s\n"), (sort_reverse) ? "[rev]" : "");
        1:   93-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:   93-block  1
unconditional  2 never executed
        1:   93-block  2
unconditional  3 taken 1
        1:   93-block  3
call    4 returned 1
call    5 returned 1
        -:   94:#else
        -:   95:		printf(_("btime (not available: using 'ctime') %s\n"),
        -:   96:		    (sort_reverse) ? "[rev]" : "");
        -:   97:#endif
        1:   98:		break;
unconditional  0 taken 1
        1:   99:	case SCTIME:
       1*:  100:		printf(_("ctime %s\n"), (sort_reverse) ? "[rev]" : "");
        1:  100-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  100-block  1
unconditional  2 never executed
        1:  100-block  2
unconditional  3 taken 1
        1:  100-block  3
call    4 returned 1
call    5 returned 1
        1:  101:		break;
unconditional  0 taken 1
        1:  102:	case SMTIME:
       1*:  103:		printf(_("mtime %s\n"), (sort_reverse) ? "[rev]" : "");
        1:  103-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  103-block  1
unconditional  2 never executed
        1:  103-block  2
unconditional  3 taken 1
        1:  103-block  3
call    4 returned 1
call    5 returned 1
        1:  104:		break;
unconditional  0 taken 1
        -:  105:#if __FreeBSD__ || __NetBSD__ || __OpenBSD__ || _BE_POSIX
        -:  106:	case SVER:
        -:  107:		printf(_("version (not available: using 'name') %s\n"),
        -:  108:		    (sort_reverse) ? "[rev]" : "");
        -:  109:#else
        1:  110:	case SVER:
       1*:  111:		printf(_("version %s\n"), (sort_reverse) ? "[rev]" : "");
        1:  111-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  111-block  1
unconditional  2 never executed
        1:  111-block  2
unconditional  3 taken 1
        1:  111-block  3
call    4 returned 1
call    5 returned 1
        -:  112:#endif
        1:  113:		break;
unconditional  0 taken 1
        1:  114:	case SEXT:
       1*:  115:		printf(_("extension %s\n"), (sort_reverse) ? "[rev]" : "");
        1:  115-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  115-block  1
unconditional  2 never executed
        1:  115-block  2
unconditional  3 taken 1
        1:  115-block  3
call    4 returned 1
call    5 returned 1
        1:  116:		break;
unconditional  0 taken 1
        1:  117:	case SINO:
       1*:  118:		printf(_("inode %s\n"), (sort_reverse) ? "[rev]" : "");
        1:  118-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  118-block  1
unconditional  2 never executed
        1:  118-block  2
unconditional  3 taken 1
        1:  118-block  3
call    4 returned 1
call    5 returned 1
        1:  119:		break;
unconditional  0 taken 1
        1:  120:	case SOWN:
        1:  121:		if (light_mode) {
        1:  121-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  122:			printf(_("owner (not available: using 'name') %s\n"),
    %%%%%:  122-block  0
unconditional  0 never executed
    %%%%%:  122-block  1
unconditional  1 never executed
    %%%%%:  122-block  2
call    2 never executed
call    3 never executed
unconditional  4 never executed
    #####:  123:			    (sort_reverse) ? "[rev]" : "");
    %%%%%:  123-block  0
branch  0 never executed
branch  1 never executed
        -:  124:		} else {
       1*:  125:			printf(_("owner %s\n"), (sort_reverse) ? "[rev]" : "");
        1:  125-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  125-block  1
unconditional  2 never executed
        1:  125-block  2
unconditional  3 taken 1
        1:  125-block  3
call    4 returned 1
call    5 returned 1
unconditional  6 taken 1
        -:  126:		}
        1:  127:		break;
        1:  127-block  0
unconditional  0 taken 1
        1:  128:	case SGRP:
        1:  129:		if (light_mode) {
        1:  129-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  130:			printf(_("group (not available: using 'name') %s\n"),
    %%%%%:  130-block  0
unconditional  0 never executed
    %%%%%:  130-block  1
unconditional  1 never executed
    %%%%%:  130-block  2
call    2 never executed
call    3 never executed
unconditional  4 never executed
    #####:  131:			    (sort_reverse) ? "[rev]" : "");
    %%%%%:  131-block  0
branch  0 never executed
branch  1 never executed
        -:  132:		} else {
       1*:  133:			printf(_("group %s\n"), (sort_reverse) ? "[rev]" : "");
        1:  133-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  133-block  1
unconditional  2 never executed
        1:  133-block  2
unconditional  3 taken 1
        1:  133-block  3
call    4 returned 1
call    5 returned 1
unconditional  6 taken 1
        -:  134:		}
        1:  135:		break;
        1:  135-block  0
unconditional  0 taken 1
        -:  136:	}
       22:  137:}
        -:  138:
        -:  139:/* Print the line divinding files and prompt using DIV_LINE_CHAR. If
        -:  140: * DIV_LINE_CHAR takes more than two columns to be printed (ASCII chars
        -:  141: * take only one, but unicode chars could take two), print exactly the
        -:  142: * content of DIV_LINE_CHAR. Otherwise, repeat DIV_LINE_CHAR to fulfill
        -:  143: * all terminal columns. */
        -:  144:static void
function print_div_line called 305 returned 100% blocks executed 100%
      305:  145:print_div_line(void)
        -:  146:{
      305:  147:	fputs(dl_c, stdout);
      305:  147-block  0
call    0 returned 305
        -:  148:
      305:  149:	size_t len = wc_xstrlen(div_line_char);
call    0 returned 305
      305:  150:	if (len <= 2) {
branch  0 taken 7 (fallthrough)
branch  1 taken 298
        -:  151:		int i;
      532:  152:		for (i = (int)(term_cols / len); i--;)
        7:  152-block  0
unconditional  0 taken 7
      532:  152-block  1
branch  1 taken 525
branch  2 taken 7
      525:  153:			fputs(div_line_char, stdout);
      525:  153-block  0
call    0 returned 525
unconditional  1 taken 525
        -:  154:	} else {
      298:  155:		puts(div_line_char);
      298:  155-block  0
call    0 returned 298
unconditional  1 taken 298
        -:  156:	}
        -:  157:
      305:  158:	fputs(df_c, stdout);
      305:  158-block  0
call    0 returned 305
      305:  159:	fflush(stdout);
call    0 returned 305
      305:  160:}
        -:  161:
        -:  162:/* Print free/total space for the filesystem of the current working
        -:  163: * directory */
        -:  164:static void
function print_disk_usage called 0 returned 0% blocks executed 0%
    #####:  165:print_disk_usage(void)
        -:  166:{
    #####:  167:	if (!ws || !ws[cur_ws].path || !*ws[cur_ws].path)
    %%%%%:  167-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  167-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  167-block  2
branch  4 never executed
branch  5 never executed
    #####:  168:		return;
    %%%%%:  168-block  0
unconditional  0 never executed
        -:  169:
        -:  170:	struct statvfs stat;
    #####:  171:	if (statvfs(ws[cur_ws].path, &stat) != EXIT_SUCCESS) {
    %%%%%:  171-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  172:		_err('w', PRINT_PROMPT, "statvfs: %s\n", strerror(errno));
    %%%%%:  172-block  0
call    0 never executed
call    1 never executed
    #####:  173:		return;
unconditional  0 never executed
        -:  174:	}
        -:  175:
    #####:  176:	char *free_space = get_size_unit((off_t)(stat.f_frsize * stat.f_bavail));
    %%%%%:  176-block  0
call    0 never executed
    #####:  177:	char *size = get_size_unit((off_t)(stat.f_blocks * stat.f_frsize));
call    0 never executed
    #####:  178:	printf("%s->%s %s/%s\n", mi_c, df_c, free_space ? free_space : "?",
branch  0 never executed
branch  1 never executed
    %%%%%:  178-block  0
unconditional  2 never executed
    %%%%%:  178-block  1
unconditional  3 never executed
    %%%%%:  178-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  178-block  3
unconditional  6 never executed
    %%%%%:  178-block  4
unconditional  7 never executed
    %%%%%:  178-block  5
call    8 never executed
        -:  179:	    size ? size : "?");
        -:  180:
    #####:  181:	free(free_space);
    #####:  182:	free(size);
    #####:  183:	return;
unconditional  0 never executed
        -:  184:}
        -:  185:
        -:  186:static void
function _print_selfiles called 0 returned 0% blocks executed 0%
    #####:  187:_print_selfiles(unsigned short t_rows)
        -:  188:{
    #####:  189:	int limit = max_printselfiles;
        -:  190:
    #####:  191:	if (max_printselfiles == 0) {
    %%%%%:  191-block  0
branch  0 never executed
branch  1 never executed
        -:  192:		/* Never take more than half terminal height */
    #####:  193:		limit = (t_rows / 2) - 4;
        -:  194:		/* 4 = 2 div lines, 2 prompt lines */
    #####:  195:		if (limit <= 0)
    %%%%%:  195-block  0
branch  0 never executed
branch  1 never executed
    #####:  196:			limit = 1;
    %%%%%:  196-block  0
unconditional  0 never executed
        -:  197:	}
        -:  198:
    #####:  199:	if (limit > (int)sel_n)
    %%%%%:  199-block  0
branch  0 never executed
branch  1 never executed
    #####:  200:		limit = (int)sel_n;
    %%%%%:  200-block  0
unconditional  0 never executed
        -:  201:
        -:  202:	int i;
    #####:  203:	for (i = 0; i < (max_printselfiles != UNSET ? limit : (int)sel_n); i++)
    %%%%%:  203-block  0
unconditional  0 never executed
unconditional  1 never executed
    %%%%%:  203-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  203-block  2
unconditional  4 never executed
    %%%%%:  203-block  3
unconditional  5 never executed
    %%%%%:  203-block  4
branch  6 never executed
branch  7 never executed
    #####:  204:		colors_list(sel_elements[i], 0, NO_PAD, PRINT_NEWLINE);
    %%%%%:  204-block  0
call    0 never executed
        -:  205:
    #####:  206:	if (max_printselfiles != UNSET && limit < (int)sel_n)
    %%%%%:  206-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  206-block  1
branch  2 never executed
branch  3 never executed
    #####:  207:		printf("%d/%zu\n", i, sel_n);
    %%%%%:  207-block  0
call    0 never executed
unconditional  1 never executed
        -:  208:
    #####:  209:	print_div_line();
    %%%%%:  209-block  0
call    0 never executed
    #####:  210:}
        -:  211:
        -:  212:static void
function print_dirhist_map called 0 returned 0% blocks executed 0%
    #####:  213:print_dirhist_map(void)
        -:  214:{
        -:  215:	size_t i;
    #####:  216:	for (i = 0; i < (size_t)dirhist_total_index; i++) {
    %%%%%:  216-block  0
unconditional  0 never executed
    %%%%%:  216-block  1
unconditional  1 never executed
    %%%%%:  216-block  2
branch  2 never executed
branch  3 never executed
    #####:  217:		if (i != (size_t)dirhist_cur_index)
    %%%%%:  217-block  0
branch  0 never executed
branch  1 never executed
    #####:  218:			continue;
    %%%%%:  218-block  0
unconditional  0 never executed
        -:  219:
    #####:  220:		if (i > 0 && old_pwd[i - 1])
    %%%%%:  220-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  220-block  1
branch  2 never executed
branch  3 never executed
    #####:  221:			printf("%zu %s\n", i, old_pwd[i - 1]);
    %%%%%:  221-block  0
call    0 never executed
unconditional  1 never executed
        -:  222:
    #####:  223:		printf("%zu %s%s%s\n", i + 1, dh_c,
    #####:  224:		    old_pwd[i], df_c);
    %%%%%:  224-block  0
call    0 never executed
        -:  225:
    #####:  226:		if (i + 1 < (size_t)dirhist_total_index && old_pwd[i + 1])
branch  0 never executed
branch  1 never executed
    %%%%%:  226-block  0
branch  2 never executed
branch  3 never executed
    #####:  227:			printf("%zu %s\n", i + 2, old_pwd[i + 1]);
    %%%%%:  227-block  0
call    0 never executed
unconditional  1 never executed
        -:  228:
    #####:  229:		break;
    %%%%%:  229-block  0
unconditional  0 never executed
        -:  230:	}
    #####:  231:}
        -:  232:
        -:  233:#ifndef _NO_ICONS
        -:  234:/* Set the icon field to the corresponding icon for FILE. If not found,
        -:  235: * set the default icon */
        -:  236:static void
function get_file_icon called 1 returned 100% blocks executed 75%
        1:  237:get_file_icon(const char *file, int n)
        -:  238:{
        1:  239:	if (!file)
        1:  239-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  240:		return;
    %%%%%:  240-block  0
unconditional  0 never executed
        -:  241:
        1:  242:	int i = (int)(sizeof(icon_filenames) / sizeof(struct icons_t));
        8:  243:	while (--i >= 0) {
        1:  243-block  0
unconditional  0 taken 1
        8:  243-block  1
branch  1 taken 7
branch  2 taken 1 (fallthrough)
       7*:  244:		if (TOUPPER(*file) == TOUPPER(*icon_filenames[i].name)
        7:  244-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7:  244-block  1
branch  2 taken 7 (fallthrough)
branch  3 taken 0
        7:  244-block  2
unconditional  4 taken 7
    %%%%%:  244-block  3
unconditional  5 never executed
        7:  244-block  4
branch  6 taken 1 (fallthrough)
branch  7 taken 6
        1:  244-block  5
branch  8 taken 1 (fallthrough)
branch  9 taken 0
        1:  244-block  6
unconditional 10 taken 1
        6:  244-block  7
unconditional 11 taken 6
        7:  244-block  8
branch 12 taken 0 (fallthrough)
branch 13 taken 7
    #####:  245:		&& strcasecmp(file, icon_filenames[i].name) == 0) {
    %%%%%:  245-block  0
branch  0 never executed
branch  1 never executed
    #####:  246:			file_info[n].icon = icon_filenames[i].icon;
    #####:  247:			file_info[n].icon_color = icon_filenames[i].color;
    #####:  248:			break;
    %%%%%:  248-block  0
unconditional  0 never executed
        -:  249:		}
        -:  250:	}
        -:  251:}
        -:  252:
        -:  253:/* Set the icon field to the corresponding icon for DIR. If not found,
        -:  254: * set the default icon */
        -:  255:static void
function get_dir_icon called 3 returned 100% blocks executed 69%
        3:  256:get_dir_icon(const char *dir, int n)
        -:  257:{
        -:  258:	/* Default values for directories */
        3:  259:	file_info[n].icon = DEF_DIR_ICON;
        3:  260:	file_info[n].icon_color = DEF_DIR_ICON_COLOR;
        -:  261:
        3:  262:	if (!dir)
        3:  262-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  263:		return;
    %%%%%:  263-block  0
unconditional  0 never executed
        -:  264:
        3:  265:	int i = (int)(sizeof(icon_dirnames) / sizeof(struct icons_t));
       30:  266:	while (--i >= 0) {
        3:  266-block  0
unconditional  0 taken 3
       30:  266-block  1
branch  1 taken 27
branch  2 taken 3 (fallthrough)
      27*:  267:		if (TOUPPER(*dir) == TOUPPER(*icon_dirnames[i].name)
       27:  267-block  0
branch  0 taken 27 (fallthrough)
branch  1 taken 0
       27:  267-block  1
branch  2 taken 27 (fallthrough)
branch  3 taken 0
       27:  267-block  2
unconditional  4 taken 27
    %%%%%:  267-block  3
unconditional  5 never executed
       27:  267-block  4
branch  6 taken 0 (fallthrough)
branch  7 taken 27
    %%%%%:  267-block  5
branch  8 never executed
branch  9 never executed
    %%%%%:  267-block  6
unconditional 10 never executed
       27:  267-block  7
unconditional 11 taken 27
       27:  267-block  8
branch 12 taken 6 (fallthrough)
branch 13 taken 21
        6:  268:		&& strcasecmp(dir, icon_dirnames[i].name) == 0) {
        6:  268-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:  269:			file_info[n].icon = icon_dirnames[i].icon;
    #####:  270:			file_info[n].icon_color = icon_dirnames[i].color;
    #####:  271:			break;
    %%%%%:  271-block  0
unconditional  0 never executed
        -:  272:		}
        -:  273:	}
        -:  274:}
        -:  275:
        -:  276:/* Set the icon field to the corresponding icon for EXT. If not found,
        -:  277: * set the default icon */
        -:  278:static void
function get_ext_icon called 2 returned 100% blocks executed 83%
        2:  279:get_ext_icon(const char *restrict ext, int n)
        -:  280:{
        2:  281:	file_info[n].icon = DEF_FILE_ICON;
        2:  282:	file_info[n].icon_color = DEF_FILE_ICON_COLOR;
        -:  283:
        2:  284:	if (!ext)
        2:  284-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  285:		return;
    %%%%%:  285-block  0
unconditional  0 never executed
        -:  286:
        2:  287:	ext++;
        -:  288:
        2:  289:	int i = (int)(sizeof(icon_ext) / sizeof(struct icons_t));
      224:  290:	while (--i >= 0) {
        2:  290-block  0
unconditional  0 taken 2
      224:  290-block  1
branch  1 taken 224
branch  2 taken 0 (fallthrough)
        -:  291:		/* Tolower */
     224*:  292:		char c = (*ext >= 'A' && *ext <= 'Z')
      224:  292-block  0
branch  0 taken 224 (fallthrough)
branch  1 taken 0
      224:  292-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 224
      224:  292-block  2
unconditional  4 taken 224
    #####:  293:			     ? (char)(*ext - 'A' + 'a') : *ext;
    %%%%%:  293-block  0
unconditional  0 never executed
      224:  294:		if (c == *icon_ext[i].name && strcasecmp(ext, icon_ext[i].name) == 0) {
      224:  294-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 220
        4:  294-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 2
        2:  295:			file_info[n].icon = icon_ext[i].icon;
        2:  296:			file_info[n].icon_color = icon_ext[i].color;
        2:  297:			break;
        2:  297-block  0
unconditional  0 taken 2
        -:  298:		}
        -:  299:	}
        -:  300:}
        -:  301:#endif /* _NO_ICONS */
        -:  302:
        -:  303:/* List files in the current working directory (global variable 'path').
        -:  304: * Unlike list_dir(), however, this function uses no color and runs
        -:  305: * neither stat() nor count_dir(), which makes it quite faster. Return
        -:  306: * zero on success or one on error */
        -:  307:static int
function list_dir_light called 3 returned 100% blocks executed 34%
        3:  308:list_dir_light(void)
        -:  309:{
        -:  310:#ifdef _LIST_SPEED
        -:  311:	clock_t start = clock();
        -:  312:#endif
        -:  313:	/* Hide the cursor while listing */
        3:  314:	fputs("\x1b[?25l", stdout);
        3:  314-block  0
call    0 returned 3
        -:  315:
        -:  316:	DIR *dir;
        -:  317:	struct dirent *ent;
        3:  318:	int reset_pager = 0;
        3:  319:	int close_dir = 1;
        -:  320:	/* Get terminal current amount of rows and columns */
        -:  321:	struct winsize w;
        3:  322:	ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
call    0 returned 3
        -:  323:	/* ws_col and ws_row are both unsigned short int according to
        -:  324:	 * /bits/ioctl-types.h */
        -:  325:
        -:  326:	/* These two are global */
        3:  327:	term_cols = w.ws_col;
        3:  328:	term_rows = w.ws_row;
        -:  329:
        3:  330:	if ((dir = opendir(ws[cur_ws].path)) == NULL) {
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    #####:  331:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, ws[cur_ws].path,
call    0 never executed
    #####:  332:		    strerror(errno));
    %%%%%:  332-block  0
call    0 never executed
    #####:  333:		close_dir = 0;
    #####:  334:		goto END;
unconditional  0 never executed
        -:  335:	}
        -:  336:
        -:  337:#ifdef LINUX_INOTIFY
        3:  338:	if (inotify_wd >= 0) {
        3:  338-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  339:		inotify_rm_watch(inotify_fd, inotify_wd);
        3:  339-block  0
call    0 returned 3
        3:  340:		inotify_wd = -1;
unconditional  0 taken 3
        -:  341:	}
        3:  342:	inotify_wd = inotify_add_watch(inotify_fd, ws[cur_ws].path, INOTIFY_MASK);
        3:  342-block  0
call    0 returned 3
        -:  343:
        -:  344:#elif defined(BSD_KQUEUE)
        -:  345:	if (event_fd >= 0) {
        -:  346:		close(event_fd);
        -:  347:		event_fd = -1;
        -:  348:	}
        -:  349:#if defined(O_EVTONLY)
        -:  350:	event_fd = open(ws[cur_ws].path, O_EVTONLY);
        -:  351:#else
        -:  352:	event_fd = open(ws[cur_ws].path, O_RDONLY);
        -:  353:#endif
        -:  354:	if (event_fd >= 0) {
        -:  355:		EV_SET(&events_to_monitor[0], event_fd, EVFILT_VNODE,
        -:  356:		       EV_ADD | EV_CLEAR, KQUEUE_FFLAGS, 0, ws[cur_ws].path);
        -:  357:	}
        -:  358:#endif
        -:  359:
        3:  360:	errno = 0;
        3:  361:	longest = 0;
        3:  362:	register unsigned int n = 0;
        3:  363:	unsigned int total_dents = 0, count = 0;
        -:  364:
        3:  365:	file_info = (struct fileinfo *)xnmalloc(ENTRY_N + 2,
call    0 returned 3
        -:  366:	    sizeof(struct fileinfo));
        -:  367:
       24:  368:	while ((ent = readdir(dir))) {
unconditional  0 taken 3
       24:  368-block  0
call    1 returned 24
branch  2 taken 21
branch  3 taken 3 (fallthrough)
       21:  369:		char *ename = ent->d_name;
        -:  370:		/* Skip self and parent directories */
       21:  371:		if (*ename == '.' && (!ename[1] || (ename[1] == '.' && !ename[2])))
       21:  371-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 15
        6:  371-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 3
        3:  371-block  2
branch  4 taken 3 (fallthrough)
branch  5 taken 0
        3:  371-block  3
branch  6 taken 3 (fallthrough)
branch  7 taken 0
        6:  372:			continue;
        6:  372-block  0
unconditional  0 taken 6
        -:  373:
        -:  374:		/* Skip files according to FILTER */
       15:  375:		if (filter) {
       15:  375-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####:  376:			if (regexec(&regex_exp, ename, 0, NULL, 0) == EXIT_SUCCESS) {
    %%%%%:  376-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  377:				if (filter_rev)
    %%%%%:  377-block  0
branch  0 never executed
branch  1 never executed
    #####:  378:					continue;
    %%%%%:  378-block  0
unconditional  0 never executed
    #####:  379:			} else if (!filter_rev) {
    %%%%%:  379-block  0
branch  0 never executed
branch  1 never executed
    #####:  380:				continue;
    %%%%%:  380-block  0
unconditional  0 never executed
        -:  381:			}
        -:  382:		}
        -:  383:
      15*:  384:		if (!show_hidden && *ename == '.')
       15:  384-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    %%%%%:  384-block  1
branch  2 never executed
branch  3 never executed
    #####:  385:			continue;
    %%%%%:  385-block  0
unconditional  0 never executed
        -:  386:#if !defined(_DIRENT_HAVE_D_TYPE)
        -:  387:		struct stat attr;
        -:  388:		if (lstat(ename, &attr) == -1)
        -:  389:			continue;
        -:  390:		if (only_dirs && (attr.st_mode & S_IFMT) != S_IFDIR)
        -:  391:#else
      15*:  392:		if (only_dirs && ent->d_type != DT_DIR)
       15:  392-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    %%%%%:  392-block  1
branch  2 never executed
branch  3 never executed
        -:  393:#endif /* !_DIRENT_HAVE_D_TYPE */
    #####:  394:			continue;
    %%%%%:  394-block  0
unconditional  0 never executed
        -:  395:
       15:  396:		if (count > ENTRY_N) {
       15:  396-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####:  397:			count = 0;
    #####:  398:			total_dents = n + ENTRY_N;
    #####:  399:			file_info = xrealloc(file_info, (total_dents + 2) * sizeof(struct fileinfo));
    %%%%%:  399-block  0
call    0 never executed
unconditional  1 never executed
        -:  400:		}
        -:  401:
       15:  402:		file_info[n].name = (char *)xnmalloc(NAME_MAX + 1, sizeof(char));
       15:  402-block  0
call    0 returned 15
        -:  403:
       15:  404:		if (!unicode) {
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####:  405:			file_info[n].len = xstrsncpy(file_info[n].name, ename, NAME_MAX);
    %%%%%:  405-block  0
call    0 never executed
unconditional  1 never executed
        -:  406:		} else {
       15:  407:			xstrsncpy(file_info[n].name, ename, NAME_MAX);
       15:  407-block  0
call    0 returned 15
       15:  408:			file_info[n].len = wc_xstrlen(ename);
call    0 returned 15
unconditional  1 taken 15
        -:  409:		}
        -:  410:
        -:  411:		/* ################  */
        -:  412:#if !defined(_DIRENT_HAVE_D_TYPE)
        -:  413:		switch (attr.st_mode & S_IFMT) {
        -:  414:		case S_IFBLK: file_info[n].type = DT_BLK; break;
        -:  415:		case S_IFCHR: file_info[n].type = DT_CHR; break;
        -:  416:		case S_IFDIR: file_info[n].type = DT_DIR; break;
        -:  417:		case S_IFIFO: file_info[n].type = DT_FIFO; break;
        -:  418:		case S_IFLNK: file_info[n].type = DT_LNK; break;
        -:  419:		case S_IFREG: file_info[n].type = DT_REG; break;
        -:  420:		case S_IFSOCK: file_info[n].type = DT_SOCK; break;
        -:  421:		default: file_info[n].type = DT_UNKNOWN; break;
        -:  422:		}
        -:  423:		file_info[n].dir = (file_info[n].type == DT_DIR) ? 1 : 0;
        -:  424:		file_info[n].symlink = (file_info[n].type == DT_LNK) ? 1 : 0;
        -:  425:#else
       15:  426:		file_info[n].dir = (ent->d_type == DT_DIR) ? 1 : 0;
       15:  427:		file_info[n].symlink = (ent->d_type == DT_LNK) ? 1 : 0;
       15:  428:		file_info[n].type = ent->d_type;
        -:  429:#endif /* !_DIRENT_HAVE_D_TYPE */
       15:  430:		file_info[n].inode = ent->d_ino;
       15:  431:		file_info[n].linkn = 1;
       15:  432:		file_info[n].size = 1;
       15:  433:		file_info[n].color = (char *)NULL;
       15:  434:		file_info[n].ext_color = (char *)NULL;
       15:  435:		file_info[n].exec = 0;
       15:  436:		file_info[n].ruser = 1;
       15:  437:		file_info[n].filesn = 0;
       15:  438:		file_info[n].time = 0;
        -:  439:#ifndef _NO_ICONS
       15:  440:		file_info[n].icon = DEF_FILE_ICON;
       15:  441:		file_info[n].icon_color = DEF_FILE_ICON_COLOR;
        -:  442:#endif
       15:  443:		switch (file_info[n].type) {
       15:  443-block  0
branch  0 taken 6
branch  1 taken 3
branch  2 taken 6
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
        -:  444:
        6:  445:		case DT_DIR:
        -:  446:#ifndef _NO_ICONS
        6:  447:			if (icons) {
        6:  447-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:  448:				get_dir_icon(file_info[n].name, (int)n);
    %%%%%:  448-block  0
call    0 never executed
        -:  449:				/* If set from the color scheme file */
    #####:  450:				if (*dir_ico_c)
branch  0 never executed
branch  1 never executed
    #####:  451:					file_info[n].icon_color = dir_ico_c;
    %%%%%:  451-block  0
unconditional  0 never executed
        -:  452:			}
        -:  453:#endif
        -:  454:
        -:  455:			files_counter
        6:  456:			    ? (file_info[n].filesn = (count_dir(ename, NO_CPOP) - 2))
        6:  456-block  0
call    0 returned 6
      12*:  457:			    : (file_info[n].filesn = 1);
        6:  457-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
unconditional  2 taken 6
    %%%%%:  457-block  1
unconditional  3 never executed
        -:  458:
        6:  459:			if (file_info[n].filesn > 0) {
        6:  459-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        5:  460:				file_info[n].color = di_c;
        5:  460-block  0
unconditional  0 taken 5
        1:  461:			} else if (file_info[n].filesn == 0) {
        1:  461-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  462:				file_info[n].color = ed_c;
        1:  462-block  0
unconditional  0 taken 1
        -:  463:			} else {
    #####:  464:				file_info[n].color = nd_c;
        -:  465:#ifndef _NO_ICONS
    #####:  466:				file_info[n].icon = ICON_LOCK;
    #####:  467:				file_info[n].icon_color = YELLOW;
    %%%%%:  467-block  0
unconditional  0 never executed
        -:  468:#endif
        -:  469:			}
        -:  470:
        6:  471:			break;
        6:  471-block  0
unconditional  0 taken 6
        -:  472:
        3:  473:		case DT_LNK:
        -:  474:#ifndef _NO_ICONS
        3:  475:			file_info[n].icon = ICON_LINK;
        -:  476:#endif
        3:  477:			file_info[n].color = ln_c;
        3:  478:			break;
        3:  478-block  0
unconditional  0 taken 3
        -:  479:
        6:  480:		case DT_REG: file_info[n].color = fi_c; break;
        6:  480-block  0
unconditional  0 taken 6
    #####:  481:		case DT_SOCK: file_info[n].color = so_c; break;
    %%%%%:  481-block  0
unconditional  0 never executed
    #####:  482:		case DT_FIFO: file_info[n].color = pi_c; break;
    %%%%%:  482-block  0
unconditional  0 never executed
    #####:  483:		case DT_BLK: file_info[n].color = bd_c; break;
    %%%%%:  483-block  0
unconditional  0 never executed
    #####:  484:		case DT_CHR: file_info[n].color = cd_c; break;
    %%%%%:  484-block  0
unconditional  0 never executed
    #####:  485:		case DT_UNKNOWN: file_info[n].color = uf_c; break;
    %%%%%:  485-block  0
unconditional  0 never executed
    #####:  486:		default: file_info[n].color = df_c; break;
    %%%%%:  486-block  0
unconditional  0 never executed
        -:  487:		}
        -:  488:
        -:  489:#ifndef _NO_ICONS
      15*:  490:		if (xargs.icons_use_file_color == 1 && icons)
       15:  490-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    %%%%%:  490-block  1
branch  2 never executed
branch  3 never executed
    #####:  491:			file_info[n].icon_color = file_info[n].color;
    %%%%%:  491-block  0
unconditional  0 never executed
        -:  492:#endif
        -:  493:
       15:  494:		n++;
       15:  495:		count++;
       15:  495-block  0
unconditional  0 taken 15
        -:  496:	}
        -:  497:
        3:  498:	file_info[n].name = (char *)NULL;
        3:  499:	files = (size_t)n;
        -:  500:
        3:  501:	if (n == 0) {
        3:  501-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  502:		printf("%s. ..%s\n", colorize ? di_c : df_c, df_c);
    %%%%%:  502-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  502-block  1
unconditional  2 never executed
    %%%%%:  502-block  2
unconditional  3 never executed
    %%%%%:  502-block  3
call    4 never executed
    #####:  503:		free(file_info);
    #####:  504:		goto END;
unconditional  0 never executed
        -:  505:	}
        -:  506:
        3:  507:	if (sort)
        3:  507-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  508:		ENTSORT(file_info, n, entrycmp);
        3:  508-block  0
call    0 returned 3
unconditional  1 taken 3
        -:  509:
        -:  510:	int i;
        3:  511:	register size_t counter = 0;
        3:  512:	size_t columns_n = 1;
        -:  513:
        -:  514:	/* Get the longest file name */
       3*:  515:	if (columned || long_view) {
        3:  515-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:  515-block  1
branch  2 never executed
branch  3 never executed
        3:  516:		i = (int)n;
       18:  517:		while (--i >= 0) {
        3:  517-block  0
unconditional  0 taken 3
       18:  517-block  1
branch  1 taken 15
branch  2 taken 3 (fallthrough)
       15:  518:			size_t total_len = 0;
      15*:  519:			file_info[i].eln_n = no_eln ? -1 : DIGINUM(i + 1);
       15:  519-block  0
branch  0 taken 15 (fallthrough)
branch  1 taken 0
       15:  519-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 15
    %%%%%:  519-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  519-block  3
branch  6 never executed
branch  7 never executed
    %%%%%:  519-block  4
branch  8 never executed
branch  9 never executed
    %%%%%:  519-block  5
branch 10 never executed
branch 11 never executed
    %%%%%:  519-block  6
branch 12 never executed
branch 13 never executed
    %%%%%:  519-block  7
branch 14 never executed
branch 15 never executed
    %%%%%:  519-block  8
branch 16 never executed
branch 17 never executed
    %%%%%:  519-block  9
branch 18 never executed
branch 19 never executed
    %%%%%:  519-block 10
unconditional 20 never executed
    %%%%%:  519-block 11
unconditional 21 never executed
    %%%%%:  519-block 12
unconditional 22 never executed
    %%%%%:  519-block 13
unconditional 23 never executed
    %%%%%:  519-block 14
unconditional 24 never executed
    %%%%%:  519-block 15
unconditional 25 never executed
    %%%%%:  519-block 16
unconditional 26 never executed
    %%%%%:  519-block 17
unconditional 27 never executed
    %%%%%:  519-block 18
unconditional 28 never executed
    %%%%%:  519-block 19
unconditional 29 never executed
    %%%%%:  519-block 20
unconditional 30 never executed
    %%%%%:  519-block 21
unconditional 31 never executed
    %%%%%:  519-block 22
unconditional 32 never executed
    %%%%%:  519-block 23
unconditional 33 never executed
    %%%%%:  519-block 24
unconditional 34 never executed
    %%%%%:  519-block 25
unconditional 35 never executed
    %%%%%:  519-block 26
unconditional 36 never executed
       15:  519-block 27
unconditional 37 taken 15
       15:  519-block 28
unconditional 38 taken 15
    %%%%%:  519-block 29
unconditional 39 never executed
       15:  520:			total_len = (size_t)file_info[i].eln_n + 1 + file_info[i].len;
        -:  521:
       15:  522:			if (!long_view && classify) {
       15:  522-block  0
branch  0 taken 15 (fallthrough)
branch  1 taken 0
       15:  522-block  1
branch  2 taken 15 (fallthrough)
branch  3 taken 0
       15:  523:				if (file_info[i].dir)
       15:  523-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 9
        6:  524:					total_len++;
        6:  524-block  0
unconditional  0 taken 6
        -:  525:
       15:  526:				if (file_info[i].filesn > 0 && files_counter)
       15:  526-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 10
        5:  526-block  1
branch  2 taken 5 (fallthrough)
branch  3 taken 0
       5*:  527:					total_len += DIGINUM(file_info[i].filesn);
        5:  527-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:  527-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  527-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  527-block  3
branch  6 never executed
branch  7 never executed
    %%%%%:  527-block  4
branch  8 never executed
branch  9 never executed
    %%%%%:  527-block  5
branch 10 never executed
branch 11 never executed
    %%%%%:  527-block  6
branch 12 never executed
branch 13 never executed
    %%%%%:  527-block  7
branch 14 never executed
branch 15 never executed
    %%%%%:  527-block  8
branch 16 never executed
branch 17 never executed
    %%%%%:  527-block  9
unconditional 18 never executed
    %%%%%:  527-block 10
unconditional 19 never executed
    %%%%%:  527-block 11
unconditional 20 never executed
    %%%%%:  527-block 12
unconditional 21 never executed
    %%%%%:  527-block 13
unconditional 22 never executed
    %%%%%:  527-block 14
unconditional 23 never executed
    %%%%%:  527-block 15
unconditional 24 never executed
    %%%%%:  527-block 16
unconditional 25 never executed
    %%%%%:  527-block 17
unconditional 26 never executed
    %%%%%:  527-block 18
unconditional 27 never executed
    %%%%%:  527-block 19
unconditional 28 never executed
    %%%%%:  527-block 20
unconditional 29 never executed
    %%%%%:  527-block 21
unconditional 30 never executed
    %%%%%:  527-block 22
unconditional 31 never executed
    %%%%%:  527-block 23
unconditional 32 never executed
    %%%%%:  527-block 24
unconditional 33 never executed
    %%%%%:  527-block 25
unconditional 34 never executed
        5:  527-block 26
unconditional 35 taken 5
        5:  527-block 27
unconditional 36 taken 5
        -:  528:
       15:  529:				if (!file_info[i].dir && !colorize) {
       15:  529-block  0
branch  0 taken 9 (fallthrough)
branch  1 taken 6
        9:  529-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 9
    #####:  530:					switch (file_info[i].type) {
    %%%%%:  530-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  531:					case DT_REG:
    #####:  532:						if (file_info[i].exec)
    %%%%%:  532-block  0
branch  0 never executed
branch  1 never executed
    #####:  533:							total_len++;
    %%%%%:  533-block  0
unconditional  0 never executed
    #####:  534:						break;
    %%%%%:  534-block  0
unconditional  0 never executed
    #####:  535:					case DT_LNK:  /* fallthrough */
        -:  536:					case DT_SOCK: /* fallthrough */
        -:  537:					case DT_FIFO: /* fallthrough */
    #####:  538:					case DT_UNKNOWN: total_len++; break;
    %%%%%:  538-block  0
unconditional  0 never executed
        -:  539:					}
        -:  540:				}
        -:  541:			}
        -:  542:
       15:  543:			if (total_len > longest) {
       15:  543-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 9
        6:  544:				if (max_files == UNSET)
        6:  544-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6:  545:					longest = total_len;
        6:  545-block  0
unconditional  0 taken 6
    #####:  546:				else if (i < max_files)
    %%%%%:  546-block  0
branch  0 never executed
branch  1 never executed
    #####:  547:					longest = total_len;
    %%%%%:  547-block  0
unconditional  0 never executed
        -:  548:			}
        -:  549:		}
        -:  550:#ifndef _NO_ICONS
       3*:  551:		if (icons && !long_view && columned)
        3:  551-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:  551-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  551-block  2
branch  4 never executed
branch  5 never executed
    #####:  552:			longest += 3;
    %%%%%:  552-block  0
unconditional  0 never executed
        -:  553:#endif
        -:  554:	}
        -:  555:
        -:  556:				/* ########################
        -:  557:				 * #    LONG VIEW MODE    #
        -:  558:				 * ######################## */
        -:  559:
        3:  560:	if (long_view) {
        3:  560-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:  561:		struct stat lattr;
    #####:  562:		int space_left = (int)term_cols - MAX_PROP_STR;
        -:  563:
    #####:  564:		if (space_left < min_name_trim)
    %%%%%:  564-block  0
branch  0 never executed
branch  1 never executed
    #####:  565:			space_left = min_name_trim;
    %%%%%:  565-block  0
unconditional  0 never executed
        -:  566:
    #####:  567:		if ((int)longest < space_left)
    %%%%%:  567-block  0
branch  0 never executed
branch  1 never executed
    #####:  568:			space_left = (int)longest;
    %%%%%:  568-block  0
unconditional  0 never executed
        -:  569:
    #####:  570:		int k = (int)files;
    #####:  571:		for (i = 0; i < k; i++) {
    %%%%%:  571-block  0
unconditional  0 never executed
    %%%%%:  571-block  1
unconditional  1 never executed
    %%%%%:  571-block  2
branch  2 never executed
branch  3 never executed
    #####:  572:			if (max_files != UNSET && i == max_files)
    %%%%%:  572-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  572-block  1
branch  2 never executed
branch  3 never executed
    #####:  573:				break;
    %%%%%:  573-block  0
unconditional  0 never executed
    #####:  574:			if (lstat(file_info[i].name, &lattr) == -1)
    %%%%%:  574-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  575:				continue;
    %%%%%:  575-block  0
unconditional  0 never executed
        -:  576:
    #####:  577:			if (pager) {
    %%%%%:  577-block  0
branch  0 never executed
branch  1 never executed
    #####:  578:				if (counter > (size_t)(term_rows - 2)) {
    %%%%%:  578-block  0
branch  0 never executed
branch  1 never executed
    #####:  579:					fputs("\x1b[7;97m--Mas--\x1b[0;49m", stdout);
    %%%%%:  579-block  0
call    0 never executed
        -:  580:
    #####:  581:					switch (xgetchar()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  582:					/* Advance one line at a time */
    #####:  583:					case 66: /* fallthrough */ /* Down arrow */
        -:  584:					case 10: /* fallthrough */ /* Enter */
        -:  585:					case 32:		   /* Space */
    #####:  586:						break;
    %%%%%:  586-block  0
unconditional  0 never executed
        -:  587:
        -:  588:					/* Advance one page at a time */
    #####:  589:					case 126:
    #####:  590:						counter = 0; /* Page Down */
    #####:  591:						break;
    %%%%%:  591-block  0
unconditional  0 never executed
        -:  592:
    #####:  593:					case 63: /* fallthrough */ /* ? */
        -:  594:					case 104: {		   /* h: Print pager help */
    #####:  595:						CLEAR;
    %%%%%:  595-block  0
call    0 never executed
        -:  596:
    #####:  597:						fputs(_("?, h: help\n"
call    0 never executed
call    1 never executed
        -:  598:							"Down arrow, Enter, Space: Advance one line\n"
        -:  599:							"Page Down: Advance one page\n"
        -:  600:							"q: Stop pagging\n"), stdout);
        -:  601:
    #####:  602:						int l = (int)term_rows - 5;
    #####:  603:						while (--l >= 0)
unconditional  0 never executed
    %%%%%:  603-block  0
branch  1 never executed
branch  2 never executed
    #####:  604:							putchar('\n');
    %%%%%:  604-block  0
call    0 never executed
unconditional  1 never executed
        -:  605:
    #####:  606:						fputs("\x1b[7;97m--Mas--\x1b[0;49m", stdout);
    %%%%%:  606-block  0
call    0 never executed
        -:  607:
    #####:  608:						i -= (term_rows - 1);
    #####:  609:						if (i < 0)
branch  0 never executed
branch  1 never executed
    #####:  610:							i = 0;
    %%%%%:  610-block  0
unconditional  0 never executed
        -:  611:
    #####:  612:						counter = 0;
    #####:  613:						xgetchar();
    %%%%%:  613-block  0
call    0 never executed
    #####:  614:						CLEAR;
call    0 never executed
    #####:  615:					} break;
unconditional  0 never executed
        -:  616:
        -:  617:					/* Stop paging (and set a flag to reenable the pager
        -:  618:					 * later) */
    #####:  619:					case 99:  /* 'c' */
        -:  620:					case 112: /* 'p' */
        -:  621:					case 113:
    #####:  622:						pager = 0, reset_pager = 1; /* 'q' */
    #####:  623:						break;
    %%%%%:  623-block  0
unconditional  0 never executed
        -:  624:
        -:  625:					/* If another key is pressed, go back one position.
        -:  626:					 * Otherwise, some file names won't be listed.*/
    #####:  627:					default:
    #####:  628:						i--;
    #####:  629:						fputs("\r\x1b[K\x1b[3J", stdout);
    %%%%%:  629-block  0
call    0 never executed
    #####:  630:						continue;
unconditional  0 never executed
        -:  631:					}
        -:  632:
    #####:  633:					fputs("\r\x1b[K\x1b[3J", stdout);
    %%%%%:  633-block  0
call    0 never executed
unconditional  1 never executed
        -:  634:				}
        -:  635:
    #####:  636:				counter++;
    %%%%%:  636-block  0
unconditional  0 never executed
        -:  637:			}
        -:  638:
    #####:  639:			file_info[i].uid = lattr.st_uid;
    #####:  640:			file_info[i].gid = lattr.st_gid;
    #####:  641:			file_info[i].ltime = (time_t)lattr.st_mtim.tv_sec;
    #####:  642:			file_info[i].mode = lattr.st_mode;
    #####:  643:			file_info[i].size = lattr.st_size;
        -:  644:
        -:  645:			/* Print ELN. The remaining part of the line will be
        -:  646:			 * printed by print_entry_props() */
    #####:  647:			if (!no_eln)
    %%%%%:  647-block  0
branch  0 never executed
branch  1 never executed
    #####:  648:				printf("%s%d%s ", el_c, i + 1, df_c);
    %%%%%:  648-block  0
call    0 never executed
unconditional  1 never executed
        -:  649:
    #####:  650:			print_entry_props(&file_info[i], (size_t)space_left);
    %%%%%:  650-block  0
call    0 never executed
unconditional  1 never executed
        -:  651:		}
        -:  652:
    #####:  653:		goto END;
    %%%%%:  653-block  0
unconditional  0 never executed
        -:  654:	}
        -:  655:
        -:  656:				/* ########################
        -:  657:				 * #   NORMAL VIEW MODE   #
        -:  658:				 * ######################## */
        -:  659:
        3:  660:	int last_column = 0;
        -:  661:
        -:  662:/*	char *line_buf = (char *)xcalloc(term_cols * 10, sizeof(char));
        -:  663:	size_t line_sz = 0; */
        -:  664:
        -:  665:	/* Get possible amount of columns for the dirlist screen */
        3:  666:	if (!columned) {
        3:  666-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  667:		columns_n = 1;
    %%%%%:  667-block  0
unconditional  0 never executed
        -:  668:	} else {
        3:  669:		columns_n = (size_t)term_cols / (longest + 1); /* +1 for the
        -:  670:		space between file names */
        -:  671:
        -:  672:		/* If longest is bigger than terminal columns, columns_n will
        -:  673:		 * be negative or zero. To avoid this: */
        3:  674:		if (columns_n < 1)
        3:  674-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  675:			columns_n = 1;
    %%%%%:  675-block  0
unconditional  0 never executed
        -:  676:
        -:  677:		/* If we have only three files, we don't want four columns */
        3:  678:		if (columns_n > (size_t)n)
        3:  678-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  679:			columns_n = (size_t)n;
        1:  679-block  0
unconditional  0 taken 1
        -:  680:	}
        -:  681:
        3:  682:	int nn = (int)n;
        3:  683:	size_t cur_cols = 0;
       18:  684:	for (i = 0; i < nn; i++) {
        3:  684-block  0
unconditional  0 taken 3
       15:  684-block  1
unconditional  1 taken 15
       18:  684-block  2
branch  2 taken 15
branch  3 taken 3 (fallthrough)
      15*:  685:		if (max_files != UNSET && i == max_files)
       15:  685-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    %%%%%:  685-block  1
branch  2 never executed
branch  3 never executed
    #####:  686:			break;
    %%%%%:  686-block  0
unconditional  0 never executed
        -:  687:
        -:  688:		/* A basic pager for directories containing large amount of
        -:  689:		 * files. What's missing? It only goes downwards. To go
        -:  690:		 * backwards, use the terminal scrollback function */
       15:  691:		if (pager) {
       15:  691-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
        -:  692:			/* Run the pager only once all columns and rows fitting in
        -:  693:			 * the screen are filled with the corresponding file names */
    #####:  694:			if (last_column && counter > columns_n * ((size_t)term_rows - 2)) {
    %%%%%:  694-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  694-block  1
branch  2 never executed
branch  3 never executed
    #####:  695:				fputs("\x1b[7;97m--Mas--\x1b[0;49m", stdout);
    %%%%%:  695-block  0
call    0 never executed
        -:  696:
    #####:  697:				switch (xgetchar()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  698:
        -:  699:				/* Advance one line at a time */
    #####:  700:				case 66: /* fallthrough */ /* Down arrow */
        -:  701:				case 10: /* fallthrough */ /* Enter */
        -:  702:				case 32:		   /* Space */
    #####:  703:					break;
    %%%%%:  703-block  0
unconditional  0 never executed
        -:  704:
        -:  705:				/* Advance one page at a time */
    #####:  706:				case 126:
    #####:  707:					counter = 0; /* Page Down */
    #####:  708:					break;
    %%%%%:  708-block  0
unconditional  0 never executed
        -:  709:
    #####:  710:				case 63: /* fallthrough */ /* ? */
        -:  711:				case 104: {		   /* h: Print pager help */
    #####:  712:					CLEAR;
    %%%%%:  712-block  0
call    0 never executed
        -:  713:
    #####:  714:					fputs(_("?, h: help\n"
call    0 never executed
call    1 never executed
        -:  715:						"Down arrow, Enter, Space: Advance one line\n"
        -:  716:						"Page Down: Advance one page\n"
        -:  717:						"q: Stop pagging\n"), stdout);
        -:  718:
    #####:  719:					int l = (int)term_rows - 5;
    #####:  720:					while (--l >= 0)
unconditional  0 never executed
    %%%%%:  720-block  0
branch  1 never executed
branch  2 never executed
    #####:  721:						putchar('\n');
    %%%%%:  721-block  0
call    0 never executed
unconditional  1 never executed
        -:  722:
    #####:  723:					fputs("\x1b[7;97m--Mas--\x1b[0;49m", stdout);
    %%%%%:  723-block  0
call    0 never executed
        -:  724:
    #####:  725:					i -= (int)((term_rows * columns_n) - 1);
    #####:  726:					if (i < 0)
branch  0 never executed
branch  1 never executed
    #####:  727:						i = 0;
    %%%%%:  727-block  0
unconditional  0 never executed
        -:  728:
    #####:  729:					counter = 0;
    #####:  730:					xgetchar();
    %%%%%:  730-block  0
call    0 never executed
    #####:  731:					CLEAR;
call    0 never executed
    #####:  732:				} break;
unconditional  0 never executed
        -:  733:
        -:  734:				/* Stop paging (and set a flag to reenable the pager
        -:  735:				 * later) */
    #####:  736:				case 99:  /* 'c' */
        -:  737:				case 112: /* 'p' */
        -:  738:				case 113:
    #####:  739:					pager = 0, reset_pager = 1; /* 'q' */
    #####:  740:					break;
    %%%%%:  740-block  0
unconditional  0 never executed
        -:  741:
        -:  742:				/* If another key is pressed, go back one position.
        -:  743:				 * Otherwise, some file names won't be listed.*/
    #####:  744:				default:
    #####:  745:					i--;
    #####:  746:					fputs("\r\x1b[K\x1b[3J", stdout);
    %%%%%:  746-block  0
call    0 never executed
    #####:  747:					continue;
unconditional  0 never executed
        -:  748:				}
        -:  749:
    #####:  750:				fputs("\r\x1b[K\x1b[3J", stdout);
    %%%%%:  750-block  0
call    0 never executed
unconditional  1 never executed
        -:  751:			}
        -:  752:
    #####:  753:			counter++;
    %%%%%:  753-block  0
unconditional  0 never executed
        -:  754:		}
        -:  755:
       15:  756:		if (++cur_cols == columns_n) {
       15:  756-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 12
        3:  757:			cur_cols = 0;
        3:  758:			last_column = 1;
        3:  758-block  0
unconditional  0 taken 3
        -:  759:		} else {
       12:  760:			last_column = 0;
       12:  760-block  0
unconditional  0 taken 12
        -:  761:		}
        -:  762:
      15*:  763:		file_info[i].eln_n = no_eln ? -1 : DIGINUM(i + 1);
       15:  763-block  0
branch  0 taken 15 (fallthrough)
branch  1 taken 0
       15:  763-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 15
    %%%%%:  763-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  763-block  3
branch  6 never executed
branch  7 never executed
    %%%%%:  763-block  4
branch  8 never executed
branch  9 never executed
    %%%%%:  763-block  5
branch 10 never executed
branch 11 never executed
    %%%%%:  763-block  6
branch 12 never executed
branch 13 never executed
    %%%%%:  763-block  7
branch 14 never executed
branch 15 never executed
    %%%%%:  763-block  8
branch 16 never executed
branch 17 never executed
    %%%%%:  763-block  9
branch 18 never executed
branch 19 never executed
    %%%%%:  763-block 10
unconditional 20 never executed
    %%%%%:  763-block 11
unconditional 21 never executed
    %%%%%:  763-block 12
unconditional 22 never executed
    %%%%%:  763-block 13
unconditional 23 never executed
    %%%%%:  763-block 14
unconditional 24 never executed
    %%%%%:  763-block 15
unconditional 25 never executed
    %%%%%:  763-block 16
unconditional 26 never executed
    %%%%%:  763-block 17
unconditional 27 never executed
    %%%%%:  763-block 18
unconditional 28 never executed
    %%%%%:  763-block 19
unconditional 29 never executed
    %%%%%:  763-block 20
unconditional 30 never executed
    %%%%%:  763-block 21
unconditional 31 never executed
    %%%%%:  763-block 22
unconditional 32 never executed
    %%%%%:  763-block 23
unconditional 33 never executed
    %%%%%:  763-block 24
unconditional 34 never executed
    %%%%%:  763-block 25
unconditional 35 never executed
    %%%%%:  763-block 26
unconditional 36 never executed
       15:  763-block 27
unconditional 37 taken 15
       15:  763-block 28
unconditional 38 taken 15
    %%%%%:  763-block 29
unconditional 39 never executed
       15:  764:		int ind_char = 1;
        -:  765:
       15:  766:		if (!classify)
       15:  766-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####:  767:			ind_char = 0;
    %%%%%:  767-block  0
unconditional  0 never executed
        -:  768:
       15:  769:		if (colorize) {
       15:  769-block  0
branch  0 taken 15 (fallthrough)
branch  1 taken 0
       15:  770:			ind_char = 0;
        -:  771:#ifndef _NO_ICONS
       15:  772:			if (icons) {
       15:  772-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####:  773:				if (xargs.icons_use_file_color == 1)
    %%%%%:  773-block  0
branch  0 never executed
branch  1 never executed
    #####:  774:					file_info[i].icon_color = file_info[i].color;
    %%%%%:  774-block  0
unconditional  0 never executed
        -:  775:
    #####:  776:				if (no_eln) {
    %%%%%:  776-block  0
branch  0 never executed
branch  1 never executed
    #####:  777:					xprintf("%s%s %s%s%s", file_info[i].icon_color,
    #####:  778:					    file_info[i].icon, file_info[i].color,
    #####:  779:					    file_info[i].name, df_c);
    %%%%%:  779-block  0
call    0 never executed
unconditional  1 never executed
        -:  780:				} else {
    #####:  781:					xprintf("%s%d%s %s%s %s%s%s", el_c, i + 1, df_c,
    #####:  782:					    file_info[i].icon_color, file_info[i].icon,
    #####:  783:					    file_info[i].color, file_info[i].name, df_c);
    %%%%%:  783-block  0
call    0 never executed
unconditional  1 never executed
        -:  784:				}
        -:  785:			} else {
       15:  786:				if (no_eln) {
       15:  786-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 15
    #####:  787:					xprintf("%s%s%s", file_info[i].color,
    #####:  788:					    file_info[i].name, df_c);
    %%%%%:  788-block  0
call    0 never executed
unconditional  1 never executed
        -:  789:				} else {
       15:  790:					xprintf("%s%d%s %s%s%s", el_c, i + 1, df_c,
       15:  791:					    file_info[i].color, file_info[i].name, df_c);
       15:  791-block  0
call    0 returned 15
unconditional  1 taken 15
        -:  792:/*					line_sz += (size_t)sprintf(line_buf + line_sz,
        -:  793:						"%s%d%s %s%s%s", el_c, i + 1, df_c,
        -:  794:					    file_info[i].color, file_info[i].name, df_c); */
        -:  795:				}
        -:  796:			}
        -:  797:#else
        -:  798:			if (no_eln) {
        -:  799:				xprintf("%s%s%s", file_info[i].color, file_info[i].name, df_c);
        -:  800:			} else {
        -:  801:				xprintf("%s%d%s %s%s%s", el_c, i + 1, df_c,
        -:  802:				    file_info[i].color, file_info[i].name, df_c);
        -:  803:			}
        -:  804:#endif /* !_NO_ICONS */
        -:  805:
       15:  806:			if (file_info[i].dir && classify) {
       15:  806-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 9
        6:  806-block  1
branch  2 taken 6 (fallthrough)
branch  3 taken 0
        -:  807://				*(line_buf + line_sz++) = '/';
        6:  808:				putchar('/');
        6:  808-block  0
call    0 returned 6
        6:  809:				if (file_info[i].filesn > 0 && files_counter) {
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        5:  809-block  0
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        5:  810:					fputs(xitoa(file_info[i].filesn), stdout);
        5:  810-block  0
call    0 returned 5
call    1 returned 5
unconditional  2 taken 5
        -:  811:/*					char *fc = xitoa(file_info[i].filesn);
        -:  812:					strcat(line_buf + line_sz, xitoa(file_info[i].filesn));
        -:  813:					line_sz += strlen(fc); */
        -:  814:				}
        -:  815:			}
        -:  816:		}
        -:  817:
        -:  818:		/* No color */
        -:  819:		else {
        -:  820:#ifndef _NO_ICONS
    #####:  821:			if (icons) {
    %%%%%:  821-block  0
branch  0 never executed
branch  1 never executed
    #####:  822:				if (no_eln)
    %%%%%:  822-block  0
branch  0 never executed
branch  1 never executed
    #####:  823:					xprintf("%s %s", file_info[i].icon, file_info[i].name);
    %%%%%:  823-block  0
call    0 never executed
unconditional  1 never executed
        -:  824:				else
    #####:  825:					xprintf("%s%d%s %s %s", el_c, i + 1, df_c,
    #####:  826:					    file_info[i].icon, file_info[i].name);
    %%%%%:  826-block  0
call    0 never executed
unconditional  1 never executed
        -:  827:			} else {
    #####:  828:				if (no_eln)
    %%%%%:  828-block  0
branch  0 never executed
branch  1 never executed
    #####:  829:					fputs(file_info[i].name, stdout);
    %%%%%:  829-block  0
call    0 never executed
unconditional  1 never executed
        -:  830:				else
    #####:  831:					xprintf("%s%d%s %s", el_c, i + 1, df_c, file_info[i].name);
    %%%%%:  831-block  0
call    0 never executed
unconditional  1 never executed
        -:  832:			}
        -:  833:#else
        -:  834:			if (no_eln)
        -:  835:				fputs(file_info[i].name, stdout);
        -:  836:			else
        -:  837:				xprintf("%s%d%s %s", el_c, i + 1, df_c, file_info[i].name);
        -:  838:#endif /* !_NO_ICONS */
        -:  839:
    #####:  840:			if (classify) {
    %%%%%:  840-block  0
branch  0 never executed
branch  1 never executed
    #####:  841:				switch (file_info[i].type) {
    %%%%%:  841-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  842:				case DT_DIR:
    #####:  843:					ind_char = 0;
    #####:  844:					putchar('/');
    %%%%%:  844-block  0
call    0 never executed
    #####:  845:					if (file_info[i].filesn > 0 && files_counter)
branch  0 never executed
branch  1 never executed
    %%%%%:  845-block  0
branch  2 never executed
branch  3 never executed
    #####:  846:						fputs(xitoa(file_info[i].filesn), stdout);
    %%%%%:  846-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
    #####:  847:					break;
    %%%%%:  847-block  0
unconditional  0 never executed
        -:  848:
    #####:  849:				case DT_FIFO: putchar('|'); break;
    %%%%%:  849-block  0
call    0 never executed
unconditional  1 never executed
    #####:  850:				case DT_LNK: putchar('@'); break;
    %%%%%:  850-block  0
call    0 never executed
unconditional  1 never executed
    #####:  851:				case DT_SOCK: putchar('='); break;
    %%%%%:  851-block  0
call    0 never executed
unconditional  1 never executed
    #####:  852:				case DT_UNKNOWN: putchar('?'); break;
    %%%%%:  852-block  0
call    0 never executed
unconditional  1 never executed
    #####:  853:				default: ind_char = 0; break;
    %%%%%:  853-block  0
unconditional  0 never executed
        -:  854:				}
        -:  855:			}
        -:  856:		}
        -:  857:
       15:  858:		if (!last_column) {
       15:  858-block  0
branch  0 taken 12 (fallthrough)
branch  1 taken 3
        -:  859:			/* Add spaces needed to equate the longest file name length */
        -:  860:#ifndef _NO_ICONS
      12*:  861:			int cur_len = (int)file_info[i].eln_n + 1 + (icons ? 3 : 0)
       12:  861-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 12
    %%%%%:  861-block  1
unconditional  2 never executed
       12:  861-block  2
unconditional  3 taken 12
        -:  862:#else
        -:  863:			int cur_len = (int)file_info[i].eln_n + 1
        -:  864:#endif
       12:  865:						+ (int)file_info[i].len + (ind_char ? 1 : 0);
       12:  866:			if (classify) {
       12:  866-block  0
branch  0 taken 12 (fallthrough)
branch  1 taken 0
       12:  867:				if (file_info[i].dir)
       12:  867-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 6
        6:  868:					cur_len++;
        6:  868-block  0
unconditional  0 taken 6
       12:  869:				if (file_info[i].filesn > 0 && files_counter
       12:  869-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 7
        5:  869-block  1
branch  2 taken 5 (fallthrough)
branch  3 taken 0
        5:  870:				&& file_info[i].ruser)
        5:  870-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 0
       5*:  871:					cur_len += DIGINUM((int)file_info[i].filesn);
        5:  871-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:  871-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  871-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  871-block  3
branch  6 never executed
branch  7 never executed
    %%%%%:  871-block  4
branch  8 never executed
branch  9 never executed
    %%%%%:  871-block  5
branch 10 never executed
branch 11 never executed
    %%%%%:  871-block  6
branch 12 never executed
branch 13 never executed
    %%%%%:  871-block  7
branch 14 never executed
branch 15 never executed
    %%%%%:  871-block  8
branch 16 never executed
branch 17 never executed
    %%%%%:  871-block  9
unconditional 18 never executed
    %%%%%:  871-block 10
unconditional 19 never executed
    %%%%%:  871-block 11
unconditional 20 never executed
    %%%%%:  871-block 12
unconditional 21 never executed
    %%%%%:  871-block 13
unconditional 22 never executed
    %%%%%:  871-block 14
unconditional 23 never executed
    %%%%%:  871-block 15
unconditional 24 never executed
    %%%%%:  871-block 16
unconditional 25 never executed
    %%%%%:  871-block 17
unconditional 26 never executed
    %%%%%:  871-block 18
unconditional 27 never executed
    %%%%%:  871-block 19
unconditional 28 never executed
    %%%%%:  871-block 20
unconditional 29 never executed
    %%%%%:  871-block 21
unconditional 30 never executed
    %%%%%:  871-block 22
unconditional 31 never executed
    %%%%%:  871-block 23
unconditional 32 never executed
    %%%%%:  871-block 24
unconditional 33 never executed
    %%%%%:  871-block 25
unconditional 34 never executed
        5:  871-block 26
unconditional 35 taken 5
        5:  871-block 27
unconditional 36 taken 5
        -:  872:			}
        -:  873:
       12:  874:			int diff = (int)longest - cur_len;
        -:  875://			xprintf("\x1b[%dC", diff + 1);
        -:  876:			register int j;
       90:  877:			for (j = diff + 1; j--;) {
       12:  877-block  0
unconditional  0 taken 12
       90:  877-block  1
branch  1 taken 78
branch  2 taken 12
       78:  878:				putchar(' ');
       78:  878-block  0
call    0 returned 78
unconditional  1 taken 78
        -:  879://				*(line_buf + line_sz++) = ' '; 
        -:  880:			}
        -:  881:		} else {
        -:  882:/*			*(line_buf + line_sz++) = '\n';
        -:  883:			fputs(line_buf, stdout);
        -:  884:			memset(line_buf, '\0', line_sz);
        -:  885:			line_sz = 0; */
        3:  886:			putchar('\n');
        3:  886-block  0
call    0 returned 3
unconditional  1 taken 3
        -:  887:			
        -:  888:		}
        -:  889:	}
        -:  890:
        3:  891:	if (!last_column)
        3:  891-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        2:  892:		putchar('\n');
        2:  892-block  0
call    0 returned 2
unconditional  1 taken 2
        -:  893:
        -:  894://	free(line_buf);
        -:  895:
        1:  896:END:
        1:  896-block  0
unconditional  0 taken 1
        -:  897:	/* Unhide the cursor */
        3:  898:	fputs("\x1b[?25h", stdout);
        3:  898-block  0
call    0 returned 3
        -:  899:
        3:  900:	if (close_dir && closedir(dir) == -1)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  900-block  0
call    2 returned 3
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    #####:  901:		return EXIT_FAILURE;
    %%%%%:  901-block  0
unconditional  0 never executed
        -:  902:
        3:  903:	if (xargs.list_and_quit == 1)
        3:  903-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  904:		exit(exit_code);
    %%%%%:  904-block  0
call    0 never executed
        -:  905:
        3:  906:	if (reset_pager)
        3:  906-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  907:		pager = 1;
    %%%%%:  907-block  0
unconditional  0 never executed
        -:  908:
       3*:  909:	if (max_files != UNSET && (int)files > max_files)
        3:  909-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:  909-block  1
branch  2 never executed
branch  3 never executed
    #####:  910:		printf("%d/%zu\n", max_files, files);
    %%%%%:  910-block  0
call    0 never executed
unconditional  1 never executed
        -:  911:
        -:  912:	/* Print a dividing line between the files list and the
        -:  913:	 * prompt */
        3:  914:	print_div_line();
        3:  914-block  0
call    0 returned 3
        -:  915:
        3:  916:	if (dirhist_map) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:  917:		/* Print current, previous, and next entries */
    #####:  918:		print_dirhist_map();
    %%%%%:  918-block  0
call    0 never executed
    #####:  919:		print_div_line();
call    0 never executed
unconditional  1 never executed
        -:  920:	}
        -:  921:
        3:  922:	if (disk_usage)
        3:  922-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  923:		print_disk_usage();
    %%%%%:  923-block  0
call    0 never executed
unconditional  1 never executed
        -:  924:
        3:  925:	if (sort_switch)
        3:  925-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  926:		print_sort_method();
    %%%%%:  926-block  0
call    0 never executed
unconditional  1 never executed
        -:  927:
       3*:  928:	if (print_selfiles && sel_n > 0)
        3:  928-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:  928-block  1
branch  2 never executed
branch  3 never executed
    #####:  929:		_print_selfiles(term_rows);
    %%%%%:  929-block  0
call    0 never executed
unconditional  1 never executed
        -:  930:
        -:  931:	/* Unhide the cursor */
        3:  932:	fputs("\x1b[?25h", stdout);
        3:  932-block  0
call    0 returned 3
        -:  933:
        -:  934:#ifdef _LIST_SPEED
        -:  935:	clock_t end = clock();
        -:  936:	printf("list_dir time: %f\n", (double)(end-start)/CLOCKS_PER_SEC);
        -:  937:#endif
        -:  938:
        3:  939:	return EXIT_SUCCESS;
unconditional  0 taken 3
        -:  940:}
        -:  941:
        -:  942:/* List files in the current working directory. Uses file type colors
        -:  943: * and columns. Return zero on success or one on error */
        -:  944:int
function list_dir called 305 returned 100% blocks executed 69%
      305:  945:list_dir(void)
        -:  946:{
        -:  947:#ifdef _LIST_SPEED
        -:  948:	clock_t start = clock();
        -:  949:#endif
      305:  950:	if (clear_screen)
      305:  950-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 299
        6:  951:		CLEAR;
        6:  951-block  0
call    0 returned 6
unconditional  1 taken 6
        -:  952:
      305:  953:	if (light_mode)
      305:  953-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 302
        3:  954:		return list_dir_light();
        3:  954-block  0
call    0 returned 3
unconditional  1 taken 3
        -:  955:
        -:  956:	/* Hide the cursor while listing */
      302:  957:	fputs("\x1b[?25l", stdout);
      302:  957-block  0
call    0 returned 302
        -:  958:
        -:  959:	DIR *dir;
        -:  960:	struct dirent *ent;
        -:  961:	struct stat attr;
      302:  962:	int reset_pager = 0;
      302:  963:	int close_dir = 1;
        -:  964:	/* Get terminal current amount of rows and columns */
        -:  965:	struct winsize w;
      302:  966:	ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
call    0 returned 302
        -:  967:	/* These two are global */
      302:  968:	term_cols = w.ws_col;
      302:  969:	term_rows = w.ws_row;
        -:  970:
      302:  971:	if ((dir = opendir(ws[cur_ws].path)) == NULL) {
call    0 returned 302
branch  1 taken 0 (fallthrough)
branch  2 taken 302
    #####:  972:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, ws[cur_ws].path,
call    0 never executed
    #####:  973:		    strerror(errno));
    %%%%%:  973-block  0
call    0 never executed
    #####:  974:		close_dir = 0;
    #####:  975:		goto END;
unconditional  0 never executed
        -:  976:	}
        -:  977:
        -:  978:#ifdef LINUX_INOTIFY
      302:  979:	if (inotify_wd >= 0) {
      302:  979-block  0
branch  0 taken 298 (fallthrough)
branch  1 taken 4
      298:  980:		inotify_rm_watch(inotify_fd, inotify_wd);
      298:  980-block  0
call    0 returned 298
      298:  981:		inotify_wd = -1;
      298:  982:		watch = 0;
unconditional  0 taken 298
        -:  983:	}
      302:  984:	inotify_wd = inotify_add_watch(inotify_fd, ws[cur_ws].path, INOTIFY_MASK);
      302:  984-block  0
call    0 returned 302
      302:  985:	if (inotify_wd > 0)
branch  0 taken 302 (fallthrough)
branch  1 taken 0
      302:  986:		watch = 1;
      302:  986-block  0
unconditional  0 taken 302
        -:  987:
        -:  988:#elif defined(BSD_KQUEUE)
        -:  989:	if (event_fd >= 0) {
        -:  990:		close(event_fd);
        -:  991:		event_fd = -1;
        -:  992:		watch = 0;
        -:  993:	}
        -:  994:#if defined(O_EVTONLY)
        -:  995:	event_fd = open(ws[cur_ws].path, O_EVTONLY);
        -:  996:#else
        -:  997:	event_fd = open(ws[cur_ws].path, O_RDONLY);
        -:  998:#endif
        -:  999:	if (event_fd >= 0) {
        -: 1000:		/* Prepare for events */
        -: 1001:		EV_SET(&events_to_monitor[0], event_fd, EVFILT_VNODE,
        -: 1002:				EV_ADD | EV_CLEAR, KQUEUE_FFLAGS, 0, ws[cur_ws].path);
        -: 1003:		watch = 1;
        -: 1004:		/* Register events */
        -: 1005:		kevent(kq, events_to_monitor, NUM_EVENT_SLOTS,
        -: 1006:				NULL, 0, NULL);
        -: 1007:
        -: 1008:	}
        -: 1009:#endif /* LINUX_INOTIFY */
        -: 1010:
      302: 1011:	int fd = dirfd(dir);
      302: 1011-block  0
call    0 returned 302
        -: 1012:
        -: 1013:		/* ##########################################
        -: 1014:		 * #    GATHER AND STORE FILE INFORMATION   #
        -: 1015:		 * ########################################## */
        -: 1016:
      302: 1017:	errno = 0;
      302: 1018:	longest = 0;
      302: 1019:	register unsigned int n = 0;
      302: 1020:	unsigned int total_dents = 0, count = 0;
        -: 1021:
      302: 1022:	file_info = (struct fileinfo *)xnmalloc(ENTRY_N + 2,
call    0 returned 302
        -: 1023:	    sizeof(struct fileinfo));
        -: 1024:
    41077: 1025:	while ((ent = readdir(dir))) {
unconditional  0 taken 302
    41077: 1025-block  0
call    1 returned 41077
branch  2 taken 40775
branch  3 taken 302 (fallthrough)
    40775: 1026:		char *ename = ent->d_name;
        -: 1027:		/* Skip self and parent directories */
    40775: 1028:		if (*ename == '.' && (!ename[1] || (ename[1] == '.' && !ename[2])))
    40775: 1028-block  0
branch  0 taken 3156 (fallthrough)
branch  1 taken 37619
     3156: 1028-block  1
branch  2 taken 2854 (fallthrough)
branch  3 taken 302
     2854: 1028-block  2
branch  4 taken 302 (fallthrough)
branch  5 taken 2552
      302: 1028-block  3
branch  6 taken 302 (fallthrough)
branch  7 taken 0
      604: 1029:			continue;
      604: 1029-block  0
unconditional  0 taken 604
        -: 1030:
        -: 1031:		/* Filter files according to FILTER */
    40171: 1032:		if (filter) {
    40171: 1032-block  0
branch  0 taken 28 (fallthrough)
branch  1 taken 40143
       28: 1033:			if (regexec(&regex_exp, ename, 0, NULL, 0) == EXIT_SUCCESS) {
       28: 1033-block  0
call    0 returned 28
branch  1 taken 16 (fallthrough)
branch  2 taken 12
       16: 1034:				if (filter_rev)
       16: 1034-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 14
        2: 1035:					continue;
        2: 1035-block  0
unconditional  0 taken 2
       12: 1036:			} else if (!filter_rev) {
       12: 1036-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 5
        7: 1037:				continue;
        7: 1037-block  0
unconditional  0 taken 7
        -: 1038:			}
        -: 1039:		}
        -: 1040:
    40162: 1041:		if (!show_hidden && *ename == '.')
    40162: 1041-block  0
branch  0 taken 154 (fallthrough)
branch  1 taken 40008
      154: 1041-block  1
branch  2 taken 96 (fallthrough)
branch  3 taken 58
       96: 1042:			continue;
       96: 1042-block  0
unconditional  0 taken 96
        -: 1043:
    40066: 1044:		fstatat(fd, ename, &attr, AT_SYMLINK_NOFOLLOW);
    40066: 1044-block  0
call    0 returned 40066
        -: 1045:
        -: 1046:#if !defined(_DIRENT_HAVE_D_TYPE)
        -: 1047:		if (only_dirs && (attr.st_mode & S_IFMT) == S_IFDIR)
        -: 1048:#else
   40066*: 1049:		if (only_dirs && ent->d_type != DT_DIR)
branch  0 taken 0 (fallthrough)
branch  1 taken 40066
    %%%%%: 1049-block  0
branch  2 never executed
branch  3 never executed
        -: 1050:#endif
    #####: 1051:			continue;
    %%%%%: 1051-block  0
unconditional  0 never executed
        -: 1052:
    40066: 1053:		if (count > ENTRY_N) {
    40066: 1053-block  0
branch  0 taken 524 (fallthrough)
branch  1 taken 39542
      524: 1054:			count = 0;
      524: 1055:			total_dents = n + ENTRY_N;
      524: 1056:			file_info = xrealloc(file_info, (total_dents + 2) * sizeof(struct fileinfo));
      524: 1056-block  0
call    0 returned 524
unconditional  1 taken 524
        -: 1057:		}
        -: 1058:
    40066: 1059:		file_info[n].name = (char *)xnmalloc(NAME_MAX + 1, sizeof(char));
    40066: 1059-block  0
call    0 returned 40066
        -: 1060:
    40066: 1061:		if (!unicode) {
branch  0 taken 70 (fallthrough)
branch  1 taken 39996
       70: 1062:			file_info[n].len = xstrsncpy(file_info[n].name, ename, NAME_MAX);
       70: 1062-block  0
call    0 returned 70
unconditional  1 taken 70
        -: 1063:		} else {
    39996: 1064:			xstrsncpy(file_info[n].name, ename, NAME_MAX);
    39996: 1064-block  0
call    0 returned 39996
    39996: 1065:			file_info[n].len = wc_xstrlen(ename);
call    0 returned 39996
unconditional  1 taken 39996
        -: 1066:		}
        -: 1067:
    40066: 1068:		file_info[n].exec = 0;
        -: 1069:
        -: 1070:#if !defined(_DIRENT_HAVE_D_TYPE)
        -: 1071:		switch (attr.st_mode & S_IFMT) {
        -: 1072:		case S_IFBLK: file_info[n].type = DT_BLK; break;
        -: 1073:		case S_IFCHR: file_info[n].type = DT_CHR; break;
        -: 1074:		case S_IFDIR: file_info[n].type = DT_DIR; break;
        -: 1075:		case S_IFIFO: file_info[n].type = DT_FIFO; break;
        -: 1076:		case S_IFLNK: file_info[n].type = DT_LNK; break;
        -: 1077:		case S_IFREG: file_info[n].type = DT_REG; break;
        -: 1078:		case S_IFSOCK: file_info[n].type = DT_SOCK; break;
        -: 1079:		default: file_info[n].type = DT_UNKNOWN; break;
        -: 1080:		}
        -: 1081:		file_info[n].dir = (file_info[n].type == DT_DIR) ? 1 : 0;
        -: 1082:		file_info[n].symlink = (file_info[n].type == DT_LNK) ? 1 : 0;
        -: 1083:#else
    40066: 1084:		file_info[n].dir = (ent->d_type == DT_DIR) ? 1 : 0;
    40066: 1085:		file_info[n].symlink = (ent->d_type == DT_LNK) ? 1 : 0;
    40066: 1086:		file_info[n].type = ent->d_type;
        -: 1087:#endif /* _DIRENT_HAVE_D_TYPE */
        -: 1088:
    40066: 1089:		file_info[n].inode = ent->d_ino;
    40066: 1090:		file_info[n].linkn = attr.st_nlink;
    40066: 1091:		file_info[n].size = attr.st_size;
        -: 1092:
    40066: 1093:		file_info[n].uid = attr.st_uid;
    40066: 1094:		file_info[n].gid = attr.st_gid;
    40066: 1095:		file_info[n].mode = attr.st_mode;
    40066: 1096:		if (long_view)
    40066: 1096-block  0
branch  0 taken 214 (fallthrough)
branch  1 taken 39852
      214: 1097:			file_info[n].ltime = (time_t)attr.st_mtim.tv_sec;
      214: 1097-block  0
unconditional  0 taken 214
        -: 1098:
        -: 1099:/*		if (long_view) {
        -: 1100:			file_info[n].uid = attr.st_uid;
        -: 1101:			file_info[n].gid = attr.st_gid;
        -: 1102:			file_info[n].ltime = (time_t)attr.st_mtim.tv_sec;
        -: 1103:			file_info[n].mode = attr.st_mode;
        -: 1104:		} else if (sort == SOWN || sort == SGRP) {
        -: 1105:			file_info[n].uid = attr.st_uid;
        -: 1106:			file_info[n].gid = attr.st_gid;
        -: 1107:		} */
        -: 1108:
    40066: 1109:		file_info[n].color = (char *)NULL;
    40066: 1110:		file_info[n].ext_color = (char *)NULL;
        -: 1111:
        -: 1112:#ifndef _NO_ICONS
        -: 1113:		/* Default icon for all files */
    40066: 1114:		file_info[n].icon = DEF_FILE_ICON;
    40066: 1115:		file_info[n].icon_color = DEF_FILE_ICON_COLOR;
        -: 1116:#endif
        -: 1117:
    40066: 1118:		file_info[n].ruser = 1;
    40066: 1119:		file_info[n].filesn = 0;
        -: 1120:
    40066: 1121:		switch (sort) {
    40066: 1121-block  0
branch  0 taken 60
branch  1 taken 60
branch  2 taken 60
branch  3 taken 60
branch  4 taken 39826
       60: 1122:		case SATIME:
       60: 1123:			file_info[n].time = (time_t)attr.st_atime;
       60: 1124:			break;
       60: 1124-block  0
unconditional  0 taken 60
        -: 1125:#if defined(HAVE_ST_BIRTHTIME) || defined(__BSD_VISIBLE)
        -: 1126:		case SBTIME:
        -: 1127:#ifdef __OpenBSD__
        -: 1128:			file_info[n].time = (time_t)attr.__st_birthtim.tv_sec;
        -: 1129:#else
        -: 1130:			file_info[n].time = (time_t)attr.st_birthtime;
        -: 1131:#endif /* HAVE_ST_BIRTHTIME || __BSD_VISIBLE */
        -: 1132:			break;
        -: 1133:#elif defined(_STATX)
       60: 1134:		case SBTIME: {
        -: 1135:			struct statx attx;
       60: 1136:			if (statx(AT_FDCWD, ename, AT_SYMLINK_NOFOLLOW,
       60: 1136-block  0
call    0 returned 60
branch  1 taken 0 (fallthrough)
branch  2 taken 60
        -: 1137:			STATX_BTIME, &attx) == -1)
    #####: 1138:				file_info[n].time = 0;
    %%%%%: 1138-block  0
unconditional  0 never executed
        -: 1139:			else
       60: 1140:				file_info[n].time = (time_t)attx.stx_btime.tv_sec;
       60: 1140-block  0
unconditional  0 taken 60
       60: 1141:		} break;
       60: 1141-block  0
unconditional  0 taken 60
        -: 1142:#else
        -: 1143:		case SBTIME: file_info[n].time = (time_t)attr.st_ctime; break;
        -: 1144:#endif /* _STATX */
       60: 1145:		case SCTIME: file_info[n].time = (time_t)attr.st_ctime;	break;
       60: 1145-block  0
unconditional  0 taken 60
       60: 1146:		case SMTIME: file_info[n].time = (time_t)attr.st_mtime; break;
       60: 1146-block  0
unconditional  0 taken 60
    39826: 1147:		default: file_info[n].time = 0; break;
    39826: 1147-block  0
unconditional  0 taken 39826
        -: 1148:		}
        -: 1149:
    40066: 1150:		switch (file_info[n].type) {
    40066: 1150-block  0
branch  0 taken 2804
branch  1 taken 4033
branch  2 taken 33187
branch  3 taken 1
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 41
branch  8 taken 0
        -: 1151:
     2804: 1152:		case DT_DIR:
        -: 1153:#ifndef _NO_ICONS
     2804: 1154:			if (icons) {
     2804: 1154-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 2801
        3: 1155:				get_dir_icon(file_info[n].name, (int)n);
        3: 1155-block  0
call    0 returned 3
        -: 1156:
        -: 1157:				/* If set from the color scheme file */
        3: 1158:				if (*dir_ico_c)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 1159:					file_info[n].icon_color = dir_ico_c;
        3: 1159-block  0
unconditional  0 taken 3
        -: 1160:			}
        -: 1161:#endif /* _NO_ICONS */
     2804: 1162:			if (files_counter) {
     2804: 1162-block  0
branch  0 taken 2801 (fallthrough)
branch  1 taken 3
     2801: 1163:				file_info[n].filesn = count_dir(ename, NO_CPOP) - 2;
     2801: 1163-block  0
call    0 returned 2801
unconditional  1 taken 2801
        -: 1164:			} else {
        3: 1165:				if (check_file_access(file_info[n]) == 0)
        3: 1165-block  0
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    #####: 1166:					file_info[n].filesn = -1;
    %%%%%: 1166-block  0
unconditional  0 never executed
        -: 1167:				else
        3: 1168:					file_info[n].filesn = 1;
        3: 1168-block  0
unconditional  0 taken 3
        -: 1169:			}
     2804: 1170:			if (file_info[n].filesn > 0) { /* S_ISVTX*/
     2804: 1170-block  0
branch  0 taken 2568 (fallthrough)
branch  1 taken 236
     2568: 1171:				file_info[n].color = (attr.st_mode & 01000)
     2568: 1171-block  0
unconditional  0 taken 2568
       1*: 1172:							 ? ((attr.st_mode & 00002) ? tw_c : st_c)
        1: 1172-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1172-block  1
unconditional  2 taken 1
    %%%%%: 1172-block  2
unconditional  3 never executed
    2569*: 1173:							 : ((attr.st_mode & 00002) ? ow_c : di_c);
     2568: 1173-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2567
        1: 1173-block  1
unconditional  2 taken 1
     2567: 1173-block  2
branch  3 taken 0 (fallthrough)
branch  4 taken 2567
    %%%%%: 1173-block  3
unconditional  5 never executed
     2567: 1173-block  4
unconditional  6 taken 2567
     2567: 1173-block  5
unconditional  7 taken 2567
        -: 1174:				/* S_ISWOTH*/
      236: 1175:			} else if (file_info[n].filesn == 0) {
      236: 1175-block  0
branch  0 taken 226 (fallthrough)
branch  1 taken 10
      226: 1176:				file_info[n].color = (attr.st_mode & 01000)
      226: 1176-block  0
unconditional  0 taken 226
       1*: 1177:							 ? ((attr.st_mode & 00002) ? tw_c : st_c)
        1: 1177-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1177-block  1
unconditional  2 taken 1
    %%%%%: 1177-block  2
unconditional  3 never executed
     227*: 1178:							 : ((attr.st_mode & 00002) ? ow_c : ed_c);
      226: 1178-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 225
        1: 1178-block  1
unconditional  2 taken 1
      225: 1178-block  2
branch  3 taken 0 (fallthrough)
branch  4 taken 225
    %%%%%: 1178-block  3
unconditional  5 never executed
      225: 1178-block  4
unconditional  6 taken 225
      225: 1178-block  5
unconditional  7 taken 225
        -: 1179:			} else {
       10: 1180:				file_info[n].color = nd_c;
        -: 1181:#ifndef _NO_ICONS
       10: 1182:				file_info[n].icon = ICON_LOCK;
       10: 1183:				file_info[n].icon_color = YELLOW;
       10: 1183-block  0
unconditional  0 taken 10
        -: 1184:#endif
        -: 1185:			}
        -: 1186:
     2804: 1187:			break;
     2804: 1187-block  0
unconditional  0 taken 2804
        -: 1188:
     4033: 1189:		case DT_LNK: {
        -: 1190:#ifndef _NO_ICONS
     4033: 1191:			file_info[n].icon = ICON_LINK;
        -: 1192:#endif
     4033: 1193:			if (!follow_symlinks) {
     4033: 1193-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4033
    #####: 1194:				file_info[n].color = ln_c;
    #####: 1195:				break;
    %%%%%: 1195-block  0
unconditional  0 never executed
        -: 1196:			}
        -: 1197:			struct stat attrl;
     4033: 1198:			if (fstatat(fd, ename, &attrl, 0) == -1) {
     4033: 1198-block  0
call    0 returned 4033
branch  1 taken 54 (fallthrough)
branch  2 taken 3979
       54: 1199:				file_info[n].color = or_c;
       54: 1199-block  0
unconditional  0 taken 54
        -: 1200:			} else {
     3979: 1201:				if (S_ISDIR(attrl.st_mode)) {
     3979: 1201-block  0
branch  0 taken 61 (fallthrough)
branch  1 taken 3918
       61: 1202:					file_info[n].dir = 1;
        -: 1203:					files_counter
       61: 1204:					    ? (file_info[n].filesn = (count_dir(ename, NO_CPOP) - 2))
       61: 1204-block  0
call    0 returned 61
     122*: 1205:					    : (file_info[n].filesn = 0);
       61: 1205-block  0
branch  0 taken 61 (fallthrough)
branch  1 taken 0
unconditional  2 taken 61
    %%%%%: 1205-block  1
unconditional  3 never executed
        -: 1206:				}
     3979: 1207:				file_info[n].color = ln_c;
     3979: 1207-block  0
unconditional  0 taken 3979
        -: 1208:			}
        -: 1209:			}
     4033: 1210:			break;
     4033: 1210-block  0
unconditional  0 taken 4033
        -: 1211:
    33187: 1212:		case DT_REG: {
        -: 1213:#ifdef _LINUX_CAP
        -: 1214:			cap_t cap;
        -: 1215:#endif
        -: 1216:			/* Do not perform the access check if the user is root */
    33187: 1217:			if (!(flags & ROOT_USR)
    33187: 1217-block  0
branch  0 taken 33185 (fallthrough)
branch  1 taken 2
    33185: 1218:			&& check_file_access(file_info[n]) == 0) {
    33185: 1218-block  0
call    0 returned 33185
branch  1 taken 18 (fallthrough)
branch  2 taken 33167
        -: 1219:#ifndef _NO_ICONS
       18: 1220:				file_info[n].icon = ICON_LOCK;
       18: 1221:				file_info[n].icon_color = YELLOW;
        -: 1222:#endif
       18: 1223:				file_info[n].color = nf_c;
       18: 1223-block  0
unconditional  0 taken 18
    33169: 1224:			} else if (attr.st_mode & 04000) { /* SUID */
    33169: 1224-block  0
branch  0 taken 210 (fallthrough)
branch  1 taken 32959
      210: 1225:				file_info[n].exec = 1;
      210: 1226:				file_info[n].color = su_c;
        -: 1227:#ifndef _NO_ICONS
      210: 1228:				file_info[n].icon = ICON_EXEC;
      210: 1228-block  0
unconditional  0 taken 210
        -: 1229:#endif
    32959: 1230:			} else if (attr.st_mode & 02000) { /* SGID */
    32959: 1230-block  0
branch  0 taken 18 (fallthrough)
branch  1 taken 32941
       18: 1231:				file_info[n].exec = 1;
       18: 1232:				file_info[n].color = sg_c;
        -: 1233:#ifndef _NO_ICONS
       18: 1234:				file_info[n].icon = ICON_EXEC;
       18: 1234-block  0
unconditional  0 taken 18
        -: 1235:#endif
        -: 1236:			}
        -: 1237:
        -: 1238:#ifdef _LINUX_CAP
    32941: 1239:			else if (check_cap && (cap = cap_get_file(ename))) {
    32941: 1239-block  0
branch  0 taken 32941 (fallthrough)
branch  1 taken 0
    32941: 1239-block  1
call    2 returned 32941
branch  3 taken 45 (fallthrough)
branch  4 taken 32896
       45: 1240:				file_info[n].color = ca_c;
       45: 1241:				cap_free(cap);
       45: 1241-block  0
call    0 returned 45
unconditional  1 taken 45
        -: 1242:			}
        -: 1243:#endif
        -: 1244:
    32896: 1245:			else if ((attr.st_mode & 00100) /* Exec */
    32896: 1245-block  0
branch  0 taken 4906 (fallthrough)
branch  1 taken 27990
     4906: 1246:			|| (attr.st_mode & 00010) || (attr.st_mode & 00001)) {
     4906: 1246-block  0
branch  0 taken 4906 (fallthrough)
branch  1 taken 0
     4906: 1246-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 4906
    27990: 1247:				file_info[n].exec = 1;
        -: 1248:#ifndef _NO_ICONS
    27990: 1249:				file_info[n].icon = ICON_EXEC;
        -: 1250:#endif
    27990: 1251:				if (file_info[n].size == 0)
    27990: 1251-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 27989
        1: 1252:					file_info[n].color = ee_c;
        1: 1252-block  0
unconditional  0 taken 1
        -: 1253:				else
    27989: 1254:					file_info[n].color = ex_c;
    27989: 1254-block  0
unconditional  0 taken 27989
     4906: 1255:			} else if (file_info[n].size == 0) {
     4906: 1255-block  0
branch  0 taken 428 (fallthrough)
branch  1 taken 4478
      428: 1256:				file_info[n].color = ef_c;
      428: 1256-block  0
unconditional  0 taken 428
     4478: 1257:			} else if (file_info[n].linkn > 1) { /* Multi-hardlink */
     4478: 1257-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4478
    #####: 1258:				file_info[n].color = mh_c;
    %%%%%: 1258-block  0
unconditional  0 never executed
        -: 1259:			} else { /* Regular file */
     4478: 1260:				file_info[n].color = fi_c;
     4478: 1260-block  0
unconditional  0 taken 4478
        -: 1261:			}
        -: 1262:
        -: 1263:			/* Check file extension */
    33187: 1264:			char *ext = (char *)NULL;
    33187: 1265:			if (check_ext)
    33187: 1265-block  0
branch  0 taken 33187 (fallthrough)
branch  1 taken 0
    33187: 1266:				ext = strrchr(file_info[n].name, '.');
    33187: 1266-block  0
unconditional  0 taken 33187
        -: 1267:			/* Make sure not to take a hidden file for a file extension */
    33187: 1268:			if (ext && ext != file_info[n].name) {
    33187: 1268-block  0
branch  0 taken 4642 (fallthrough)
branch  1 taken 28545
     4642: 1268-block  1
branch  2 taken 3822 (fallthrough)
branch  3 taken 820
        -: 1269:#ifndef _NO_ICONS
     3822: 1270:				if (icons)
     3822: 1270-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 3820
        2: 1271:					get_ext_icon(ext, (int)n);
        2: 1271-block  0
call    0 returned 2
unconditional  1 taken 2
        -: 1272:#endif
        -: 1273:				/* Check extension color only if some is defined */
     3822: 1274:				if (ext_colors_n) {
     3822: 1274-block  0
branch  0 taken 3818 (fallthrough)
branch  1 taken 4
     3818: 1275:					char *extcolor = get_ext_color(ext);
     3818: 1275-block  0
call    0 returned 3818
        -: 1276:
     3818: 1277:					if (extcolor) {
branch  0 taken 486 (fallthrough)
branch  1 taken 3332
      972: 1278:						file_info[n].ext_color = (char *)xnmalloc(
      486: 1279:									strlen(extcolor) + 4, sizeof(char));
      486: 1279-block  0
call    0 returned 486
      486: 1280:						sprintf(file_info[n].ext_color, "\x1b[%sm",
        -: 1281:								extcolor);
      486: 1282:						file_info[n].color = file_info[n].ext_color;
      486: 1283:						extcolor = (char *)NULL;
unconditional  0 taken 486
        -: 1284:					}
        -: 1285:				}
        -: 1286:			}
        -: 1287:
        -: 1288:#ifndef _NO_ICONS
        -: 1289:			/* No extension. Check icons for specific file names */
    29365: 1290:			else if (icons)
    29365: 1290-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 29364
        1: 1291:				get_file_icon(file_info[n].name, (int)n);
        1: 1291-block  0
call    0 returned 1
unconditional  1 taken 1
        -: 1292:#endif
        -: 1293:
        -: 1294:		} /* End of DT_REG block */
    33187: 1295:		break;
    33187: 1295-block  0
unconditional  0 taken 33187
        -: 1296:
        1: 1297:		case DT_SOCK: file_info[n].color = so_c; break;
        1: 1297-block  0
unconditional  0 taken 1
    #####: 1298:		case DT_FIFO: file_info[n].color = pi_c; break;
    %%%%%: 1298-block  0
unconditional  0 never executed
    #####: 1299:		case DT_BLK: file_info[n].color = bd_c; break;
    %%%%%: 1299-block  0
unconditional  0 never executed
    #####: 1300:		case DT_CHR: file_info[n].color = cd_c; break;
    %%%%%: 1300-block  0
unconditional  0 never executed
       41: 1301:		case DT_UNKNOWN: file_info[n].color = uf_c; break;
       41: 1301-block  0
unconditional  0 taken 41
    #####: 1302:		default: file_info[n].color = df_c; break;
    %%%%%: 1302-block  0
unconditional  0 never executed
        -: 1303:		}
        -: 1304:
        -: 1305:#ifndef _NO_ICONS
   40066*: 1306:		if (xargs.icons_use_file_color == 1 && icons)
    40066: 1306-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 40066
    %%%%%: 1306-block  1
branch  2 never executed
branch  3 never executed
    #####: 1307:			file_info[n].icon_color = file_info[n].color;
    %%%%%: 1307-block  0
unconditional  0 never executed
        -: 1308:#endif
        -: 1309:
    40066: 1310:		n++;
    40066: 1311:		count++;
    40066: 1311-block  0
unconditional  0 taken 40066
        -: 1312:	}
        -: 1313:
      302: 1314:	file_info[n].name = (char *)NULL;
      302: 1315:	files = n;
        -: 1316:
      302: 1317:	if (n == 0) {
      302: 1317-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 298
       4*: 1318:		printf("%s. ..%s\n", colorize ? di_c : df_c, df_c);
        4: 1318-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 1318-block  1
unconditional  2 taken 4
    %%%%%: 1318-block  2
unconditional  3 never executed
        4: 1318-block  3
call    4 returned 4
        4: 1319:		free(file_info);
        4: 1320:		goto END;
unconditional  0 taken 4
        -: 1321:	}
        -: 1322:
        -: 1323:		/* #############################################
        -: 1324:		 * #    SORT FILES ACCORDING TO SORT METHOD    #
        -: 1325:		 * ############################################# */
        -: 1326:
      298: 1327:	if (sort)
      298: 1327-block  0
branch  0 taken 296 (fallthrough)
branch  1 taken 2
      296: 1328:		ENTSORT(file_info, n, entrycmp);
      296: 1328-block  0
call    0 returned 296
unconditional  1 taken 296
        -: 1329:
        -: 1330:		/* ##########################################
        -: 1331:		 * #    GET INFO TO PRINT COLUMNED OUTPUT   #
        -: 1332:		 * ########################################## */
        -: 1333:
        -: 1334:	int i;
      298: 1335:	register size_t counter = 0;
      298: 1336:	size_t columns_n = 1;
        -: 1337:
        -: 1338:	/* Get the longest file name */
      298: 1339:	if (columned || long_view) {
      298: 1339-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 297
        1: 1339-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
      297: 1340:		i = (int)n;
    40356: 1341:		while (--i >= 0) {
      297: 1341-block  0
unconditional  0 taken 297
    40356: 1341-block  1
branch  1 taken 40059
branch  2 taken 297 (fallthrough)
    40059: 1342:			size_t total_len = 0;
   40059*: 1343:			file_info[i].eln_n = no_eln ? -1 : DIGINUM(i + 1);
    40059: 1343-block  0
branch  0 taken 40059 (fallthrough)
branch  1 taken 0
    40059: 1343-block  1
branch  2 taken 38106 (fallthrough)
branch  3 taken 1953
    38106: 1343-block  2
branch  4 taken 32352 (fallthrough)
branch  5 taken 5754
    32352: 1343-block  3
branch  6 taken 23040 (fallthrough)
branch  7 taken 9312
    23040: 1343-block  4
branch  8 taken 0 (fallthrough)
branch  9 taken 23040
    %%%%%: 1343-block  5
branch 10 never executed
branch 11 never executed
    %%%%%: 1343-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1343-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1343-block  8
branch 16 never executed
branch 17 never executed
    %%%%%: 1343-block  9
branch 18 never executed
branch 19 never executed
    %%%%%: 1343-block 10
unconditional 20 never executed
    %%%%%: 1343-block 11
unconditional 21 never executed
    %%%%%: 1343-block 12
unconditional 22 never executed
    %%%%%: 1343-block 13
unconditional 23 never executed
    %%%%%: 1343-block 14
unconditional 24 never executed
    %%%%%: 1343-block 15
unconditional 25 never executed
    %%%%%: 1343-block 16
unconditional 26 never executed
    %%%%%: 1343-block 17
unconditional 27 never executed
    %%%%%: 1343-block 18
unconditional 28 never executed
    %%%%%: 1343-block 19
unconditional 29 never executed
    %%%%%: 1343-block 20
unconditional 30 never executed
    23040: 1343-block 21
unconditional 31 taken 23040
    23040: 1343-block 22
unconditional 32 taken 23040
     9312: 1343-block 23
unconditional 33 taken 9312
    32352: 1343-block 24
unconditional 34 taken 32352
     5754: 1343-block 25
unconditional 35 taken 5754
    38106: 1343-block 26
unconditional 36 taken 38106
     1953: 1343-block 27
unconditional 37 taken 1953
    40059: 1343-block 28
unconditional 38 taken 40059
    %%%%%: 1343-block 29
unconditional 39 never executed
    40059: 1344:			total_len = (size_t)file_info[i].eln_n + 1 + file_info[i].len;
        -: 1345:
    40059: 1346:			if (!long_view && classify) {
    40059: 1346-block  0
branch  0 taken 39845 (fallthrough)
branch  1 taken 214
    39845: 1346-block  1
branch  2 taken 39845 (fallthrough)
branch  3 taken 0
    39845: 1347:				if (file_info[i].dir)
    39845: 1347-block  0
branch  0 taken 2763 (fallthrough)
branch  1 taken 37082
     2763: 1348:					total_len++;
     2763: 1348-block  0
unconditional  0 taken 2763
        -: 1349:
    39845: 1350:				if (file_info[i].filesn > 0 && files_counter)
    39845: 1350-block  0
branch  0 taken 2532 (fallthrough)
branch  1 taken 37313
     2532: 1350-block  1
branch  2 taken 2529 (fallthrough)
branch  3 taken 3
    2529*: 1351:					total_len += DIGINUM(file_info[i].filesn);
     2529: 1351-block  0
branch  0 taken 766 (fallthrough)
branch  1 taken 1763
      766: 1351-block  1
branch  2 taken 123 (fallthrough)
branch  3 taken 643
      123: 1351-block  2
branch  4 taken 7 (fallthrough)
branch  5 taken 116
        7: 1351-block  3
branch  6 taken 1 (fallthrough)
branch  7 taken 6
        1: 1351-block  4
branch  8 taken 1 (fallthrough)
branch  9 taken 0
        1: 1351-block  5
branch 10 taken 0 (fallthrough)
branch 11 taken 1
    %%%%%: 1351-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1351-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1351-block  8
branch 16 never executed
branch 17 never executed
    %%%%%: 1351-block  9
unconditional 18 never executed
    %%%%%: 1351-block 10
unconditional 19 never executed
    %%%%%: 1351-block 11
unconditional 20 never executed
    %%%%%: 1351-block 12
unconditional 21 never executed
    %%%%%: 1351-block 13
unconditional 22 never executed
    %%%%%: 1351-block 14
unconditional 23 never executed
    %%%%%: 1351-block 15
unconditional 24 never executed
        1: 1351-block 16
unconditional 25 taken 1
        1: 1351-block 17
unconditional 26 taken 1
    %%%%%: 1351-block 18
unconditional 27 never executed
        1: 1351-block 19
unconditional 28 taken 1
        6: 1351-block 20
unconditional 29 taken 6
        7: 1351-block 21
unconditional 30 taken 7
      116: 1351-block 22
unconditional 31 taken 116
      123: 1351-block 23
unconditional 32 taken 123
      643: 1351-block 24
unconditional 33 taken 643
      766: 1351-block 25
unconditional 34 taken 766
     1763: 1351-block 26
unconditional 35 taken 1763
     2529: 1351-block 27
unconditional 36 taken 2529
        -: 1352:
    39845: 1353:				if (!file_info[i].dir && !colorize) {
    39845: 1353-block  0
branch  0 taken 37082 (fallthrough)
branch  1 taken 2763
    37082: 1353-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 37082
    #####: 1354:					switch (file_info[i].type) {
    %%%%%: 1354-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1355:					case DT_REG:
    #####: 1356:						if (file_info[i].exec)
    %%%%%: 1356-block  0
branch  0 never executed
branch  1 never executed
    #####: 1357:							total_len++;
    %%%%%: 1357-block  0
unconditional  0 never executed
    #####: 1358:						break;
    %%%%%: 1358-block  0
unconditional  0 never executed
    #####: 1359:					case DT_LNK:  /* fallthrough */
        -: 1360:					case DT_SOCK: /* fallthrough */
        -: 1361:					case DT_FIFO: /* fallthrough */
    #####: 1362:					case DT_UNKNOWN: total_len += 1; break;
    %%%%%: 1362-block  0
unconditional  0 never executed
        -: 1363:					}
        -: 1364:				}
        -: 1365:			}
        -: 1366:
    40059: 1367:			if (total_len > longest) {
    40059: 1367-block  0
branch  0 taken 4410 (fallthrough)
branch  1 taken 35649
     4410: 1368:				if (max_files == UNSET)
     4410: 1368-block  0
branch  0 taken 948 (fallthrough)
branch  1 taken 3462
      948: 1369:					longest = total_len;
      948: 1369-block  0
unconditional  0 taken 948
        -: 1370:				/* If MAX_FILES is set, get longest file name from
        -: 1371:				 * the first MAX_FILES file names */
     3462: 1372:				else if (i < max_files)
     3462: 1372-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 3459
        3: 1373:					longest = total_len;
        3: 1373-block  0
unconditional  0 taken 3
        -: 1374:			}
        -: 1375:		}
        -: 1376:
        -: 1377:#ifndef _NO_ICONS
      297: 1378:		if (icons && !long_view && columned)
      297: 1378-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 296
        1: 1378-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 1378-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1: 1379:			longest += 3;
        1: 1379-block  0
unconditional  0 taken 1
        -: 1380:#endif
        -: 1381:	}
        -: 1382:
        -: 1383:				/* ########################
        -: 1384:				 * #    LONG VIEW MODE    #
        -: 1385:				 * ######################## */
        -: 1386:
      298: 1387:	if (long_view) {
      298: 1387-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 293
        5: 1388:		int space_left = term_cols - MAX_PROP_STR;
        -: 1389:		/* SPACE_LEFT is the max space that should be used to print the
        -: 1390:		 * file name (plus space char) */
        -: 1391:
        -: 1392:		/* Do not allow SPACE_LEFT to be less than MIN_NAME_TRIM,
        -: 1393:		 * especially because the result of the above operation could
        -: 1394:		 * be negative */
        5: 1395:		if (space_left < min_name_trim)
        5: 1395-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 1396:			space_left = min_name_trim;
    %%%%%: 1396-block  0
unconditional  0 never executed
        -: 1397:
        5: 1398:		if ((int)longest < space_left)
        5: 1398-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4: 1399:			space_left = (int)longest;
        4: 1399-block  0
unconditional  0 taken 4
        -: 1400:
        5: 1401:		int k = (int)files;
      219: 1402:		for (i = 0; i < k; i++) {
        5: 1402-block  0
unconditional  0 taken 5
      214: 1402-block  1
unconditional  1 taken 214
      219: 1402-block  2
branch  2 taken 214
branch  3 taken 5 (fallthrough)
     214*: 1403:			if (max_files != UNSET && i == max_files)
      214: 1403-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 214
    %%%%%: 1403-block  1
branch  2 never executed
branch  3 never executed
    #####: 1404:				break;
    %%%%%: 1404-block  0
unconditional  0 never executed
        -: 1405:
      214: 1406:			if (pager) {
      214: 1406-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 214
    #####: 1407:				if (counter > (size_t)(term_rows - 2)) {
    %%%%%: 1407-block  0
branch  0 never executed
branch  1 never executed
    #####: 1408:					fputs("\x1b[7;97m--Mas--\x1b[0;49m", stdout);
    %%%%%: 1408-block  0
call    0 never executed
        -: 1409:
    #####: 1410:					switch (xgetchar()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1411:					/* Advance one line at a time */
    #####: 1412:					case 66: /* fallthrough */ /* Down arrow */
        -: 1413:					case 10: /* fallthrough */ /* Enter */
        -: 1414:					case 32: /* Space */
    #####: 1415:						break;
    %%%%%: 1415-block  0
unconditional  0 never executed
        -: 1416:
        -: 1417:					/* Advance one page at a time */
    #####: 1418:					case 126:  /* Page Down */
    #####: 1419:						counter = 0;
    #####: 1420:						break;
    %%%%%: 1420-block  0
unconditional  0 never executed
        -: 1421:
    #####: 1422:					case 63: /* fallthrough */ /* ? */
        -: 1423:					case 104: {		   /* h: Print pager help */
    #####: 1424:						CLEAR;
    %%%%%: 1424-block  0
call    0 never executed
    #####: 1425:						fputs(_("?, h: help\n"
call    0 never executed
call    1 never executed
        -: 1426:							"Down arrow, Enter, Space: Advance one line\n"
        -: 1427:							"Page Down: Advance one page\n"
        -: 1428:							"q: Stop pagging\n"), stdout);
        -: 1429:
    #####: 1430:						int l = (int)term_rows - 5;
    #####: 1431:						while (--l >= 0)
unconditional  0 never executed
    %%%%%: 1431-block  0
branch  1 never executed
branch  2 never executed
    #####: 1432:							putchar('\n');
    %%%%%: 1432-block  0
call    0 never executed
unconditional  1 never executed
        -: 1433:
    #####: 1434:						fputs("\x1b[7;97m--Mas--\x1b[0;49m", stdout);
    %%%%%: 1434-block  0
call    0 never executed
        -: 1435:
    #####: 1436:						i -= (term_rows - 1);
    #####: 1437:						if (i < 0)
branch  0 never executed
branch  1 never executed
    #####: 1438:							i = 0;
    %%%%%: 1438-block  0
unconditional  0 never executed
        -: 1439:
    #####: 1440:						counter = 0;
    #####: 1441:						xgetchar();
    %%%%%: 1441-block  0
call    0 never executed
    #####: 1442:						CLEAR;
call    0 never executed
    #####: 1443:					} break;
unconditional  0 never executed
        -: 1444:
        -: 1445:					/* Stop paging (and set a flag to reenable the pager
        -: 1446:					 * later) */
    #####: 1447:					case 99:  /* fallthrough */ /* 'c' */
        -: 1448:					case 112: /* fallthrough */ /* 'p' */
        -: 1449:					case 113:
    #####: 1450:						pager = 0, reset_pager = 1; /* 'q' */
    #####: 1451:						break;
    %%%%%: 1451-block  0
unconditional  0 never executed
        -: 1452:
        -: 1453:					/* If another key is pressed, go back one position.
        -: 1454:					 * Otherwise, some file names won't be listed.*/
    #####: 1455:					default:
    #####: 1456:						i--;
    #####: 1457:						fputs("\r\x1b[K\x1b[3J", stdout);
    %%%%%: 1457-block  0
call    0 never executed
    #####: 1458:						continue;
unconditional  0 never executed
        -: 1459:					}
        -: 1460:
    #####: 1461:					fputs("\r\x1b[K\x1b[3J", stdout);
    %%%%%: 1461-block  0
call    0 never executed
unconditional  1 never executed
        -: 1462:				}
        -: 1463:
    #####: 1464:				counter++;
    %%%%%: 1464-block  0
unconditional  0 never executed
        -: 1465:			}
        -: 1466:
        -: 1467:			/* Print ELN. The remaining part of the line will be
        -: 1468:			 * printed by print_entry_props() */
      214: 1469:			if (!no_eln)
      214: 1469-block  0
branch  0 taken 214 (fallthrough)
branch  1 taken 0
      214: 1470:				printf("%s%d%s ", el_c, i + 1, df_c);
      214: 1470-block  0
call    0 returned 214
unconditional  1 taken 214
        -: 1471:
      214: 1472:			print_entry_props(&file_info[i], (size_t)space_left);
      214: 1472-block  0
call    0 returned 214
unconditional  1 taken 214
        -: 1473:		}
        -: 1474:
        5: 1475:		goto END;
        5: 1475-block  0
unconditional  0 taken 5
        -: 1476:	}
        -: 1477:
        -: 1478:				/* ########################
        -: 1479:				 * #   NORMAL VIEW MODE   #
        -: 1480:				 * ######################## */
        -: 1481:
      293: 1482:	int last_column = 0;
        -: 1483:
        -: 1484:	/* Get amount of columns needed to print files in CWD  */
      293: 1485:	if (!columned) {
      293: 1485-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 292
        1: 1486:		columns_n = 1;
        1: 1486-block  0
unconditional  0 taken 1
        -: 1487:	} else {
      292: 1488:		columns_n = (size_t)term_cols / (longest + 1); /* +1 for the
        -: 1489:		space between file names */
        -: 1490:
        -: 1491:		/* If longest is bigger than terminal columns, columns_n will
        -: 1492:		 * be negative or zero. To avoid this: */
      292: 1493:		if (columns_n < 1)
      292: 1493-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 288
        4: 1494:			columns_n = 1;
        4: 1494-block  0
unconditional  0 taken 4
        -: 1495:
        -: 1496:		/* If we have only three files, we don't want four columns */
      292: 1497:		if (columns_n > (size_t)n)
      292: 1497-block  0
branch  0 taken 84 (fallthrough)
branch  1 taken 208
       84: 1498:			columns_n = (size_t)n;
       84: 1498-block  0
unconditional  0 taken 84
        -: 1499:	}
        -: 1500:
      293: 1501:	int nn = (int)n;
      293: 1502:	size_t cur_cols = 0;
    36787: 1503:	for (i = 0; i < nn; i++) {
      293: 1503-block  0
unconditional  0 taken 293
    36494: 1503-block  1
unconditional  1 taken 36494
    36787: 1503-block  2
branch  2 taken 36495
branch  3 taken 292 (fallthrough)
    36495: 1504:		if (max_files != UNSET && i == max_files)
    36495: 1504-block  0
branch  0 taken 101 (fallthrough)
branch  1 taken 36394
      101: 1504-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 100
        1: 1505:			break;
        1: 1505-block  0
unconditional  0 taken 1
        -: 1506:
        -: 1507:				/* ######################
        -: 1508:				 * #   A SIMPLE PAGER   #
        -: 1509:				 * ###################### */
        -: 1510:
        -: 1511:		/* A basic pager for directories containing large amount of
        -: 1512:		 * files. What's missing? It only goes downwards. To go
        -: 1513:		 * backwards, use the terminal scrollback function */
    36494: 1514:		if (pager) {
    36494: 1514-block  0
branch  0 taken 312 (fallthrough)
branch  1 taken 36182
        -: 1515:			/* Run the pager only once all columns and rows fitting in
        -: 1516:			 * the screen are filled with the corresponding file names */
      312: 1517:			if (last_column && counter > columns_n * ((size_t)term_rows - 2)) {
      312: 1517-block  0
branch  0 taken 309 (fallthrough)
branch  1 taken 3
      309: 1517-block  1
branch  2 taken 120 (fallthrough)
branch  3 taken 189
      120: 1518:				fputs("\x1b[7;97m--Mas--\x1b[0;49m", stdout);
      120: 1518-block  0
call    0 returned 120
        -: 1519:
      120: 1520:				switch (xgetchar()) {
call    0 returned 120
branch  1 taken 32
branch  2 taken 5
branch  3 taken 1
branch  4 taken 3
branch  5 taken 79
        -: 1521:				/* Advance one line at a time */
       32: 1522:				case 66: /* fallthrough */ /* Down arrow */
        -: 1523:				case 10: /* fallthrough */ /* Enter */
        -: 1524:				case 32: /* Space */
       32: 1525:					break;
       32: 1525-block  0
unconditional  0 taken 32
        -: 1526:
        -: 1527:				/* Advance one page at a time */
        5: 1528:				case 126: /* Page Down */
        5: 1529:					counter = 0; break;
        5: 1529-block  0
unconditional  0 taken 5
        -: 1530:
        1: 1531:				case 63: /* fallthrough */ /* ? */
        -: 1532:				case 104: {		   /* h: Print pager help */
        1: 1533:					CLEAR;
        1: 1533-block  0
call    0 returned 1
        -: 1534:
        1: 1535:					fputs(_("?, h: help\n"
call    0 returned 1
call    1 returned 1
        -: 1536:						"Down arrow, Enter, Space: Advance one line\n"
        -: 1537:						"Page Down: Advance one page\n"
        -: 1538:						"q: Stop pagging\n"), stdout);
        -: 1539:
        1: 1540:					int l = (int)term_rows - 5;
       19: 1541:					while (--l >= 0)
unconditional  0 taken 1
       19: 1541-block  0
branch  1 taken 18
branch  2 taken 1 (fallthrough)
       18: 1542:						putchar('\n');
       18: 1542-block  0
call    0 returned 18
unconditional  1 taken 18
        -: 1543:
        1: 1544:					fputs("\x1b[7;97m--Mas--\x1b[0;49m", stdout);
        1: 1544-block  0
call    0 returned 1
        -: 1545:
        1: 1546:					i -= ((term_rows * (int)columns_n) - 1);
        -: 1547:
        1: 1548:					if (i < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1549:						i = 0;
    %%%%%: 1549-block  0
unconditional  0 never executed
        -: 1550:
        1: 1551:					counter = 0;
        1: 1552:					xgetchar();
        1: 1552-block  0
call    0 returned 1
        1: 1553:					CLEAR;
call    0 returned 1
        1: 1554:				} break;
unconditional  0 taken 1
        -: 1555:
        -: 1556:				/* Stop paging (and set a flag to reenable the pager
        -: 1557:				 * later) */
        3: 1558:				case 99: /* fallthrough */  /* 'c' */
        -: 1559:				case 112: /* fallthrough */ /* 'p' */
        -: 1560:				case 113:
        3: 1561:					pager = 0, reset_pager = 1; /* 'q' */
        3: 1562:					break;
        3: 1562-block  0
unconditional  0 taken 3
        -: 1563:
        -: 1564:				/* If another key is pressed, go back one position.
        -: 1565:				 * Otherwise, some file names won't be listed.*/
       79: 1566:				default:
       79: 1567:					i--;
       79: 1568:					fputs("\r\x1b[K\x1b[3J", stdout);
       79: 1568-block  0
call    0 returned 79
       79: 1569:					continue;
unconditional  0 taken 79
        -: 1570:				}
        -: 1571:
       41: 1572:				fputs("\r\x1b[K\x1b[3J", stdout);
       41: 1572-block  0
call    0 returned 41
unconditional  1 taken 41
        -: 1573:			}
        -: 1574:
      233: 1575:			counter++;
      233: 1575-block  0
unconditional  0 taken 233
        -: 1576:		}
        -: 1577:
        -: 1578:		/* Determine if current entry is in the last column, in which
        -: 1579:		 * case a new line char will be appended */
    36415: 1580:		if (++cur_cols == columns_n) {
    36415: 1580-block  0
branch  0 taken 32210 (fallthrough)
branch  1 taken 4205
    32210: 1581:			cur_cols = 0;
    32210: 1582:			last_column = 1;
    32210: 1582-block  0
unconditional  0 taken 32210
        -: 1583:		} else {
     4205: 1584:			last_column = 0;
     4205: 1584-block  0
unconditional  0 taken 4205
        -: 1585:		}
        -: 1586:
   36415*: 1587:		file_info[i].eln_n = no_eln ? -1 : DIGINUM(i + 1);
    36415: 1587-block  0
branch  0 taken 36415 (fallthrough)
branch  1 taken 0
    36415: 1587-block  1
branch  2 taken 34479 (fallthrough)
branch  3 taken 1936
    34479: 1587-block  2
branch  4 taken 28893 (fallthrough)
branch  5 taken 5586
    28893: 1587-block  3
branch  6 taken 20480 (fallthrough)
branch  7 taken 8413
    20480: 1587-block  4
branch  8 taken 0 (fallthrough)
branch  9 taken 20480
    %%%%%: 1587-block  5
branch 10 never executed
branch 11 never executed
    %%%%%: 1587-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1587-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1587-block  8
branch 16 never executed
branch 17 never executed
    %%%%%: 1587-block  9
branch 18 never executed
branch 19 never executed
    %%%%%: 1587-block 10
unconditional 20 never executed
    %%%%%: 1587-block 11
unconditional 21 never executed
    %%%%%: 1587-block 12
unconditional 22 never executed
    %%%%%: 1587-block 13
unconditional 23 never executed
    %%%%%: 1587-block 14
unconditional 24 never executed
    %%%%%: 1587-block 15
unconditional 25 never executed
    %%%%%: 1587-block 16
unconditional 26 never executed
    %%%%%: 1587-block 17
unconditional 27 never executed
    %%%%%: 1587-block 18
unconditional 28 never executed
    %%%%%: 1587-block 19
unconditional 29 never executed
    %%%%%: 1587-block 20
unconditional 30 never executed
    20480: 1587-block 21
unconditional 31 taken 20480
    20480: 1587-block 22
unconditional 32 taken 20480
     8413: 1587-block 23
unconditional 33 taken 8413
    28893: 1587-block 24
unconditional 34 taken 28893
     5586: 1587-block 25
unconditional 35 taken 5586
    34479: 1587-block 26
unconditional 36 taken 34479
     1936: 1587-block 27
unconditional 37 taken 1936
    36415: 1587-block 28
unconditional 38 taken 36415
    %%%%%: 1587-block 29
unconditional 39 never executed
    36415: 1588:		int ind_char = 1;
    36415: 1589:		if (!classify)
    36415: 1589-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 36415
    #####: 1590:			ind_char = 0;
    %%%%%: 1590-block  0
unconditional  0 never executed
        -: 1591:
        -: 1592:			/* #################################
        -: 1593:			 * #    PRINT THE CURRENT ENTRY    #
        -: 1594:			 * ################################# */
        -: 1595:
    36415: 1596:		if (colorize) {
    36415: 1596-block  0
branch  0 taken 36415 (fallthrough)
branch  1 taken 0
    36415: 1597:			ind_char = 0;
        -: 1598:#ifndef _NO_ICONS
    36415: 1599:			if (icons) {
    36415: 1599-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 36408
        7: 1600:				if (no_eln) {
        7: 1600-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####: 1601:					xprintf("%s%s %s%s%s", file_info[i].icon_color,
    #####: 1602:					    file_info[i].icon, file_info[i].color,
    #####: 1603:					    file_info[i].name, df_c);
    %%%%%: 1603-block  0
call    0 never executed
unconditional  1 never executed
        -: 1604:				} else {
        7: 1605:					xprintf("%s%d%s %s%s %s%s%s", el_c, i + 1, df_c,
        7: 1606:					    file_info[i].icon_color, file_info[i].icon,
        7: 1607:					    file_info[i].color, file_info[i].name, df_c);
        7: 1607-block  0
call    0 returned 7
unconditional  1 taken 7
        -: 1608:				}
        -: 1609:			} else {
    36408: 1610:				if (no_eln) {
    36408: 1610-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 36408
    #####: 1611:					xprintf("%s%s%s", file_info[i].color,
    #####: 1612:					    file_info[i].name, df_c);
    %%%%%: 1612-block  0
call    0 never executed
unconditional  1 never executed
        -: 1613:				} else {
    36408: 1614:					xprintf("%s%d%s %s%s%s", el_c, i + 1, df_c,
    36408: 1615:						file_info[i].color, file_info[i].name, df_c);
    36408: 1615-block  0
call    0 returned 36408
unconditional  1 taken 36408
        -: 1616:				}
        -: 1617:			}
        -: 1618:#else
        -: 1619:			if (no_eln) {
        -: 1620:				xprintf("%s%s%s", file_info[i].color, file_info[i].name, df_c);
        -: 1621:			} else {
        -: 1622:				xprintf("%s%d%s %s%s%s", el_c, i + 1, df_c,
        -: 1623:				    file_info[i].color, file_info[i].name, df_c);
        -: 1624:			}
        -: 1625:#endif /* !_NO_ICONS */
        -: 1626:
    36415: 1627:			if (classify) {
    36415: 1627-block  0
branch  0 taken 36415 (fallthrough)
branch  1 taken 0
        -: 1628:				/* Append directory indicator and files counter */
    36415: 1629:				switch (file_info[i].type) {
    36415: 1629-block  0
branch  0 taken 2712
branch  1 taken 3615
branch  2 taken 30088
     2712: 1630:				case DT_DIR:
     2712: 1631:					putchar('/');
     2712: 1631-block  0
call    0 returned 2712
     2712: 1632:					if (file_info[i].filesn > 0 && files_counter)
branch  0 taken 2479 (fallthrough)
branch  1 taken 233
     2479: 1632-block  0
branch  2 taken 2476 (fallthrough)
branch  3 taken 3
     2476: 1633:						fputs(xitoa(file_info[i].filesn), stdout);
     2476: 1633-block  0
call    0 returned 2476
call    1 returned 2476
unconditional  2 taken 2476
     2712: 1634:					break;
     2712: 1634-block  0
unconditional  0 taken 2712
        -: 1635:
     3615: 1636:				case DT_LNK:
     3615: 1637:					if (file_info[i].dir)
     3615: 1637-block  0
branch  0 taken 59 (fallthrough)
branch  1 taken 3556
       59: 1638:					putchar('/');
       59: 1638-block  0
call    0 returned 59
unconditional  1 taken 59
     3615: 1639:					if (file_info[i].filesn > 0 && files_counter)
     3615: 1639-block  0
branch  0 taken 59 (fallthrough)
branch  1 taken 3556
       59: 1639-block  1
branch  2 taken 59 (fallthrough)
branch  3 taken 0
       59: 1640:						fputs(xitoa(file_info[i].filesn), stdout);
       59: 1640-block  0
call    0 returned 59
call    1 returned 59
unconditional  2 taken 59
     3615: 1641:					break;
     3615: 1641-block  0
unconditional  0 taken 3615
        -: 1642:				}
        -: 1643:			}
        -: 1644:		}
        -: 1645:
        -: 1646:		/* No color */
        -: 1647:		else {
        -: 1648:#ifndef _NO_ICONS
    #####: 1649:			if (icons) {
    %%%%%: 1649-block  0
branch  0 never executed
branch  1 never executed
    #####: 1650:				if (no_eln)
    %%%%%: 1650-block  0
branch  0 never executed
branch  1 never executed
    #####: 1651:					xprintf("%s %s", file_info[i].icon, file_info[i].name);
    %%%%%: 1651-block  0
call    0 never executed
unconditional  1 never executed
        -: 1652:				else
    #####: 1653:					xprintf("%s%d%s %s %s", el_c, i + 1, df_c,
    #####: 1654:					    file_info[i].icon, file_info[i].name);
    %%%%%: 1654-block  0
call    0 never executed
unconditional  1 never executed
        -: 1655:			} else {
    #####: 1656:				if (no_eln) {
    %%%%%: 1656-block  0
branch  0 never executed
branch  1 never executed
    #####: 1657:					fputs(file_info[i].name, stdout);
    %%%%%: 1657-block  0
call    0 never executed
unconditional  1 never executed
        -: 1658:				} else {
    #####: 1659:					xprintf("%s%d%s %s", el_c, i + 1, df_c, file_info[i].name);
    %%%%%: 1659-block  0
call    0 never executed
unconditional  1 never executed
        -: 1660:					/*                  fputs(el_c, stdout);
        -: 1661:					fputs(xitoa(i + 1), stdout);
        -: 1662:					fputs(df_c, stdout);
        -: 1663:					putchar(' ');
        -: 1664:					fputs(file_info[i].name, stdout); */
        -: 1665:				}
        -: 1666:			}
        -: 1667:#else
        -: 1668:			if (no_eln) {
        -: 1669:				fputs(file_info[i].name, stdout);
        -: 1670:			} else {
        -: 1671:				xprintf("%s%d%s %s", el_c, i + 1, df_c, file_info[i].name);
        -: 1672:			}
        -: 1673:#endif /* !_NO_ICONS */
        -: 1674:
    #####: 1675:			if (classify) {
    %%%%%: 1675-block  0
branch  0 never executed
branch  1 never executed
        -: 1676:				/* Append file type indicator */
    #####: 1677:				switch (file_info[i].type) {
    %%%%%: 1677-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1678:				case DT_DIR:
    #####: 1679:					ind_char = 0;
    #####: 1680:					putchar('/');
    %%%%%: 1680-block  0
call    0 never executed
    #####: 1681:					if (file_info[i].filesn > 0 && files_counter)
branch  0 never executed
branch  1 never executed
    %%%%%: 1681-block  0
branch  2 never executed
branch  3 never executed
    #####: 1682:						fputs(xitoa(file_info[i].filesn), stdout);
    %%%%%: 1682-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
    #####: 1683:					break;
    %%%%%: 1683-block  0
unconditional  0 never executed
        -: 1684:
    #####: 1685:				case DT_LNK:
    #####: 1686:					if (file_info[i].dir) {
    %%%%%: 1686-block  0
branch  0 never executed
branch  1 never executed
    #####: 1687:						ind_char = 0;
    #####: 1688:						putchar('/');
    %%%%%: 1688-block  0
call    0 never executed
    #####: 1689:						if (file_info[i].filesn > 0 && files_counter)
branch  0 never executed
branch  1 never executed
    %%%%%: 1689-block  0
branch  2 never executed
branch  3 never executed
    #####: 1690:							fputs(xitoa(file_info[i].filesn), stdout);
    %%%%%: 1690-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -: 1691:					} else {
    #####: 1692:						putchar('@');
    %%%%%: 1692-block  0
call    0 never executed
unconditional  1 never executed
        -: 1693:					}
    #####: 1694:					break;
    %%%%%: 1694-block  0
unconditional  0 never executed
        -: 1695:
    #####: 1696:				case DT_REG:
    #####: 1697:					if (file_info[i].exec)
    %%%%%: 1697-block  0
branch  0 never executed
branch  1 never executed
    #####: 1698:						putchar('*');
    %%%%%: 1698-block  0
call    0 never executed
unconditional  1 never executed
        -: 1699:					else
    #####: 1700:						ind_char = 0;
    %%%%%: 1700-block  0
unconditional  0 never executed
    #####: 1701:					break;
    %%%%%: 1701-block  0
unconditional  0 never executed
        -: 1702:
    #####: 1703:				case DT_FIFO: putchar('|'); break;
    %%%%%: 1703-block  0
call    0 never executed
unconditional  1 never executed
    #####: 1704:				case DT_SOCK: putchar('='); break;
    %%%%%: 1704-block  0
call    0 never executed
unconditional  1 never executed
    #####: 1705:				case DT_UNKNOWN: putchar('?'); break;
    %%%%%: 1705-block  0
call    0 never executed
unconditional  1 never executed
    #####: 1706:				default: ind_char = 0;
    %%%%%: 1706-block  0
unconditional  0 never executed
        -: 1707:				}
        -: 1708:			}
        -: 1709:		}
        -: 1710:
    36415: 1711:		if (!last_column) {
    36415: 1711-block  0
branch  0 taken 4205 (fallthrough)
branch  1 taken 32210
        -: 1712:			/* Pad the current file name to equate the longest file name length */
        -: 1713:#ifndef _NO_ICONS
     4205: 1714:			int cur_len = (int)file_info[i].eln_n + 1 + (icons ? 3 : 0) + (int)file_info[i].len + (ind_char ? 1 : 0);
     4205: 1714-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 4200
        5: 1714-block  1
unconditional  2 taken 5
     4200: 1714-block  2
unconditional  3 taken 4200
        -: 1715:#else
        -: 1716:			int cur_len = (int)file_info[i].eln_n + 1 + (int)file_info[i].len + (ind_char ? 1 : 0);
        -: 1717:#endif
     4205: 1718:			if (file_info[i].dir && classify) {
     4205: 1718-block  0
branch  0 taken 1853 (fallthrough)
branch  1 taken 2352
     1853: 1718-block  1
branch  2 taken 1853 (fallthrough)
branch  3 taken 0
     1853: 1719:				cur_len++;
     1853: 1720:				if (file_info[i].filesn > 0 && files_counter && file_info[i].ruser)
     1853: 1720-block  0
branch  0 taken 1688 (fallthrough)
branch  1 taken 165
     1688: 1720-block  1
branch  2 taken 1685 (fallthrough)
branch  3 taken 3
     1685: 1720-block  2
branch  4 taken 1685 (fallthrough)
branch  5 taken 0
    1685*: 1721:					cur_len += DIGINUM((int)file_info[i].filesn);
     1685: 1721-block  0
branch  0 taken 530 (fallthrough)
branch  1 taken 1155
      530: 1721-block  1
branch  2 taken 32 (fallthrough)
branch  3 taken 498
       32: 1721-block  2
branch  4 taken 4 (fallthrough)
branch  5 taken 28
        4: 1721-block  3
branch  6 taken 1 (fallthrough)
branch  7 taken 3
        1: 1721-block  4
branch  8 taken 1 (fallthrough)
branch  9 taken 0
        1: 1721-block  5
branch 10 taken 0 (fallthrough)
branch 11 taken 1
    %%%%%: 1721-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1721-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1721-block  8
branch 16 never executed
branch 17 never executed
    %%%%%: 1721-block  9
unconditional 18 never executed
    %%%%%: 1721-block 10
unconditional 19 never executed
    %%%%%: 1721-block 11
unconditional 20 never executed
    %%%%%: 1721-block 12
unconditional 21 never executed
    %%%%%: 1721-block 13
unconditional 22 never executed
    %%%%%: 1721-block 14
unconditional 23 never executed
    %%%%%: 1721-block 15
unconditional 24 never executed
        1: 1721-block 16
unconditional 25 taken 1
        1: 1721-block 17
unconditional 26 taken 1
    %%%%%: 1721-block 18
unconditional 27 never executed
        1: 1721-block 19
unconditional 28 taken 1
        3: 1721-block 20
unconditional 29 taken 3
        4: 1721-block 21
unconditional 30 taken 4
       28: 1721-block 22
unconditional 31 taken 28
       32: 1721-block 23
unconditional 32 taken 32
      498: 1721-block 24
unconditional 33 taken 498
      530: 1721-block 25
unconditional 34 taken 530
     1155: 1721-block 26
unconditional 35 taken 1155
     1685: 1721-block 27
unconditional 36 taken 1685
        -: 1722:			}
        -: 1723:
     4205: 1724:			int diff = (int)longest - cur_len;
        -: 1725:			/* Move the cursor %d columns to the right */
     4205: 1726:			xprintf("\x1b[%dC", diff + 1);
     4205: 1726-block  0
call    0 returned 4205
unconditional  1 taken 4205
        -: 1727:/*			register int j;
        -: 1728:			for (j = diff + 1; j--;)
        -: 1729:				putchar(' '); */
        -: 1730:		} else {
    32210: 1731:			putchar('\n');
    32210: 1731-block  0
call    0 returned 32210
unconditional  1 taken 32210
        -: 1732:		}
        -: 1733:	}
        -: 1734:
      293: 1735:	if (!last_column)
      293: 1735-block  0
branch  0 taken 169 (fallthrough)
branch  1 taken 124
      124: 1736:		putchar('\n');
      124: 1736-block  0
call    0 returned 124
unconditional  1 taken 124
        -: 1737:
        -: 1738:				/* #########################
        -: 1739:				 * #   POST LISTING STUFF  #
        -: 1740:				 * ######################### */
        -: 1741:
      169: 1742:END:
      169: 1742-block  0
unconditional  0 taken 169
        -: 1743:	/* Unhide the cursor */
      302: 1744:	fputs("\x1b[?25h", stdout);
      302: 1744-block  0
call    0 returned 302
        -: 1745:
      302: 1746:	if (close_dir && closedir(dir) == -1)
branch  0 taken 302 (fallthrough)
branch  1 taken 0
      302: 1746-block  0
call    2 returned 302
branch  3 taken 0 (fallthrough)
branch  4 taken 302
    #####: 1747:		return EXIT_FAILURE;
    %%%%%: 1747-block  0
unconditional  0 never executed
        -: 1748:
      302: 1749:	if (xargs.list_and_quit == 1)
      302: 1749-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 302
    #####: 1750:		exit(exit_code);
    %%%%%: 1750-block  0
call    0 never executed
        -: 1751:
      302: 1752:	if (reset_pager)
      302: 1752-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 299
        3: 1753:		pager = 1;
        3: 1753-block  0
unconditional  0 taken 3
        -: 1754:
      302: 1755:	if (max_files != UNSET && (int)files > max_files)
      302: 1755-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 301
        1: 1755-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 1756:		printf("%d/%zu\n", max_files, files);
        1: 1756-block  0
call    0 returned 1
unconditional  1 taken 1
        -: 1757:
        -: 1758:	/* Print a dividing line between the files list and the
        -: 1759:	 * prompt */
      302: 1760:	print_div_line();
      302: 1760-block  0
call    0 returned 302
        -: 1761:
      302: 1762:	if (dirhist_map) {
branch  0 taken 0 (fallthrough)
branch  1 taken 302
        -: 1763:		/* Print current, previous, and next entries */
    #####: 1764:		print_dirhist_map();
    %%%%%: 1764-block  0
call    0 never executed
    #####: 1765:		print_div_line();
call    0 never executed
unconditional  1 never executed
        -: 1766:	}
        -: 1767:
      302: 1768:	if (disk_usage)
      302: 1768-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 302
    #####: 1769:		print_disk_usage();
    %%%%%: 1769-block  0
call    0 never executed
unconditional  1 never executed
        -: 1770:
      302: 1771:	if (sort_switch)
      302: 1771-block  0
branch  0 taken 22 (fallthrough)
branch  1 taken 280
       22: 1772:		print_sort_method();
       22: 1772-block  0
call    0 returned 22
unconditional  1 taken 22
        -: 1773:
     302*: 1774:	if (print_selfiles && sel_n > 0)
      302: 1774-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 302
    %%%%%: 1774-block  1
branch  2 never executed
branch  3 never executed
    #####: 1775:		_print_selfiles(term_rows);
    %%%%%: 1775-block  0
call    0 never executed
unconditional  1 never executed
        -: 1776:
        -: 1777:#ifdef _LIST_SPEED
        -: 1778:	clock_t end = clock();
        -: 1779:	printf("list_dir time: %f\n", (double)(end-start)/CLOCKS_PER_SEC);
        -: 1780:#endif
      302: 1781:	return EXIT_SUCCESS;
      302: 1781-block  0
unconditional  0 taken 302
        -: 1782:}
        -: 1783:
        -: 1784:void
function free_dirlist called 305 returned 100% blocks executed 100%
      305: 1785:free_dirlist(void)
        -: 1786:{
      305: 1787:	if (!file_info || !files)
      305: 1787-block  0
branch  0 taken 305 (fallthrough)
branch  1 taken 0
      305: 1787-block  1
branch  2 taken 4 (fallthrough)
branch  3 taken 301
        4: 1788:		return;
        4: 1788-block  0
unconditional  0 taken 4
        -: 1789:
      301: 1790:	int i = (int)files;
    40382: 1791:	while (--i >= 0) {
      301: 1791-block  0
unconditional  0 taken 301
    40382: 1791-block  1
branch  1 taken 40081
branch  2 taken 301 (fallthrough)
    40081: 1792:		free(file_info[i].name);
    40081: 1793:		if (file_info[i].ext_color)
    40081: 1793-block  0
branch  0 taken 486 (fallthrough)
branch  1 taken 39595
      486: 1794:			free(file_info[i].ext_color);
      486: 1794-block  0
unconditional  0 taken 486
        -: 1795:	}
        -: 1796:
      301: 1797:	free(file_info);
      301: 1798:	file_info = (struct fileinfo *)NULL;
      301: 1798-block  0
unconditional  0 taken 301
        -: 1799:}
