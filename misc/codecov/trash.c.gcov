        -:    0:Source:trash.c
        -:    1:/* trash.c -- functions controlling the trash system */
        -:    2:
        -:    3:/*
        -:    4: * This file is part of CliFM
        -:    5: * 
        -:    6: * Copyright (C) 2016-2021, L. Abramovich <johndoe.arch@outlook.com>
        -:    7: * All rights reserved.
        -:    8:
        -:    9: * CliFM is free software; you can redistribute it and/or modify
        -:   10: * it under the terms of the GNU General Public License as published by
        -:   11: * the Free Software Foundation; either version 2 of the License, or
        -:   12: * (at your option) any later version.
        -:   13: *
        -:   14: * CliFM is distributed in the hope that it will be useful,
        -:   15: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   16: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   17: * GNU General Public License for more details.
        -:   18: *
        -:   19: * You should have received a copy of the GNU General Public License
        -:   20: * along with this program; if not, write to the Free Software
        -:   21: * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
        -:   22: * MA 02110-1301, USA.
        -:   23:*/
        -:   24:
        -:   25:#ifndef _NO_TRASH
        -:   26:
        -:   27:#include "helpers.h"
        -:   28:
        -:   29:#include <dirent.h>
        -:   30:#include <errno.h>
        -:   31:#include <fcntl.h>
        -:   32:#include <stdio.h>
        -:   33:#include <string.h>
        -:   34:#include <sys/stat.h>
        -:   35:#include <time.h>
        -:   36:#include <unistd.h>
        -:   37:
        -:   38:#include "aux.h"
        -:   39:#include "checks.h"
        -:   40:#include "colors.h"
        -:   41:#include "exec.h"
        -:   42:#include "misc.h"
        -:   43:#include "navigation.h"
        -:   44:#include "readline.h"
        -:   45:#include "sort.h"
        -:   46:#include "trash.h"
        -:   47:
        -:   48:/* Recursively check directory permissions (write and execute). Returns
        -:   49: * zero if OK, and one if at least one subdirectory does not have
        -:   50: * write/execute permissions */
        -:   51:static int
function recur_perm_check called 2 returned 100% blocks executed 65%
        2:   52:recur_perm_check(const char *dirname)
        -:   53:{
        -:   54:	DIR *dir;
        -:   55:	struct dirent *ent;
        -:   56:#if !defined(_DIRENT_HAVE_D_TYPE)
        -:   57:	struct stat attr;
        -:   58:#endif
        -:   59:
        2:   60:	if (!(dir = opendir(dirname)))
        2:   60-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:   61:		return EXIT_FAILURE;
    %%%%%:   61-block  0
unconditional  0 never executed
        -:   62:
        8:   63:	while ((ent = readdir(dir)) != NULL) {
        2:   63-block  0
unconditional  0 taken 2
        8:   63-block  1
call    1 returned 8
branch  2 taken 6
branch  3 taken 2 (fallthrough)
        -:   64:#if !defined(_DIRENT_HAVE_D_TYPE)
        -:   65:		if (lstat(ent->d_name, &attr) == -1)
        -:   66:			continue;
        -:   67:		if ((attr.st_mode & S_IFMT) == S_IFDIR) {
        -:   68:#else
        6:   69:		if (ent->d_type == DT_DIR) {
        6:   69-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 2
        -:   70:#endif
        4:   71:			char dirpath[PATH_MAX] = "";
        -:   72:
        4:   73:			if (*ent->d_name == '.' && (!ent->d_name[1]
        4:   73-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:   73-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 2
        2:   74:			|| (ent->d_name[1] == '.' && !ent->d_name[2])))
        2:   74-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:   74-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        4:   75:				continue;
        4:   75-block  0
unconditional  0 taken 4
        -:   76:
    #####:   77:			snprintf(dirpath, PATH_MAX, "%s/%s", dirname, ent->d_name);
        -:   78:
    #####:   79:			if (access(dirpath, W_OK | X_OK) != 0) {
    %%%%%:   79-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   80:				/* recur_perm_error_flag needs to be a global variable.
        -:   81:				  * Otherwise, since this function calls itself
        -:   82:				  * recursivelly, the flag would be reset upon every
        -:   83:				  * new call, without preserving the error code, which
        -:   84:				  * is what the flag is aimed to do. On the other side,
        -:   85:				  * if I use a local static variable for this flag, it
        -:   86:				  * will never drop the error value, and all subsequent
        -:   87:				  * calls to the function will allways return error
        -:   88:				  * (even if there's no actual error) */
    #####:   89:				recur_perm_error_flag = 1;
    #####:   90:				fprintf(stderr, _("%s: Permission denied\n"), dirpath);
    %%%%%:   90-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:   91:			}
        -:   92:
    #####:   93:			recur_perm_check(dirpath);
    %%%%%:   93-block  0
call    0 never executed
        -:   94:		}
        -:   95:	}
        -:   96:
        2:   97:	closedir(dir);
        2:   97-block  0
call    0 returned 2
        -:   98:
        2:   99:	if (recur_perm_error_flag)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  100:		return EXIT_FAILURE;
    %%%%%:  100-block  0
unconditional  0 never executed
        -:  101:
        2:  102:	return EXIT_SUCCESS;
        2:  102-block  0
unconditional  0 taken 2
        -:  103:}
        -:  104:
        -:  105:/* Check whether the current user has enough permissions (write, execute)
        -:  106: * to modify the contents of the parent directory of 'file'. 'file' needs
        -:  107: * to be an absolute path. Returns zero if yes and one if no. Useful to
        -:  108: * know if a file can be removed from or copied into the parent. In case
        -:  109: * FILE is a directory, the function checks all its subdirectories for
        -:  110: * appropriate permissions, including the immutable bit */
        -:  111:static int
function wx_parent_check called 11 returned 100% blocks executed 49%
       11:  112:wx_parent_check(char *file)
        -:  113:{
        -:  114:	struct stat file_attrib;
       11:  115:	int exit_status = -1, ret = -1;
       11:  116:	size_t file_len = strlen(file);
        -:  117:
       11:  118:	if (file[file_len - 1] == '/')
       11:  118-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 8
        3:  119:		file[file_len - 1] = '\0';
        3:  119-block  0
unconditional  0 taken 3
        -:  120:
       11:  121:	if (lstat(file, &file_attrib) == -1) {
       11:  121-block  0
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:  122:		fprintf(stderr, _("%s: No such file or directory\n"), file);
    %%%%%:  122-block  0
call    0 never executed
call    1 never executed
    #####:  123:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  124:	}
        -:  125:
       11:  126:	char *parent = strbfrlst(file, '/');
       11:  126-block  0
call    0 returned 11
       11:  127:	if (!parent) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
        -:  128:		/* strbfrlst() will return NULL if file's parent is root (/),
        -:  129:		 * simply because in this case there's nothing before the last
        -:  130:		 * slash. So, check if file's parent dir is root */
    #####:  131:		if (file[0] == '/' && strcntchr(file + 1, '/') == -1) {
    %%%%%:  131-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  131-block  1
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  132:			parent = (char *)xnmalloc(2, sizeof(char));
    %%%%%:  132-block  0
call    0 never executed
    #####:  133:			parent[0] = '/';
    #####:  134:			parent[1] = '\0';
unconditional  0 never executed
        -:  135:		} else {
    #####:  136:			fprintf(stderr, _("%s: %s: Error getting parent directory\n"),
    %%%%%:  136-block  0
call    0 never executed
call    1 never executed
        -:  137:					PROGRAM_NAME, file);
    #####:  138:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  139:		}
        -:  140:	}
        -:  141:
       11:  142:	switch (file_attrib.st_mode & S_IFMT) {
       11:  142-block  0
branch  0 taken 3
branch  1 taken 6
branch  2 taken 2
branch  3 taken 0
        3:  143:	case S_IFDIR:
        3:  144:		ret = check_immutable_bit(file);
        3:  144-block  0
call    0 returned 3
        -:  145:
        3:  146:		if (ret == -1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:  147:			/* Error message is printed by check_immutable_bit() itself */
    #####:  148:			exit_status = EXIT_FAILURE;
    %%%%%:  148-block  0
unconditional  0 never executed
        3:  149:		} else if (ret == 1) {
        3:  149-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  150:			fprintf(stderr, _("%s: Directory is immutable\n"), file);
    %%%%%:  150-block  0
call    0 never executed
call    1 never executed
    #####:  151:			exit_status = EXIT_FAILURE;
unconditional  0 never executed
        3:  152:		} else if (access(parent, W_OK | X_OK) == 0) {
        3:  152-block  0
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
        -:  153:		/* Check the parent for appropriate permissions */
        3:  154:			int files_n = count_dir(parent, NO_CPOP);
        3:  154-block  0
call    0 returned 3
        -:  155:
        3:  156:			if (files_n > 2) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -:  157:				/* I manually check here subdir because recur_perm_check()
        -:  158:				 * will only check the contents of subdir, but not subdir
        -:  159:				 * itself */
        -:  160:				/* If the parent is ok and not empty, check subdir */
        3:  161:				if (access(file, W_OK | X_OK) == 0) {
        3:  161-block  0
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
        -:  162:					/* If subdir is ok and not empty, recusivelly check
        -:  163:					 * subdir */
        3:  164:					files_n = count_dir(file, NO_CPOP);
        3:  164-block  0
call    0 returned 3
        -:  165:
        3:  166:					if (files_n > 2) {
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        -:  167:						/* Reset the recur_perm_check() error flag. See
        -:  168:						 * the note in the function block. */
        2:  169:						recur_perm_error_flag = 0;
        -:  170:
        2:  171:						if (recur_perm_check(file) == 0) {
        2:  171-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2:  172:							exit_status = EXIT_SUCCESS;
        2:  172-block  0
unconditional  0 taken 2
        -:  173:						} else {
        -:  174:							/* recur_perm_check itself will print the
        -:  175:							 * error messages */
    #####:  176:							exit_status = EXIT_FAILURE;
    %%%%%:  176-block  0
unconditional  0 never executed
        -:  177:						}
        -:  178:					} else { /* Subdir is ok and empty */
        1:  179:						exit_status = EXIT_SUCCESS;
        1:  179-block  0
unconditional  0 taken 1
        -:  180:					}
        -:  181:				} else { /* No permission for subdir */
    #####:  182:					fprintf(stderr, _("%s: Permission denied\n"),
    %%%%%:  182-block  0
call    0 never executed
call    1 never executed
        -:  183:					    file);
    #####:  184:					exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  185:				}
        -:  186:			}
        -:  187:
        -:  188:			else
    #####:  189:				exit_status = EXIT_SUCCESS;
    %%%%%:  189-block  0
unconditional  0 never executed
        -:  190:		} else { /* No permission for parent */
    #####:  191:			fprintf(stderr, _("%s: Permission denied\n"), parent);
    %%%%%:  191-block  0
call    0 never executed
call    1 never executed
    #####:  192:			exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  193:		}
        3:  194:		break;
        3:  194-block  0
unconditional  0 taken 3
        -:  195:
        6:  196:	case S_IFREG:
        6:  197:		ret = check_immutable_bit(file);
        6:  197-block  0
call    0 returned 6
        -:  198:
        6:  199:		if (ret == -1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -:  200:			/* Error message is printed by check_immutable_bit()
        -:  201:			 * itself */
    #####:  202:			exit_status = EXIT_FAILURE;
    %%%%%:  202-block  0
unconditional  0 never executed
        6:  203:		} else if (ret == 1) {
        6:  203-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:  204:			fprintf(stderr, _("%s: File is immutable\n"), file);
    %%%%%:  204-block  0
call    0 never executed
call    1 never executed
    #####:  205:			exit_status = EXIT_FAILURE;
unconditional  0 never executed
        6:  206:		} else if (parent) {
        6:  206-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6:  207:			if (access(parent, W_OK | X_OK) == 0) {
        6:  207-block  0
call    0 returned 6
branch  1 taken 6 (fallthrough)
branch  2 taken 0
        6:  208:				exit_status = EXIT_SUCCESS;
        6:  208-block  0
unconditional  0 taken 6
        -:  209:			} else {
    #####:  210:				fprintf(stderr, _("%s: Permission denied\n"), parent);
    %%%%%:  210-block  0
call    0 never executed
call    1 never executed
    #####:  211:				exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  212:			}
        -:  213:		}
        -:  214:
        6:  215:		break;
        6:  215-block  0
unconditional  0 taken 6
        -:  216:
        2:  217:	case S_IFSOCK:
        -:  218:	case S_IFIFO:
        -:  219:	case S_IFLNK:
        -:  220:		/* Symlinks, sockets and pipes do not support immutable bit */
        2:  221:		if (parent) {
        2:  221-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  222:			if (access(parent, W_OK | X_OK) == 0) {
        2:  222-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2:  223:				exit_status = EXIT_SUCCESS;
        2:  223-block  0
unconditional  0 taken 2
        -:  224:			} else {
    #####:  225:				fprintf(stderr, _("%s: Permission denied\n"), parent);
    %%%%%:  225-block  0
call    0 never executed
call    1 never executed
    #####:  226:				exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  227:			}
        -:  228:		}
        2:  229:		break;
        2:  229-block  0
unconditional  0 taken 2
        -:  230:
        -:  231:	/* DO NOT TRASH BLOCK AND CHAR DEVICES */
    #####:  232:	default:
    #####:  233:		fprintf(stderr, _("%s: trash: %s (%s): Unsupported file type\n"),
    %%%%%:  233-block  0
unconditional  0 never executed
    %%%%%:  233-block  1
unconditional  1 never executed
    %%%%%:  233-block  2
call    2 never executed
call    3 never executed
    #####:  234:		    PROGRAM_NAME, file, ((file_attrib.st_mode & S_IFMT) == S_IFBLK)
    %%%%%:  234-block  0
branch  0 never executed
branch  1 never executed
    #####:  235:		    ? "Block device" : ((file_attrib.st_mode & S_IFMT) == S_IFCHR)
    #####:  236:		    ? "Character device" : "Unknown file type");
    %%%%%:  236-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  236-block  1
unconditional  2 never executed
    %%%%%:  236-block  2
unconditional  3 never executed
    #####:  237:		exit_status = EXIT_FAILURE;
    #####:  238:		break;
unconditional  0 never executed
        -:  239:	}
        -:  240:
       11:  241:	if (parent)
       11:  241-block  0
branch  0 taken 11 (fallthrough)
branch  1 taken 0
       11:  242:		free(parent);
       11:  242-block  0
unconditional  0 taken 11
        -:  243:
       11:  244:	return exit_status;
       11:  244-block  0
unconditional  0 taken 11
        -:  245:}
        -:  246:
        -:  247:static int
function trash_clear called 0 returned 0% blocks executed 0%
    #####:  248:trash_clear(void)
        -:  249:{
    #####:  250:	struct dirent **trash_files = (struct dirent **)NULL;
    #####:  251:	int files_n = -1, exit_status = EXIT_SUCCESS;
        -:  252:
    #####:  253:	if (xchdir(trash_files_dir, NO_TITLE) == -1) {
    %%%%%:  253-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  254:		_err(0, NOPRINT_PROMPT, "%s: trash: '%s': %s\n", PROGRAM_NAME,
call    0 never executed
    #####:  255:		    trash_files_dir, strerror(errno));
    %%%%%:  255-block  0
call    0 never executed
    #####:  256:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  257:	}
        -:  258:
    #####:  259:	files_n = scandir(trash_files_dir, &trash_files, skip_files, xalphasort);
    %%%%%:  259-block  0
call    0 never executed
        -:  260:
    #####:  261:	if (!files_n) {
branch  0 never executed
branch  1 never executed
    #####:  262:		puts(_("trash: There are no trashed files"));
    %%%%%:  262-block  0
call    0 never executed
call    1 never executed
    #####:  263:		return EXIT_SUCCESS;
unconditional  0 never executed
        -:  264:	}
        -:  265:
        -:  266:	size_t i;
    #####:  267:	for (i = 0; i < (size_t)files_n; i++) {
    %%%%%:  267-block  0
unconditional  0 never executed
    %%%%%:  267-block  1
branch  1 never executed
branch  2 never executed
    #####:  268:		size_t info_file_len = strlen(trash_files[i]->d_name) + 11;
    #####:  269:		char *info_file = (char *)xnmalloc(info_file_len, sizeof(char));
    %%%%%:  269-block  0
call    0 never executed
    #####:  270:		sprintf(info_file, "%s.trashinfo", trash_files[i]->d_name);
        -:  271:
    #####:  272:		char *file1 = (char *)NULL;
    #####:  273:		file1 = (char *)xnmalloc(strlen(trash_files_dir) +
    #####:  274:					strlen(trash_files[i]->d_name) + 2, sizeof(char));
call    0 never executed
        -:  275:
    #####:  276:		sprintf(file1, "%s/%s", trash_files_dir, trash_files[i]->d_name);
        -:  277:
    #####:  278:		char *file2 = (char *)NULL;
    #####:  279:		file2 = (char *)xnmalloc(strlen(trash_info_dir) +
    #####:  280:					strlen(info_file) + 2, sizeof(char));
call    0 never executed
    #####:  281:		sprintf(file2, "%s/%s", trash_info_dir, info_file);
        -:  282:
    #####:  283:		char *tmp_cmd[] = {"rm", "-r", file1, file2, NULL};
    #####:  284:		int ret = launch_execve(tmp_cmd, FOREGROUND, E_NOFLAG);
call    0 never executed
        -:  285:
    #####:  286:		free(file1);
    #####:  287:		free(file2);
        -:  288:
    #####:  289:		if (ret != EXIT_SUCCESS) {
branch  0 never executed
branch  1 never executed
    #####:  290:			fprintf(stderr, _("%s: trash: %s: Error removing "
call    0 never executed
    #####:  291:				"trashed file\n"), PROGRAM_NAME, trash_files[i]->d_name);
    %%%%%:  291-block  0
call    0 never executed
    #####:  292:			exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  293:			/* If there is at least one error, return error */
        -:  294:		}
        -:  295:
    #####:  296:		free(info_file);
    #####:  297:		free(trash_files[i]);
    %%%%%:  297-block  0
unconditional  0 never executed
        -:  298:	}
        -:  299:
    #####:  300:	free(trash_files);
        -:  301:
    #####:  302:	if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
    %%%%%:  302-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  303:		_err(0, NOPRINT_PROMPT, "%s: trash: '%s': %s\n", PROGRAM_NAME,
    #####:  304:		    ws[cur_ws].path, strerror(errno));
    %%%%%:  304-block  0
call    0 never executed
call    1 never executed
    #####:  305:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  306:	}
        -:  307:
    #####:  308:	return exit_status;
    %%%%%:  308-block  0
unconditional  0 never executed
        -:  309:}
        -:  310:
        -:  311:static int
function trash_element called 11 returned 100% blocks executed 48%
       11:  312:trash_element(const char *suffix, struct tm *tm, char *file)
        -:  313:{
        -:  314:	/* Check file's existence */
        -:  315:	struct stat file_attrib;
        -:  316:
       11:  317:	if (lstat(file, &file_attrib) == -1) {
       11:  317-block  0
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####:  318:		fprintf(stderr, "%s: trash: %s: %s\n", PROGRAM_NAME, file,
call    0 never executed
    #####:  319:		    strerror(errno));
    %%%%%:  319-block  0
call    0 never executed
    #####:  320:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  321:	}
        -:  322:
        -:  323:	/* Check whether the user has enough permissions to remove file */
        -:  324:	/* If relative path */
       11:  325:	char full_path[PATH_MAX] = "";
        -:  326:
       11:  327:	if (*file != '/') {
       11:  327-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 4
        -:  328:		/* Construct absolute path for file */
        7:  329:		snprintf(full_path, PATH_MAX, "%s/%s", ws[cur_ws].path, file);
        7:  330:		if (wx_parent_check(full_path) != 0)
        7:  330-block  0
call    0 returned 7
branch  1 taken 0 (fallthrough)
branch  2 taken 7
    #####:  331:			return EXIT_FAILURE;
    %%%%%:  331-block  0
unconditional  0 never executed
        4:  332:	} else if (wx_parent_check(file) != 0) {
        4:  332-block  0
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
        -:  333:	/* If absolute path */
    #####:  334:		return EXIT_FAILURE;
    %%%%%:  334-block  0
unconditional  0 never executed
        -:  335:	}
        -:  336:
       11:  337:	int ret = -1;
        -:  338:
        -:  339:	/* Create the trashed file name: orig_filename.suffix, where SUFFIX is
        -:  340:	 * current date and time */
       11:  341:	char *filename = (char *)NULL;
       11:  342:	if (*file != '/') /* If relative path */
       11:  342-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 4
        7:  343:		filename = straftlst(full_path, '/');
        7:  343-block  0
call    0 returned 7
unconditional  1 taken 7
        -:  344:	else /* If absolute path */
        4:  345:		filename = straftlst(file, '/');
        4:  345-block  0
call    0 returned 4
unconditional  1 taken 4
        -:  346:
       11:  347:	if (!filename) {
       11:  347-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:  348:		fprintf(stderr, _("%s: trash: %s: Error getting file name\n"),
    %%%%%:  348-block  0
call    0 never executed
call    1 never executed
        -:  349:		    PROGRAM_NAME, file);
    #####:  350:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  351:	}
        -:  352:	/* If the length of the trashed file name (orig_filename.suffix) is
        -:  353:	 * longer than NAME_MAX (255), trim the original filename, so that
        -:  354:	 * (original_filename_len + 1 (dot) + suffix_len) won't be longer
        -:  355:	 * than NAME_MAX */
       11:  356:	size_t filename_len = strlen(filename), suffix_len = strlen(suffix);
       11:  357:	int size = (int)(filename_len + suffix_len + 1) - NAME_MAX;
        -:  358:
       11:  359:	if (size > 0) {
       11:  359-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
        -:  360:		/* If SIZE is a positive value, that is, the trashed file name
        -:  361:		 * exceeds NAME_MAX by SIZE bytes, reduce the original file name
        -:  362:		 * SIZE bytes. Terminate the original file name (FILENAME) with
        -:  363:		 * a tilde (~), to let the user know it is trimmed */
    #####:  364:		filename[filename_len - (size_t)size - 1] = '~';
    #####:  365:		filename[filename_len - (size_t)size] = '\0';
    %%%%%:  365-block  0
unconditional  0 never executed
        -:  366:	}
        -:  367:
        -:  368:	/* 2 = dot + null byte */
       11:  369:	size_t file_suffix_len = filename_len + suffix_len + 2;
       11:  370:	char *file_suffix = (char *)xnmalloc(file_suffix_len, sizeof(char));
       11:  370-block  0
call    0 returned 11
        -:  371:	/* No need for memset. sprintf adds the terminating null byte by
        -:  372:	 * itself */
       11:  373:	sprintf(file_suffix, "%s.%s", filename, suffix);
        -:  374:
        -:  375:	/* Copy the original file into the trash files directory */
       11:  376:	char *dest = (char *)NULL;
       11:  377:	dest = (char *)xnmalloc(strlen(trash_files_dir) + strlen(file_suffix) + 2,
call    0 returned 11
        -:  378:							sizeof(char));
       11:  379:	sprintf(dest, "%s/%s", trash_files_dir, file_suffix);
        -:  380:
       11:  381:	char *tmp_cmd[] = {"cp", "-a", file, dest, NULL};
        -:  382:
       11:  383:	free(filename);
        -:  384:
       11:  385:	ret = launch_execve(tmp_cmd, FOREGROUND, E_NOFLAG);
call    0 returned 11
       11:  386:	free(dest);
       11:  387:	dest = (char *)NULL;
        -:  388:
       11:  389:	if (ret != EXIT_SUCCESS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:  390:		fprintf(stderr, _("%s: trash: %s: Failed copying file to "
    %%%%%:  390-block  0
call    0 never executed
call    1 never executed
        -:  391:			"Trash\n"), PROGRAM_NAME, file);
    #####:  392:		free(file_suffix);
    #####:  393:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  394:	}
        -:  395:
        -:  396:	/* Generate the info file */
       11:  397:	size_t info_file_len = strlen(trash_info_dir) + strlen(file_suffix) + 12;
        -:  398:
       11:  399:	char *info_file = (char *)xnmalloc(info_file_len, sizeof(char));
       11:  399-block  0
call    0 returned 11
       11:  400:	sprintf(info_file, "%s/%s.trashinfo", trash_info_dir, file_suffix);
        -:  401:
       11:  402:	FILE *info_fp = fopen(info_file, "w");
call    0 returned 11
       11:  403:	if (!info_fp) { /* If error creating the info file */
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:  404:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, info_file,
call    0 never executed
    #####:  405:		    strerror(errno));
    %%%%%:  405-block  0
call    0 never executed
        -:  406:		/* Remove the trash file */
    #####:  407:		char *trash_file = (char *)NULL;
    #####:  408:		trash_file = (char *)xnmalloc(strlen(trash_files_dir)
    #####:  409:						+ strlen(file_suffix) + 2, sizeof(char));
call    0 never executed
    #####:  410:		sprintf(trash_file, "%s/%s", trash_files_dir, file_suffix);
        -:  411:
    #####:  412:		char *tmp_cmd2[] = {"rm", "-r", trash_file, NULL};
    #####:  413:		ret = launch_execve(tmp_cmd2, FOREGROUND, E_NOFLAG);
call    0 never executed
        -:  414:
    #####:  415:		free(trash_file);
        -:  416:
    #####:  417:		if (ret != EXIT_SUCCESS)
branch  0 never executed
branch  1 never executed
    #####:  418:			fprintf(stderr, _("%s: trash: %s/%s: Failed removing trash "
    %%%%%:  418-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  419:				"file\nTry removing it manually\n"), PROGRAM_NAME,
        -:  420:			    trash_files_dir, file_suffix);
        -:  421:
    #####:  422:		free(file_suffix);
    #####:  423:		free(info_file);
        -:  424:
    #####:  425:		return EXIT_FAILURE;
    %%%%%:  425-block  0
unconditional  0 never executed
        -:  426:	}
        -:  427:
        -:  428:	else { /* If info file was generated successfully */
        -:  429:		/* Encode path to URL format (RF 2396) */
       11:  430:		char *url_str = (char *)NULL;
        -:  431:
       11:  432:		if (*file != '/')
       11:  432-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 4
        7:  433:			url_str = url_encode(full_path);
        7:  433-block  0
call    0 returned 7
unconditional  1 taken 7
        -:  434:		else
        4:  435:			url_str = url_encode(file);
        4:  435-block  0
call    0 returned 4
unconditional  1 taken 4
        -:  436:
       11:  437:		if (!url_str) {
       11:  437-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:  438:			fprintf(stderr, _("%s: trash: %s: Failed encoding path\n"),
    %%%%%:  438-block  0
call    0 never executed
call    1 never executed
        -:  439:			    PROGRAM_NAME, file);
        -:  440:
    #####:  441:			fclose(info_fp);
call    0 never executed
    #####:  442:			free(info_file);
    #####:  443:			free(file_suffix);
    #####:  444:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  445:		}
        -:  446:
        -:  447:		/* Write trashed file information into the info file */
       11:  448:		fprintf(info_fp,
        -:  449:		    "[Trash Info]\nPath=%s\nDeletionDate=%d%d%dT%d:%d:%d\n",
       11:  450:		    url_str, tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
       11:  450-block  0
call    0 returned 11
        -:  451:		    tm->tm_hour, tm->tm_min, tm->tm_sec);
       11:  452:		fclose(info_fp);
call    0 returned 11
       11:  453:		free(url_str);
       11:  454:		url_str = (char *)NULL;
        -:  455:	}
        -:  456:
        -:  457:	/* Remove the file to be trashed */
       11:  458:	char *tmp_cmd3[] = {"rm", "-r", file, NULL};
       11:  459:	ret = launch_execve(tmp_cmd3, FOREGROUND, E_NOFLAG);
call    0 returned 11
        -:  460:
        -:  461:	/* If remove fails, remove trash and info files */
       11:  462:	if (ret != EXIT_SUCCESS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####:  463:		fprintf(stderr, _("%s: trash: %s: Failed removing file\n"),
    %%%%%:  463-block  0
call    0 never executed
call    1 never executed
        -:  464:		    PROGRAM_NAME, file);
    #####:  465:		char *trash_file = (char *)NULL;
    #####:  466:		trash_file = (char *)xnmalloc(strlen(trash_files_dir)
    #####:  467:						+ strlen(file_suffix) + 2, sizeof(char));
call    0 never executed
    #####:  468:		sprintf(trash_file, "%s/%s", trash_files_dir, file_suffix);
        -:  469:
    #####:  470:		char *tmp_cmd4[] = {"rm", "-r", trash_file, info_file, NULL};
    #####:  471:		ret = launch_execve(tmp_cmd4, FOREGROUND, E_NOFLAG);
call    0 never executed
    #####:  472:		free(trash_file);
        -:  473:
    #####:  474:		if (ret != EXIT_SUCCESS) {
branch  0 never executed
branch  1 never executed
    #####:  475:			fprintf(stderr, _("%s: trash: Failed removing temporary "
    %%%%%:  475-block  0
call    0 never executed
call    1 never executed
        -:  476:					"files from Trash.\nTry removing them manually\n"),
        -:  477:					PROGRAM_NAME);
    #####:  478:			free(file_suffix);
    #####:  479:			free(info_file);
    #####:  480:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  481:		}
        -:  482:	}
        -:  483:
       11:  484:	free(info_file);
       11:  485:	free(file_suffix);
       11:  486:	return EXIT_SUCCESS;
       11:  486-block  0
unconditional  0 taken 11
        -:  487:}
        -:  488:
        -:  489:static int
function remove_from_trash called 1 returned 100% blocks executed 45%
        1:  490:remove_from_trash(void)
        -:  491:{
        -:  492:	/* List trashed files */
        -:  493:	/* Change CWD to the trash directory. Otherwise, scandir() will fail */
        1:  494:	if (xchdir(trash_files_dir, NO_TITLE) == -1) {
        1:  494-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  495:		_err(0, NOPRINT_PROMPT, "%s: trash: '%s': %s\n", PROGRAM_NAME,
call    0 never executed
    #####:  496:		    trash_files_dir, strerror(errno));
    %%%%%:  496-block  0
call    0 never executed
    #####:  497:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  498:	}
        -:  499:
        1:  500:	size_t i = 0;
        1:  501:	struct dirent **trash_files = (struct dirent **)NULL;
       1*:  502:	int files_n = scandir(trash_files_dir, &trash_files,
    %%%%%:  502-block  0
unconditional  0 never executed
    %%%%%:  502-block  1
unconditional  1 never executed
    %%%%%:  502-block  2
unconditional  2 never executed
        1:  502-block  3
unconditional  3 taken 1
        1:  502-block  4
call    4 returned 1
        1:  503:					skip_files, (unicode) ? alphasort : (case_sensitive)
        1:  503-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  504:					? xalphasort : alphasort_insensitive);
    %%%%%:  504-block  0
branch  0 never executed
branch  1 never executed
        -:  505:
        1:  506:	if (files_n) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  507:		printf(_("%sTrashed files%s\n\n"), BOLD, df_c);
        1:  507-block  0
call    0 returned 1
call    1 returned 1
        -:  508:
        2:  509:		for (i = 0; i < (size_t)files_n; i++)
unconditional  0 taken 1
unconditional  1 taken 1
        2:  509-block  0
branch  2 taken 1
branch  3 taken 1
        1:  510:			colors_list(trash_files[i]->d_name, (int)i + 1, NO_PAD,
        1:  510-block  0
call    0 returned 1
        -:  511:			    PRINT_NEWLINE);
        -:  512:	} else {
    #####:  513:		puts(_("trash: There are no trashed files"));
    %%%%%:  513-block  0
call    0 never executed
call    1 never executed
        -:  514:		/* Restore CWD and return */
    #####:  515:		if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  516:			_err(0, NOPRINT_PROMPT, "%s: trash: '%s': %s\n",
    #####:  517:			    PROGRAM_NAME, ws[cur_ws].path, strerror(errno));
    %%%%%:  517-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  518:		}
        -:  519:
    #####:  520:		return EXIT_SUCCESS;
    %%%%%:  520-block  0
unconditional  0 never executed
        -:  521:	}
        -:  522:
        -:  523:	/* Restore CWD and continue */
        1:  524:	if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
        1:  524-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  525:		_err(0, NOPRINT_PROMPT, "%s: trash: '%s': %s\n", PROGRAM_NAME,
    #####:  526:		    ws[cur_ws].path, strerror(errno));
    %%%%%:  526-block  0
call    0 never executed
call    1 never executed
    #####:  527:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  528:	}
        -:  529:
        -:  530:	/* Get user input */
        1:  531:	printf(_("\n%sEnter 'q' to quit.\n"), df_c);
        1:  531-block  0
call    0 returned 1
call    1 returned 1
        1:  532:	char *line = (char *)NULL, **rm_elements = (char **)NULL;
        -:  533:
        2:  534:	while (!line)
unconditional  0 taken 1
        2:  534-block  0
branch  1 taken 1
branch  2 taken 1 (fallthrough)
        1:  535:		line = rl_no_hist(_("File(s) to be removed (ex: 1 2-6, or *): "));
        1:  535-block  0
call    0 returned 1
call    1 returned 1
unconditional  2 taken 1
        -:  536:
        1:  537:	rm_elements = get_substr(line, ' ');
        1:  537-block  0
call    0 returned 1
        1:  538:	free(line);
        -:  539:
        1:  540:	if (!rm_elements)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  541:		return EXIT_FAILURE;
    %%%%%:  541-block  0
unconditional  0 never executed
        -:  542:
        -:  543:	/* Remove files */
        1:  544:	char rm_file[PATH_MAX] = "", rm_info[PATH_MAX] = "";
        1:  545:	int ret = -1, exit_status = EXIT_SUCCESS;
        -:  546:
        -:  547:	/* First check for exit, wildcard, and non-number args */
        2:  548:	for (i = 0; rm_elements[i]; i++) {
        1:  548-block  0
unconditional  0 taken 1
        1:  548-block  1
unconditional  1 taken 1
        2:  548-block  2
branch  2 taken 1
branch  3 taken 1 (fallthrough)
        -:  549:		/* Quit */
        1:  550:		if (strcmp(rm_elements[i], "q") == 0) {
        1:  550-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  551:			size_t j;
    #####:  552:			for (j = 0; rm_elements[j]; j++)
    %%%%%:  552-block  0
unconditional  0 never executed
    %%%%%:  552-block  1
branch  1 never executed
branch  2 never executed
    #####:  553:				free(rm_elements[j]);
    %%%%%:  553-block  0
unconditional  0 never executed
    #####:  554:			free(rm_elements);
        -:  555:
    #####:  556:			for (j = 0; j < (size_t)files_n; j++)
    %%%%%:  556-block  0
unconditional  0 never executed
    %%%%%:  556-block  1
branch  1 never executed
branch  2 never executed
    #####:  557:				free(trash_files[j]);
    %%%%%:  557-block  0
unconditional  0 never executed
    #####:  558:			free(trash_files);
        -:  559:
    #####:  560:			return exit_status;
    %%%%%:  560-block  0
unconditional  0 never executed
        -:  561:		}
        -:  562:
        -:  563:		/* Asterisk */
        1:  564:		else if (strcmp(rm_elements[i], "*") == 0) {
        1:  564-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:  565:			size_t j;
    #####:  566:			for (j = 0; j < (size_t)files_n; j++) {
    %%%%%:  566-block  0
unconditional  0 never executed
    %%%%%:  566-block  1
branch  1 never executed
branch  2 never executed
    #####:  567:				snprintf(rm_file, PATH_MAX, "%s/%s", trash_files_dir,
    #####:  568:				    trash_files[j]->d_name);
    #####:  569:				snprintf(rm_info, PATH_MAX, "%s/%s.trashinfo",
    #####:  570:				    trash_info_dir, trash_files[j]->d_name);
        -:  571:
    #####:  572:				char *tmp_cmd[] = {"rm", "-r", rm_file, rm_info, NULL};
        -:  573:
    #####:  574:				ret = launch_execve(tmp_cmd, FOREGROUND, E_NOFLAG);
    %%%%%:  574-block  0
call    0 never executed
    #####:  575:				if (ret != EXIT_SUCCESS) {
branch  0 never executed
branch  1 never executed
    #####:  576:					fprintf(stderr, _("%s: trash: Error trashing %s\n"),
call    0 never executed
    #####:  577:					    PROGRAM_NAME, trash_files[j]->d_name);
    %%%%%:  577-block  0
call    0 never executed
    #####:  578:					exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  579:				}
        -:  580:
    #####:  581:				free(trash_files[j]);
    %%%%%:  581-block  0
unconditional  0 never executed
        -:  582:			}
        -:  583:
    #####:  584:			free(trash_files);
        -:  585:
    #####:  586:			for (j = 0; rm_elements[j]; j++)
    %%%%%:  586-block  0
unconditional  0 never executed
    %%%%%:  586-block  1
branch  1 never executed
branch  2 never executed
    #####:  587:				free(rm_elements[j]);
    %%%%%:  587-block  0
unconditional  0 never executed
        -:  588:
    #####:  589:			free(rm_elements);
        -:  590:
    #####:  591:			return exit_status;
    %%%%%:  591-block  0
unconditional  0 never executed
        -:  592:		}
        -:  593:
        1:  594:		else if (!is_number(rm_elements[i])) {
        1:  594-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -:  595:
    #####:  596:			fprintf(stderr, _("%s: trash: %s: Invalid ELN\n"),
call    0 never executed
    #####:  597:			    PROGRAM_NAME, rm_elements[i]);
    %%%%%:  597-block  0
call    0 never executed
    #####:  598:			exit_status = EXIT_FAILURE;
        -:  599:
        -:  600:			size_t j;
    #####:  601:			for (j = 0; rm_elements[j]; j++)
unconditional  0 never executed
    %%%%%:  601-block  0
branch  1 never executed
branch  2 never executed
    #####:  602:				free(rm_elements[j]);
    %%%%%:  602-block  0
unconditional  0 never executed
    #####:  603:			free(rm_elements);
        -:  604:
    #####:  605:			for (j = 0; j < (size_t)files_n; j++)
    %%%%%:  605-block  0
unconditional  0 never executed
    %%%%%:  605-block  1
branch  1 never executed
branch  2 never executed
    #####:  606:				free(trash_files[j]);
    %%%%%:  606-block  0
unconditional  0 never executed
    #####:  607:			free(trash_files);
        -:  608:
    #####:  609:			return exit_status;
    %%%%%:  609-block  0
unconditional  0 never executed
        -:  610:		}
        -:  611:	}
        -:  612:
        -:  613:	/* If all args are numbers, and neither 'q' nor wildcard */
        2:  614:	for (i = 0; rm_elements[i]; i++) {
        1:  614-block  0
unconditional  0 taken 1
        1:  614-block  1
unconditional  1 taken 1
        2:  614-block  2
branch  2 taken 1
branch  3 taken 1 (fallthrough)
        1:  615:		int rm_num = atoi(rm_elements[i]);
        -:  616:
       1*:  617:		if (rm_num <= 0 || rm_num > files_n) {
        1:  617-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  617-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:  618:			fprintf(stderr, _("%s: trash: %d: Invalid ELN\n"),
    %%%%%:  618-block  0
call    0 never executed
call    1 never executed
        -:  619:			    PROGRAM_NAME, rm_num);
    #####:  620:			free(rm_elements[i]);
    #####:  621:			exit_status = EXIT_FAILURE;
    #####:  622:			continue;
unconditional  0 never executed
        -:  623:		}
        -:  624:
        1:  625:		snprintf(rm_file, PATH_MAX, "%s/%s", trash_files_dir,
        1:  626:		    trash_files[rm_num - 1]->d_name);
        1:  627:		snprintf(rm_info, PATH_MAX, "%s/%s.trashinfo", trash_info_dir,
        1:  628:		    trash_files[rm_num - 1]->d_name);
        -:  629:
        1:  630:		char *tmp_cmd2[] = {"rm", "-r", rm_file, rm_info, NULL};
        -:  631:
        1:  632:		ret = launch_execve(tmp_cmd2, FOREGROUND, E_NOFLAG);
        1:  632-block  0
call    0 returned 1
        1:  633:		if (ret != EXIT_SUCCESS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:  634:			fprintf(stderr, _("%s: trash: Error trashing %s\n"),
call    0 never executed
    #####:  635:			    PROGRAM_NAME, trash_files[rm_num - 1]->d_name);
    %%%%%:  635-block  0
call    0 never executed
    #####:  636:			exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  637:		}
        -:  638:
        1:  639:		free(rm_elements[i]);
        1:  639-block  0
unconditional  0 taken 1
        -:  640:	}
        -:  641:
        1:  642:	free(rm_elements);
        -:  643:
        2:  644:	for (i = 0; i < (size_t)files_n; i++)
        1:  644-block  0
unconditional  0 taken 1
        2:  644-block  1
branch  1 taken 1
branch  2 taken 1 (fallthrough)
        1:  645:		free(trash_files[i]);
        1:  645-block  0
unconditional  0 taken 1
        1:  646:	free(trash_files);
        -:  647:
        1:  648:	return exit_status;
        1:  648-block  0
unconditional  0 taken 1
        -:  649:}
        -:  650:
        -:  651:static int
function untrash_element called 10 returned 100% blocks executed 52%
       10:  652:untrash_element(char *file)
        -:  653:{
       10:  654:	if (!file)
       10:  654-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####:  655:		return EXIT_FAILURE;
    %%%%%:  655-block  0
unconditional  0 never executed
        -:  656:
        -:  657:	char undel_file[PATH_MAX], undel_info[PATH_MAX];
       10:  658:	snprintf(undel_file, PATH_MAX, "%s/%s", trash_files_dir, file);
       10:  659:	snprintf(undel_info, PATH_MAX, "%s/%s.trashinfo", trash_info_dir,
        -:  660:	    file);
        -:  661:
        -:  662:	FILE *info_fp;
       10:  663:	info_fp = fopen(undel_info, "r");
       10:  663-block  0
call    0 returned 10
       10:  664:	if (!info_fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####:  665:		fprintf(stderr, _("%s: undel: Info file for '%s' not found. "
    %%%%%:  665-block  0
call    0 never executed
call    1 never executed
        -:  666:				"Try restoring the file manually\n"), PROGRAM_NAME, file);
    #####:  667:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  668:	}
        -:  669:
       10:  670:	char *orig_path = (char *)NULL;
        -:  671:	/* The max length for line is Path=(5) + PATH_MAX + \n(1) */
        -:  672:	char line[PATH_MAX + 6];
       10:  673:	memset(line, '\0', PATH_MAX + 6);
        -:  674:
       40:  675:	while (fgets(line, (int)sizeof(line), info_fp)) {
       10:  675-block  0
unconditional  0 taken 10
       40:  675-block  1
call    1 returned 40
branch  2 taken 30
branch  3 taken 10 (fallthrough)
       30:  676:		if (strncmp(line, "Path=", 5) == 0)
       30:  676-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 20
       10:  677:			orig_path = straft(line, '=');
       10:  677-block  0
call    0 returned 10
unconditional  1 taken 10
        -:  678:	}
        -:  679:
       10:  680:	fclose(info_fp);
       10:  680-block  0
call    0 returned 10
        -:  681:
        -:  682:	/* If original path is NULL or empty, return error */
       10:  683:	if (!orig_path)
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####:  684:		return EXIT_FAILURE;
    %%%%%:  684-block  0
unconditional  0 never executed
        -:  685:
       10:  686:	if (*orig_path == '\0') {
       10:  686-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####:  687:		free(orig_path);
    #####:  688:		return EXIT_FAILURE;
    %%%%%:  688-block  0
unconditional  0 never executed
        -:  689:	}
        -:  690:
        -:  691:	/* Remove new line char from original path, if any */
       10:  692:	size_t orig_path_len = strlen(orig_path);
       10:  693:	if (orig_path[orig_path_len - 1] == '\n')
       10:  693-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 0
       10:  694:		orig_path[orig_path_len - 1] = '\0';
       10:  694-block  0
unconditional  0 taken 10
        -:  695:
        -:  696:	/* Decode original path's URL format */
       10:  697:	char *url_decoded = url_decode(orig_path);
       10:  697-block  0
call    0 returned 10
        -:  698:
       10:  699:	if (!url_decoded) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####:  700:		fprintf(stderr, _("%s: undel: %s: Failed decoding path\n"),
    %%%%%:  700-block  0
call    0 never executed
call    1 never executed
        -:  701:		    PROGRAM_NAME, orig_path);
    #####:  702:		free(orig_path);
    #####:  703:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  704:	}
        -:  705:
       10:  706:	free(orig_path);
       10:  707:	orig_path = (char *)NULL;
        -:  708:
        -:  709:	/* Check existence and permissions of parent directory */
       10:  710:	char *parent = (char *)NULL;
       10:  711:	parent = strbfrlst(url_decoded, '/');
       10:  711-block  0
call    0 returned 10
        -:  712:
       10:  713:	if (!parent) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10
        -:  714:		/* strbfrlst() returns NULL is file's parent is root (simply
        -:  715:		 * because there's nothing before last slash in this case).
        -:  716:		 * So, check if file's parent is root. Else returns */
    #####:  717:		if (url_decoded[0] == '/' && strcntchr(url_decoded + 1, '/') == -1) {
    %%%%%:  717-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  717-block  1
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  718:			parent = (char *)xnmalloc(2, sizeof(char));
    %%%%%:  718-block  0
call    0 never executed
    #####:  719:			parent[0] = '/';
    #####:  720:			parent[1] = '\0';
unconditional  0 never executed
        -:  721:		} else {
    #####:  722:			free(url_decoded);
    #####:  723:			return EXIT_FAILURE;
    %%%%%:  723-block  0
unconditional  0 never executed
        -:  724:		}
        -:  725:	}
        -:  726:
       10:  727:	if (access(parent, F_OK) != 0) {
       10:  727-block  0
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
    #####:  728:		fprintf(stderr, _("%s: undel: %s: No such file or directory\n"),
    %%%%%:  728-block  0
call    0 never executed
call    1 never executed
        -:  729:				PROGRAM_NAME, parent);
    #####:  730:		free(parent);
    #####:  731:		free(url_decoded);
    #####:  732:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  733:	}
        -:  734:
       10:  735:	if (access(parent, X_OK | W_OK) != 0) {
       10:  735-block  0
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
    #####:  736:		fprintf(stderr, _("%s: undel: %s: Permission denied\n"),
    %%%%%:  736-block  0
call    0 never executed
call    1 never executed
        -:  737:				PROGRAM_NAME, parent);
    #####:  738:		free(parent);
    #####:  739:		free(url_decoded);
    #####:  740:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  741:	}
        -:  742:
       10:  743:	free(parent);
        -:  744:
       10:  745:	char *tmp_cmd[] = {"cp", "-a", undel_file, url_decoded, NULL};
       10:  746:	int ret = -1;
       10:  747:	ret = launch_execve(tmp_cmd, FOREGROUND, E_NOFLAG);
       10:  747-block  0
call    0 returned 10
       10:  748:	free(url_decoded);
        -:  749:
       10:  750:	if (ret == EXIT_SUCCESS) {
branch  0 taken 10 (fallthrough)
branch  1 taken 0
       10:  751:		char *tmp_cmd2[] = {"rm", "-r", undel_file, undel_info, NULL};
       10:  752:		ret = launch_execve(tmp_cmd2, FOREGROUND, E_NOFLAG);
       10:  752-block  0
call    0 returned 10
        -:  753:
       10:  754:		if (ret != EXIT_SUCCESS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    #####:  755:			fprintf(stderr, _("%s: undel: %s: Failed removing info file\n"),
    %%%%%:  755-block  0
call    0 never executed
call    1 never executed
        -:  756:					PROGRAM_NAME, undel_info);
    #####:  757:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  758:		} else {
       10:  759:			return EXIT_SUCCESS;
       10:  759-block  0
unconditional  0 taken 10
        -:  760:		}
        -:  761:	} else {
    #####:  762:		fprintf(stderr, _("%s: undel: %s: Failed restoring trashed file\n"),
    %%%%%:  762-block  0
call    0 never executed
call    1 never executed
        -:  763:				PROGRAM_NAME, undel_file);
    #####:  764:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  765:	}
        -:  766:
        -:  767:	return EXIT_FAILURE; /* Never reached */
        -:  768:}
        -:  769:
        -:  770:int
function untrash_function called 4 returned 100% blocks executed 54%
        4:  771:untrash_function(char **comm)
        -:  772:{
        4:  773:	if (xargs.stealth_mode == 1) {
        4:  773-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:  774:		printf("%s: The trash function is disabled in stealth mode\n",
    %%%%%:  774-block  0
call    0 never executed
        -:  775:		    PROGRAM_NAME);
    #####:  776:		return EXIT_SUCCESS;
unconditional  0 never executed
        -:  777:	}
        -:  778:
        4:  779:	if (!comm)
        4:  779-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:  780:		return EXIT_FAILURE;
    %%%%%:  780-block  0
unconditional  0 never executed
        -:  781:
        4:  782:	if (!trash_ok) {
        4:  782-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:  783:		fprintf(stderr, _("%s: Trash function disabled\n"), PROGRAM_NAME);
    %%%%%:  783-block  0
call    0 never executed
call    1 never executed
    #####:  784:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  785:	}
        -:  786:
        -:  787:	/* Change CWD to the trash directory to make scandir() work */
        4:  788:	if (xchdir(trash_files_dir, NO_TITLE) == -1) {
        4:  788-block  0
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
    #####:  789:		_err(0, NOPRINT_PROMPT, "%s: undel: '%s': %s\n", PROGRAM_NAME,
call    0 never executed
    #####:  790:		    trash_files_dir, strerror(errno));
    %%%%%:  790-block  0
call    0 never executed
    #####:  791:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  792:	}
        -:  793:
        -:  794:	/* Get trashed files */
        4:  795:	struct dirent **trash_files = (struct dirent **)NULL;
       4*:  796:	int trash_files_n = scandir(trash_files_dir, &trash_files,
    %%%%%:  796-block  0
unconditional  0 never executed
    %%%%%:  796-block  1
unconditional  1 never executed
    %%%%%:  796-block  2
unconditional  2 never executed
        4:  796-block  3
unconditional  3 taken 4
        4:  796-block  4
call    4 returned 4
       4*:  797:	    skip_files, (unicode) ? alphasort : (case_sensitive) ? xalphasort
        4:  797-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    %%%%%:  797-block  1
branch  2 never executed
branch  3 never executed
        -:  798:					 : alphasort_insensitive);
        4:  799:	if (trash_files_n <= 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:  800:		puts(_("trash: There are no trashed files"));
    %%%%%:  800-block  0
call    0 never executed
call    1 never executed
        -:  801:
    #####:  802:		if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  803:			_err(0, NOPRINT_PROMPT, "%s: undel: '%s': %s\n",
    #####:  804:			    PROGRAM_NAME, ws[cur_ws].path, strerror(errno));
    %%%%%:  804-block  0
call    0 never executed
call    1 never executed
    #####:  805:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  806:		}
        -:  807:
    #####:  808:		return EXIT_SUCCESS;
    %%%%%:  808-block  0
unconditional  0 never executed
        -:  809:	}
        -:  810:
        4:  811:	int exit_status = EXIT_SUCCESS;
        -:  812:	/* if "undel all" (or "u a" or "u *") */
       4*:  813:	if (comm[1] && (strcmp(comm[1], "*") == 0 || strcmp(comm[1], "a") == 0
        4:  813-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  813-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    %%%%%:  813-block  2
branch  4 never executed
branch  5 never executed
    #####:  814:	|| strcmp(comm[1], "all") == 0)) {
    %%%%%:  814-block  0
branch  0 never executed
branch  1 never executed
        -:  815:		size_t j;
       10:  816:		for (j = 0; j < (size_t)trash_files_n; j++) {
        2:  816-block  0
unconditional  0 taken 2
       10:  816-block  1
branch  1 taken 8
branch  2 taken 2 (fallthrough)
        8:  817:			if (untrash_element(trash_files[j]->d_name) != 0)
        8:  817-block  0
call    0 returned 8
branch  1 taken 0 (fallthrough)
branch  2 taken 8
    #####:  818:				exit_status = EXIT_FAILURE;
    %%%%%:  818-block  0
unconditional  0 never executed
        -:  819:
        8:  820:			free(trash_files[j]);
        8:  820-block  0
unconditional  0 taken 8
        -:  821:		}
        -:  822:
        2:  823:		free(trash_files);
        -:  824:
        2:  825:		if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
        2:  825-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  826:			_err(0, NOPRINT_PROMPT, "%s: undel: '%s': %s\n",
    #####:  827:			    PROGRAM_NAME, ws[cur_ws].path, strerror(errno));
    %%%%%:  827-block  0
call    0 never executed
call    1 never executed
    #####:  828:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  829:		}
        -:  830:
        2:  831:		return exit_status;
        2:  831-block  0
unconditional  0 taken 2
        -:  832:	}
        -:  833:
        -:  834:	/* List trashed files */
        2:  835:	printf(_("%sTrashed files%s\n\n"), BOLD, df_c);
        2:  835-block  0
call    0 returned 2
call    1 returned 2
        -:  836:	size_t i;
        -:  837:
        4:  838:	for (i = 0; i < (size_t)trash_files_n; i++)
unconditional  0 taken 2
unconditional  1 taken 2
        4:  838-block  0
branch  2 taken 2
branch  3 taken 2 (fallthrough)
        2:  839:		colors_list(trash_files[i]->d_name, (int)i + 1, NO_PAD,
        2:  839-block  0
call    0 returned 2
        -:  840:		    PRINT_NEWLINE);
        -:  841:
        -:  842:	/* Go back to previous path */
        2:  843:	if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
        2:  843-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  844:		_err(0, NOPRINT_PROMPT, "%s: undel: '%s': %s\n", PROGRAM_NAME,
    #####:  845:		    ws[cur_ws].path, strerror(errno));
    %%%%%:  845-block  0
call    0 never executed
call    1 never executed
    #####:  846:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  847:	}
        -:  848:
        -:  849:	/* Get user input */
        2:  850:	printf(_("\n%sEnter 'q' to quit.\n"), df_c);
        2:  850-block  0
call    0 returned 2
call    1 returned 2
        2:  851:	int undel_n = 0;
        2:  852:	char *line = (char *)NULL, **undel_elements = (char **)NULL;
        4:  853:	while (!line)
unconditional  0 taken 2
        4:  853-block  0
branch  1 taken 2
branch  2 taken 2 (fallthrough)
        2:  854:		line = rl_no_hist(_("File(s) to be undeleted (ex: 1 2-6, or *): "));
        2:  854-block  0
call    0 returned 2
call    1 returned 2
unconditional  2 taken 2
        -:  855:
        2:  856:	undel_elements = get_substr(line, ' ');
        2:  856-block  0
call    0 returned 2
        2:  857:	free(line);
        2:  858:	line = (char *)NULL;
        2:  859:	if (undel_elements) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        4:  860:		for (i = 0; undel_elements[i]; i++)
        2:  860-block  0
unconditional  0 taken 2
        4:  860-block  1
branch  1 taken 2
branch  2 taken 2
        2:  861:			undel_n++;
        2:  861-block  0
unconditional  0 taken 2
        -:  862:	} else {
    #####:  863:		return EXIT_FAILURE;
    %%%%%:  863-block  0
unconditional  0 never executed
        -:  864:	}
        -:  865:
        -:  866:	/* First check for quit, *, and non-number args */
        2:  867:	int free_and_return = 0;
        -:  868:
        4:  869:	for (i = 0; i < (size_t)undel_n; i++) {
        2:  869-block  0
unconditional  0 taken 2
        2:  869-block  1
unconditional  1 taken 2
        4:  869-block  2
branch  2 taken 2
branch  3 taken 2 (fallthrough)
        2:  870:		if (strcmp(undel_elements[i], "q") == 0) {
        2:  870-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  871:			free_and_return = 1;
    %%%%%:  871-block  0
unconditional  0 never executed
        2:  872:		} else if (strcmp(undel_elements[i], "*") == 0) {
        2:  872-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:  873:			size_t j;
        -:  874:
    #####:  875:			for (j = 0; j < (size_t)trash_files_n; j++)
    %%%%%:  875-block  0
unconditional  0 never executed
    %%%%%:  875-block  1
unconditional  1 never executed
    %%%%%:  875-block  2
branch  2 never executed
branch  3 never executed
    #####:  876:				if (untrash_element(trash_files[j]->d_name) != 0)
    %%%%%:  876-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  877:					exit_status = EXIT_FAILURE;
    %%%%%:  877-block  0
unconditional  0 never executed
        -:  878:
    #####:  879:			free_and_return = 1;
    %%%%%:  879-block  0
unconditional  0 never executed
        2:  880:		} else if (!is_number(undel_elements[i])) {
        2:  880-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  881:			fprintf(stderr, _("undel: %s: Invalid ELN\n"), undel_elements[i]);
    %%%%%:  881-block  0
call    0 never executed
call    1 never executed
    #####:  882:			exit_status = EXIT_FAILURE;
    #####:  883:			free_and_return = 1;
unconditional  0 never executed
        -:  884:		}
        -:  885:	}
        -:  886:
        -:  887:	/* Free and return if any of the above conditions is true */
        2:  888:	if (free_and_return) {
        2:  888-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  889:		size_t j = 0;
    #####:  890:		for (j = 0; j < (size_t)undel_n; j++)
    %%%%%:  890-block  0
unconditional  0 never executed
    %%%%%:  890-block  1
branch  1 never executed
branch  2 never executed
    #####:  891:			free(undel_elements[j]);
    %%%%%:  891-block  0
unconditional  0 never executed
    #####:  892:		free(undel_elements);
        -:  893:
    #####:  894:		for (j = 0; j < (size_t)trash_files_n; j++)
    %%%%%:  894-block  0
unconditional  0 never executed
    %%%%%:  894-block  1
branch  1 never executed
branch  2 never executed
    #####:  895:			free(trash_files[j]);
    %%%%%:  895-block  0
unconditional  0 never executed
    #####:  896:		free(trash_files);
        -:  897:
    #####:  898:		return exit_status;
    %%%%%:  898-block  0
unconditional  0 never executed
        -:  899:	}
        -:  900:
        -:  901:	/* Undelete trashed files */
        4:  902:	for (i = 0; i < (size_t)undel_n; i++) {
        2:  902-block  0
unconditional  0 taken 2
        2:  902-block  1
unconditional  1 taken 2
        4:  902-block  2
branch  2 taken 2
branch  3 taken 2 (fallthrough)
        2:  903:		int undel_num = atoi(undel_elements[i]);
        -:  904:
       2*:  905:		if (undel_num <= 0 || undel_num > trash_files_n) {
        2:  905-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  905-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####:  906:			fprintf(stderr, _("%s: undel: %d: Invalid ELN\n"),
    %%%%%:  906-block  0
call    0 never executed
call    1 never executed
        -:  907:					PROGRAM_NAME, undel_num);
    #####:  908:			free(undel_elements[i]);
    #####:  909:			continue;
unconditional  0 never executed
        -:  910:		}
        -:  911:
        -:  912:		/* If valid ELN */
        2:  913:		if (untrash_element(trash_files[undel_num - 1]->d_name) != 0)
        2:  913-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  914:			exit_status = EXIT_FAILURE;
    %%%%%:  914-block  0
unconditional  0 never executed
        2:  915:		free(undel_elements[i]);
        2:  915-block  0
unconditional  0 taken 2
        -:  916:	}
        -:  917:
        2:  918:	free(undel_elements);
        -:  919:
        -:  920:	/* Free trashed files list */
        4:  921:	for (i = 0; i < (size_t)trash_files_n; i++)
        2:  921-block  0
unconditional  0 taken 2
        4:  921-block  1
branch  1 taken 2
branch  2 taken 2 (fallthrough)
        2:  922:		free(trash_files[i]);
        2:  922-block  0
unconditional  0 taken 2
        2:  923:	free(trash_files);
        -:  924:
        -:  925:	/* If some trashed file still remains, reload the undel screen */
        2:  926:	trash_n = count_dir(trash_files_dir, NO_CPOP);
        2:  926-block  0
call    0 returned 2
        -:  927:
        2:  928:	if (trash_n <= 2)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  929:		trash_n = 0;
        2:  929-block  0
unconditional  0 taken 2
        -:  930:
        2:  931:	if (trash_n)
        2:  931-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  932:		untrash_function(comm);
    %%%%%:  932-block  0
call    0 never executed
unconditional  1 never executed
        -:  933:
        2:  934:	return exit_status;
        2:  934-block  0
unconditional  0 taken 2
        -:  935:}
        -:  936:
        -:  937:int
function trash_function called 8 returned 100% blocks executed 56%
        8:  938:trash_function(char **comm)
        -:  939:{
        8:  940:	if (xargs.stealth_mode == 1) {
        8:  940-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####:  941:		printf("%s: The trash function is disabled in "
    %%%%%:  941-block  0
call    0 never executed
        -:  942:			"stealth mode\n", PROGRAM_NAME);
    #####:  943:		return EXIT_SUCCESS;
unconditional  0 never executed
        -:  944:	}
        -:  945:
        -:  946:	/* Create trash dirs, if necessary */
        -:  947:	/*  struct stat file_attrib;
        -:  948:	if (stat (trash_dir, &file_attrib) == -1) {
        -:  949:		char *trash_files = NULL;
        -:  950:		trash_files = xcalloc(strlen(trash_dir) + 7, sizeof(char));
        -:  951:		sprintf(trash_files, "%s/files", trash_dir);
        -:  952:		char *trash_info=NULL;
        -:  953:		trash_info = xcalloc(strlen(trash_dir) + 6, sizeof(char));
        -:  954:		sprintf(trash_info, "%s/info", trash_dir);
        -:  955:		char *cmd[] = { "mkdir", "-p", trash_files, trash_info, NULL };
        -:  956:		int ret = launch_execve (cmd, FOREGROUND, E_NOFLAG);
        -:  957:		free(trash_files);
        -:  958:		free(trash_info);
        -:  959:		if (ret != EXIT_SUCCESS) {
        -:  960:			_err(0, NOPRINT_PROMPT, _("%s: mkdir: '%s': Error creating "
        -:  961:				 "trash directory\n"), PROGRAM_NAME, trash_dir);
        -:  962:			return;
        -:  963:		}
        -:  964:	} */
        -:  965:
        8:  966:	if (!comm)
        8:  966-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####:  967:		return EXIT_FAILURE;
    %%%%%:  967-block  0
unconditional  0 never executed
        -:  968:
        8:  969:	if (!trash_ok || !config_ok) {
        8:  969-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:  969-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 8
    #####:  970:		fprintf(stderr, _("%s: Trash function disabled\n"), PROGRAM_NAME);
    %%%%%:  970-block  0
call    0 never executed
call    1 never executed
    #####:  971:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  972:	}
        -:  973:
        -:  974:	/* List trashed files ('tr' or 'tr ls') */
        8:  975:	if (!comm[1] || strcmp(comm[1], "ls") == 0 || strcmp(comm[1], "list") == 0) {
        8:  975-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 1
        7:  975-block  1
branch  2 taken 6 (fallthrough)
branch  3 taken 1
        6:  975-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 6
        -:  976:		/* List files in the Trash/files dir */
        2:  977:		if (xchdir(trash_files_dir, NO_TITLE) == -1) {
        2:  977-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  978:			_err(0, NOPRINT_PROMPT, "%s: trash: %s: %s\n",
call    0 never executed
    #####:  979:			    PROGRAM_NAME, trash_files_dir, strerror(errno));
    %%%%%:  979-block  0
call    0 never executed
    #####:  980:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  981:		}
        -:  982:
        2:  983:		struct dirent **trash_files = (struct dirent **)NULL;
       2*:  984:		int files_n = scandir(trash_files_dir, &trash_files,
    %%%%%:  984-block  0
unconditional  0 never executed
    %%%%%:  984-block  1
unconditional  1 never executed
    %%%%%:  984-block  2
unconditional  2 never executed
        2:  984-block  3
unconditional  3 taken 2
        2:  984-block  4
call    4 returned 2
        2:  985:						skip_files, (unicode) ? alphasort : (case_sensitive)
        2:  985-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  986:						? xalphasort : alphasort_insensitive);
    %%%%%:  986-block  0
branch  0 never executed
branch  1 never executed
        2:  987:		if (files_n) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -:  988:			size_t i;
       10:  989:			for (i = 0; i < (size_t)files_n; i++) {
        2:  989-block  0
unconditional  0 taken 2
       10:  989-block  1
branch  1 taken 8
branch  2 taken 2 (fallthrough)
        8:  990:				colors_list(trash_files[i]->d_name, (int)i + 1, NO_PAD,
        8:  990-block  0
call    0 returned 8
        -:  991:							PRINT_NEWLINE);
        8:  992:				free(trash_files[i]);
unconditional  0 taken 8
        -:  993:			}
        -:  994:
        2:  995:			free(trash_files);
        2:  995-block  0
unconditional  0 taken 2
        -:  996:		} else {
    #####:  997:			puts(_("trash: There are no trashed files"));
    %%%%%:  997-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  998:		}
        -:  999:
        2: 1000:		if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
        2: 1000-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####: 1001:			_err(0, NOPRINT_PROMPT, "%s: trash: '%s': %s\n",
    #####: 1002:			    PROGRAM_NAME, ws[cur_ws].path, strerror(errno));
    %%%%%: 1002-block  0
call    0 never executed
call    1 never executed
    #####: 1003:			return EXIT_FAILURE;
unconditional  0 never executed
        -: 1004:		} else {
        2: 1005:			return EXIT_SUCCESS;
        2: 1005-block  0
unconditional  0 taken 2
        -: 1006:		}
        -: 1007:	}
        -: 1008:
        -: 1009:	else {
        -: 1010:		/* Create suffix from current date and time to create unique
        -: 1011:		 * file names for trashed files */
        6: 1012:		int exit_status = EXIT_SUCCESS;
        6: 1013:		time_t rawtime = time(NULL);
        6: 1013-block  0
call    0 returned 6
        -: 1014:		struct tm tm;
        6: 1015:		localtime_r(&rawtime, &tm);
call    0 returned 6
        6: 1016:		char date[64] = "";
        -: 1017:
        6: 1018:		strftime(date, sizeof(date), "%b %d %H:%M:%S %Y", &tm);
        -: 1019:
        6: 1020:		char suffix[68] = "";
        -: 1021:
        6: 1022:		snprintf(suffix, 67, "%d%d%d%d%d%d", tm.tm_year + 1900,
        6: 1023:		    tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min,
        -: 1024:		    tm.tm_sec);
        -: 1025:
        -: 1026:		/* Remove file(s) from Trash */
        6: 1027:		if (strcmp(comm[1], "del") == 0 || strcmp(comm[1], "rm") == 0) {
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        5: 1027-block  0
branch  2 taken 0 (fallthrough)
branch  3 taken 5
        1: 1028:			exit_status = remove_from_trash();
        1: 1028-block  0
call    0 returned 1
unconditional  1 taken 1
        5: 1029:		} else if (strcmp(comm[1], "clear") == 0) {
        5: 1029-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 1030:			trash_clear();
    %%%%%: 1030-block  0
call    0 never executed
unconditional  1 never executed
        -: 1031:		} else {
        -: 1032:			/* Trash files passed as arguments */
        -: 1033:			size_t i;
       16: 1034:			for (i = 1; comm[i]; i++) {
        5: 1034-block  0
unconditional  0 taken 5
       11: 1034-block  1
unconditional  1 taken 11
       16: 1034-block  2
branch  2 taken 11
branch  3 taken 5 (fallthrough)
       11: 1035:				char *deq_file = dequote_str(comm[i], 0);
       11: 1035-block  0
call    0 returned 11
       11: 1036:				char tmp_comm[PATH_MAX] = "";
        -: 1037:
       11: 1038:				if (deq_file[0] == '/') { /* If absolute path */
branch  0 taken 4 (fallthrough)
branch  1 taken 7
        4: 1039:					strcpy(tmp_comm, deq_file);
        4: 1039-block  0
unconditional  0 taken 4
        -: 1040:				} else { /* If relative path, add path to check against
        -: 1041:					TRASH_DIR */
        7: 1042:					snprintf(tmp_comm, PATH_MAX, "%s/%s", ws[cur_ws].path,
        7: 1042-block  0
unconditional  0 taken 7
        -: 1043:					    deq_file);
        -: 1044:				}
        -: 1045:
        -: 1046:				/* Some filters: you cannot trash wathever you want */
        -: 1047:				/* Do not trash any of the parent directories of TRASH_DIR,
        -: 1048:				 * that is, /, /home, ~/, ~/.local, ~/.local/share */
      11*: 1049:				if (strncmp(tmp_comm, trash_dir, strlen(tmp_comm)) == 0) {
       11: 1049-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 1050:					fprintf(stderr, _("trash: Cannot trash '%s'\n"), tmp_comm);
    %%%%%: 1050-block  0
call    0 never executed
call    1 never executed
    #####: 1051:					exit_status = EXIT_FAILURE;
    #####: 1052:					free(deq_file);
    #####: 1053:					continue;
unconditional  0 never executed
    %%%%%: 1053-block  0
unconditional  1 never executed
      11*: 1054:				} else if (strncmp(tmp_comm, trash_dir, strlen(trash_dir)) == 0) {
       11: 1054-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
        -: 1055:				/* Do no trash TRASH_DIR itself nor anything inside it,
        -: 1056:				 * that is, already trashed files */
    #####: 1057:					puts(_("trash: Use 'trash del' to remove trashed files"));
    %%%%%: 1057-block  0
call    0 never executed
call    1 never executed
    #####: 1058:					exit_status = EXIT_FAILURE;
    #####: 1059:					free(deq_file);
    #####: 1060:					continue;
unconditional  0 never executed
        -: 1061:				}
        -: 1062:
        -: 1063:				struct stat file_attrib;
      11*: 1064:				if (lstat(deq_file, &file_attrib) == -1) {
       11: 1064-block  0
call    0 returned 11
branch  1 taken 0 (fallthrough)
branch  2 taken 11
    #####: 1065:					fprintf(stderr, _("trash: %s: %s\n"), deq_file,
call    0 never executed
call    1 never executed
    #####: 1066:					    strerror(errno));
    %%%%%: 1066-block  0
call    0 never executed
    #####: 1067:					exit_status = EXIT_FAILURE;
    #####: 1068:					free(deq_file);
    #####: 1069:					continue;
unconditional  0 never executed
        -: 1070:				} else {
        -: 1071:				/* Do not trash block or character devices */
      11*: 1072:					if ((file_attrib.st_mode & S_IFMT) == S_IFBLK) {
       11: 1072-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 1073:						fprintf(stderr, _("trash: %s: Cannot trash a "
    %%%%%: 1073-block  0
call    0 never executed
call    1 never executed
        -: 1074:								"block device\n"), deq_file);
    #####: 1075:						exit_status = EXIT_FAILURE;
    #####: 1076:						free(deq_file);
    #####: 1077:						continue;
unconditional  0 never executed
      11*: 1078:					} else if ((file_attrib.st_mode & S_IFMT) == S_IFCHR) {
       11: 1078-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 11
    #####: 1079:						fprintf(stderr, _("trash: %s: Cannot trash a "
    %%%%%: 1079-block  0
call    0 never executed
call    1 never executed
        -: 1080:								"character device\n"), deq_file);
    #####: 1081:						exit_status = EXIT_FAILURE;
    #####: 1082:						free(deq_file);
    #####: 1083:						continue;
unconditional  0 never executed
        -: 1084:					}
        -: 1085:				}
        -: 1086:
        -: 1087:				/* Once here, everything is fine: trash the file */
       11: 1088:				exit_status = trash_element(suffix, &tm, deq_file);
       11: 1088-block  0
call    0 returned 11
        -: 1089:				/* The trash_element() function will take care of
        -: 1090:				 * printing error messages, if any */
       11: 1091:				free(deq_file);
unconditional  0 taken 11
        -: 1092:			}
        -: 1093:		}
        -: 1094:
        6: 1095:		return exit_status;
        6: 1095-block  0
unconditional  0 taken 6
        -: 1096:	}
        -: 1097:}
        -: 1098:#endif /* !_NO_TRASH */
        -: 1099:
