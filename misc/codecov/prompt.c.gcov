        -:    0:Source:prompt.c
        -:    1:/* prompt.c -- functions controlling the appearance and behaviour of the prompt */
        -:    2:
        -:    3:/*
        -:    4: * This file is part of CliFM
        -:    5: * 
        -:    6: * Copyright (C) 2016-2021, L. Abramovich <johndoe.arch@outlook.com>
        -:    7: * All rights reserved.
        -:    8:
        -:    9: * CliFM is free software; you can redistribute it and/or modify
        -:   10: * it under the terms of the GNU General Public License as published by
        -:   11: * the Free Software Foundation; either version 2 of the License, or
        -:   12: * (at your option) any later version.
        -:   13: *
        -:   14: * CliFM is distributed in the hope that it will be useful,
        -:   15: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   16: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   17: * GNU General Public License for more details.
        -:   18: *
        -:   19: * You should have received a copy of the GNU General Public License
        -:   20: * along with this program; if not, write to the Free Software
        -:   21: * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
        -:   22: * MA 02110-1301, USA.
        -:   23:*/
        -:   24:
        -:   25:#include "helpers.h"
        -:   26:
        -:   27:#include <stdio.h>
        -:   28:#include <string.h>
        -:   29:#if !defined(__HAIKU__) && !defined(__OpenBSD__)
        -:   30:#include <wordexp.h>
        -:   31:#endif
        -:   32:#include <readline/readline.h>
        -:   33:
        -:   34:#include "aux.h"
        -:   35:#include "exec.h"
        -:   36:#include "history.h"
        -:   37:#include "init.h"
        -:   38:#include "listing.h"
        -:   39:#include "misc.h"
        -:   40:#include "navigation.h"
        -:   41:#include "prompt.h"
        -:   42:#ifndef _NO_TRASH
        -:   43:#include "trash.h"
        -:   44:#else
        -:   45:#include <time.h>
        -:   46:#endif
        -:   47:
        -:   48:/* Decode the prompt string (encoded_prompt global variable) taken from
        -:   49: * the configuration file. Based on the decode_prompt_string function
        -:   50: * found in an old bash release (1.14.7). */
        -:   51:static char *
function decode_prompt called 509 returned 100% blocks executed 50%
      509:   52:decode_prompt(const char *line)
        -:   53:{
      509:   54:	if (!line)
      509:   54-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    #####:   55:		return (char *)NULL;
    %%%%%:   55-block  0
unconditional  0 never executed
        -:   56:
        -:   57:#define CTLESC '\001'
        -:   58:#define CTLNUL '\177'
        -:   59:
      509:   60:	char *temp = (char *)NULL, *result = (char *)NULL;
      509:   61:	size_t result_len = 0;
        -:   62:	int c;
        -:   63:
    37065:   64:	while ((c = *line++)) {
      509:   64-block  0
unconditional  0 taken 509
    37065:   64-block  1
branch  1 taken 36556
branch  2 taken 509 (fallthrough)
        -:   65:		/* We have an escape char */
    36556:   66:		if (c == '\\') {
    36556:   66-block  0
branch  0 taken 15214 (fallthrough)
branch  1 taken 21342
        -:   67:			/* Now move on to the next char */
    15214:   68:			c = *line;
    15214:   69:			switch (c) {
    15214:   69-block  0
branch  0 taken 507
branch  1 taken 3547
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 507
branch  6 taken 509
branch  7 taken 509
branch  8 taken 0
branch  9 taken 507
branch 10 taken 506
branch 11 taken 509
branch 12 taken 509
branch 13 taken 507
branch 14 taken 7096
branch 15 taken 0
branch 16 taken 1
        -:   70:
      507:   71:			case 'z': /* Exit status of last executed command */
      507:   72:				temp = (char *)xnmalloc(3, sizeof(char));
      507:   72-block  0
call    0 returned 507
      507:   73:				temp[0] = ':';
      507:   74:				temp[1] = (exit_code) ? '(' : ')';
branch  0 taken 22 (fallthrough)
branch  1 taken 485
       22:   74-block  0
unconditional  2 taken 22
      485:   74-block  1
unconditional  3 taken 485
      507:   75:				temp[2] = '\0';
      507:   76:				goto add_string;
      507:   76-block  0
unconditional  0 taken 507
        -:   77:
        -:   78:/*			case 'x': // Hex numbers
        -:   79:			{
        -:   80:				// Go back one char, so that we have "\x ... n", which
        -:   81:				// is what the get_hex_num() requires
        -:   82:				line--;
        -:   83:				// get_hex_num returns an array on integers corresponding
        -:   84:				// to the hex codes found in line up to the fisrt non-hex
        -:   85:				// expression
        -:   86:				int *hex = get_hex_num(line);
        -:   87:				int n = 0, i = 0, j;
        -:   88:				// Count how many hex expressions were found
        -:   89:				while (hex[n++] != -1);
        -:   90:				n--;
        -:   91:				// 2 + n == CTLEST + 0x00 + amount of hex numbers
        -:   92:				temp = xnmalloc(2 + (size_t)n, sizeof(char));
        -:   93:				// Construct the line: "\001hex1hex2...n0x00"
        -:   94:				temp[0] = CTLESC;
        -:   95:				for (j = 1; j < (1 + n); j++)
        -:   96:					temp[j] = (char)hex[i++];
        -:   97:				temp[1 + n] = '\0';
        -:   98:				// Set the line pointer after the first non-hex
        -:   99:				// expression to continue processing
        -:  100:				line += (i * 4);
        -:  101:				c = 0;
        -:  102:				free(hex);
        -:  103:				goto add_string;
        -:  104:			} */
        -:  105:
     3547:  106:			case 'e': /* Escape char */
     3547:  107:				temp = xnmalloc(2, sizeof(char));
     3547:  107-block  0
call    0 returned 3547
     3547:  108:				line++;
        -:  109:				/* 27 (dec) == 033 (octal) == 0x1b (hex) == \e */
     3547:  110:				temp[0] = '\033';
     3547:  111:				temp[1] = '\0';
     3547:  112:				c = 0;
     3547:  113:				goto add_string;
unconditional  0 taken 3547
        -:  114:
    #####:  115:			case '0': /* Octal char */
        -:  116:			case '1':
        -:  117:			case '2':
        -:  118:			case '3':
        -:  119:			case '4':
        -:  120:			case '5':
        -:  121:			case '6':
        -:  122:			case '7': {
        -:  123:				char octal_string[4];
        -:  124:				int n;
        -:  125:
    #####:  126:				xstrsncpy(octal_string, line, 3);
    %%%%%:  126-block  0
call    0 never executed
    #####:  127:				octal_string[3] = '\0';
        -:  128:
    #####:  129:				n = read_octal(octal_string);
call    0 never executed
    #####:  130:				temp = xnmalloc(3, sizeof(char));
call    0 never executed
        -:  131:
    #####:  132:				if (n == CTLESC || n == CTLNUL) {
branch  0 never executed
branch  1 never executed
    %%%%%:  132-block  0
branch  2 never executed
branch  3 never executed
    #####:  133:					line += 3;
    #####:  134:					temp[0] = CTLESC;
    #####:  135:					temp[1] = (char)n;
    #####:  136:					temp[2] = '\0';
    %%%%%:  136-block  0
unconditional  0 never executed
    #####:  137:				} else if (n == -1) {
    %%%%%:  137-block  0
branch  0 never executed
branch  1 never executed
    #####:  138:					temp[0] = '\\';
    #####:  139:					temp[1] = '\0';
    %%%%%:  139-block  0
unconditional  0 never executed
        -:  140:				} else {
    #####:  141:					line += 3;
    #####:  142:					temp[0] = (char)n;
    #####:  143:					temp[1] = '\0';
    %%%%%:  143-block  0
unconditional  0 never executed
        -:  144:				}
        -:  145:
    #####:  146:				c = 0;
    #####:  147:				goto add_string;
    %%%%%:  147-block  0
unconditional  0 never executed
        -:  148:			}
        -:  149:
    #####:  150:			case 'c': /* Program name */
    #####:  151:				temp = savestring(PNL, strlen(PNL));
    %%%%%:  151-block  0
call    0 never executed
    #####:  152:				goto add_string;
unconditional  0 never executed
        -:  153:
    #####:  154:			case 'P': /* Current profile name */
    #####:  155:				if (!alt_profile)
    %%%%%:  155-block  0
branch  0 never executed
branch  1 never executed
    #####:  156:					temp = savestring("default", 7);
    %%%%%:  156-block  0
call    0 never executed
unconditional  1 never executed
        -:  157:				else
    #####:  158:					temp = savestring(alt_profile, strlen(alt_profile));
    %%%%%:  158-block  0
call    0 never executed
unconditional  1 never executed
    #####:  159:				goto add_string;
    %%%%%:  159-block  0
unconditional  0 never executed
        -:  160:
      507:  161:			case 't': /* Time: 24-hour HH:MM:SS format */
        -:  162:			case 'T': /* 12-hour HH:MM:SS format */
        -:  163:			case 'A': /* 24-hour HH:MM format */
        -:  164:			case '@': /* 12-hour HH:MM:SS am/pm format */
        -:  165:			case 'd': /* Date: abrev_weak_day, abrev_month_day month_num */
        -:  166:			{
      507:  167:				time_t rawtime = time(NULL);
      507:  167-block  0
call    0 returned 507
        -:  168:				struct tm tm;
      507:  169:				localtime_r(&rawtime, &tm);
call    0 returned 507
      507:  170:				if (c == 't') {
branch  0 taken 0 (fallthrough)
branch  1 taken 507
    #####:  171:					char time[9] = "";
    #####:  172:					strftime(time, sizeof(time), "%H:%M:%S", &tm);
    #####:  173:					temp = savestring(time, sizeof(time));
    %%%%%:  173-block  0
call    0 never executed
      507:  174:				} else if (c == 'T') {
      507:  174-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 507
    #####:  175:					char time[9] = "";
    #####:  176:					strftime(time, sizeof(time), "%I:%M:%S", &tm);
    #####:  177:					temp = savestring(time, sizeof(time));
    %%%%%:  177-block  0
call    0 never executed
      507:  178:				} else if (c == 'A') {
      507:  178-block  0
branch  0 taken 507 (fallthrough)
branch  1 taken 0
      507:  179:					char time[6] = "";
      507:  180:					strftime(time, sizeof(time), "%H:%M", &tm);
      507:  181:					temp = savestring(time, sizeof(time));
      507:  181-block  0
call    0 returned 507
    #####:  182:				} else if (c == '@') {
    %%%%%:  182-block  0
branch  0 never executed
branch  1 never executed
    #####:  183:					char time[12] = "";
    #####:  184:					strftime(time, sizeof(time), "%I:%M:%S %p", &tm);
    #####:  185:					temp = savestring(time, sizeof(time));
    %%%%%:  185-block  0
call    0 never executed
        -:  186:				} else { /* c == 'd' */
    #####:  187:					char time[12] = "";
    #####:  188:					strftime(time, sizeof(time), "%a %b %d", &tm);
    #####:  189:					temp = savestring(time, sizeof(time));
    %%%%%:  189-block  0
call    0 never executed
        -:  190:				}
      507:  191:				goto add_string;
      507:  191-block  0
unconditional  0 taken 507
        -:  192:			}
        -:  193:
      509:  194:			case 'u': /* User name */
      509:  195:				if (!user.name)
      509:  195-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    #####:  196:					temp = savestring("?", 1);
    %%%%%:  196-block  0
call    0 never executed
unconditional  1 never executed
        -:  197:				else
      509:  198:					temp = savestring(user.name, strlen(user.name));
      509:  198-block  0
call    0 returned 509
unconditional  1 taken 509
      509:  199:				goto add_string;
      509:  199-block  0
unconditional  0 taken 509
        -:  200:
      509:  201:			case 'h': /* Hostname up to first '.' */
        -:  202:			case 'H': /* Full hostname */
      509:  203:				temp = savestring(hostname, strlen(hostname));
      509:  203-block  0
call    0 returned 509
      509:  204:				if (c == 'h') {
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    #####:  205:					int ret = strcntchr(hostname, '.');
    %%%%%:  205-block  0
call    0 never executed
    #####:  206:					if (ret != -1)
branch  0 never executed
branch  1 never executed
    #####:  207:						temp[ret] = '\0';
    %%%%%:  207-block  0
unconditional  0 never executed
        -:  208:				}
      509:  209:				goto add_string;
      509:  209-block  0
unconditional  0 taken 509
        -:  210:
    #####:  211:			case 's': /* Shell name (after last slash)*/
        -:  212:			{
    #####:  213:				if (!user.shell) {
    %%%%%:  213-block  0
branch  0 never executed
branch  1 never executed
    #####:  214:					line++;
    #####:  215:					break;
    %%%%%:  215-block  0
unconditional  0 never executed
        -:  216:				}
    #####:  217:				char *shell_name = strrchr(user.shell, '/');
    #####:  218:				temp = savestring(shell_name + 1, strlen(shell_name) - 1);
    %%%%%:  218-block  0
call    0 never executed
    #####:  219:				goto add_string;
unconditional  0 never executed
        -:  220:			}
        -:  221:
      507:  222:			case 'S': { /* Current workspace */
        -:  223:				char s[12];
      507:  224:				sprintf(s, "%d", cur_ws + 1);
      507:  225:				temp = savestring(s, 1);
      507:  225-block  0
call    0 returned 507
      507:  226:				goto add_string;
unconditional  0 taken 507
        -:  227:			}
        -:  228:
      506:  229:			case 'l': { /* Current mode */
        -:  230:				char s[2];
      506:  231:				s[0] = (light_mode ? 'L' : '\0');
      506:  231-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 502
        4:  231-block  1
unconditional  2 taken 4
      502:  231-block  2
unconditional  3 taken 502
      506:  232:				s[1] = '\0';
      506:  233:				temp = savestring(s, 1);
      506:  233-block  0
call    0 returned 506
      506:  234:				goto add_string;
unconditional  0 taken 506
        -:  235:			}
        -:  236:
      509:  237:			case 'p':
        -:  238:			case 'w': /* Full PWD */
        -:  239:			case 'W': /* Short PWD */
        -:  240:			{
      509:  241:				if (!ws[cur_ws].path) {
      509:  241-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    #####:  242:					line++;
    #####:  243:					break;
    %%%%%:  243-block  0
unconditional  0 never executed
        -:  244:				}
        -:  245:
        -:  246:				/* Reduce HOME to "~" */
      509:  247:				int free_tmp_path = 0;
      509:  248:				char *tmp_path = (char *)NULL;
      509:  249:				if (strncmp(ws[cur_ws].path, user.home,
      509:  249-block  0
branch  0 taken 488 (fallthrough)
branch  1 taken 21
        -:  250:					user.home_len) == 0)
      488:  251:					tmp_path = home_tilde(ws[cur_ws].path);
      488:  251-block  0
call    0 returned 488
unconditional  1 taken 488
      509:  252:				if (!tmp_path)
      509:  252-block  0
branch  0 taken 21 (fallthrough)
branch  1 taken 488
       21:  253:					tmp_path = ws[cur_ws].path;
       21:  253-block  0
unconditional  0 taken 21
        -:  254:				else
      488:  255:					free_tmp_path = 1;
      488:  255-block  0
unconditional  0 taken 488
        -:  256:
      509:  257:				if (c == 'W') {
      509:  257-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    #####:  258:					char *ret = (char *)NULL;
        -:  259:					/* If not root dir (/), get last dir name */
    #####:  260:					if (!(*tmp_path == '/' && !*(tmp_path + 1)))
    %%%%%:  260-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  260-block  1
branch  2 never executed
branch  3 never executed
    #####:  261:						ret = strrchr(tmp_path, '/');
    %%%%%:  261-block  0
unconditional  0 never executed
        -:  262:
    #####:  263:					if (!ret)
    %%%%%:  263-block  0
branch  0 never executed
branch  1 never executed
    #####:  264:						temp = savestring(tmp_path, strlen(tmp_path));
    %%%%%:  264-block  0
call    0 never executed
unconditional  1 never executed
        -:  265:					else
    #####:  266:						temp = savestring(ret + 1, strlen(ret) - 1);
    %%%%%:  266-block  0
call    0 never executed
unconditional  1 never executed
        -:  267:				}
        -:  268:
        -:  269:				/* Reduce path only if longer than max_path */
      509:  270:				else if (c == 'p') {
      509:  270-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    #####:  271:					if (strlen(tmp_path) > (size_t)max_path) {
    %%%%%:  271-block  0
branch  0 never executed
branch  1 never executed
    #####:  272:						char *ret = (char *)NULL;
    #####:  273:						ret = strrchr(tmp_path, '/');
    #####:  274:						if (!ret)
    %%%%%:  274-block  0
branch  0 never executed
branch  1 never executed
    #####:  275:							temp = savestring(tmp_path, strlen(tmp_path));
    %%%%%:  275-block  0
call    0 never executed
unconditional  1 never executed
        -:  276:						else
    #####:  277:							temp = savestring(ret + 1, strlen(ret) - 1);
    %%%%%:  277-block  0
call    0 never executed
unconditional  1 never executed
        -:  278:					} else {
    #####:  279:						temp = savestring(tmp_path, strlen(tmp_path));
    %%%%%:  279-block  0
call    0 never executed
unconditional  1 never executed
        -:  280:					}
        -:  281:				} else { /* If c == 'w' */
      509:  282:					temp = savestring(tmp_path, strlen(tmp_path));
      509:  282-block  0
call    0 returned 509
unconditional  1 taken 509
        -:  283:				}
        -:  284:
      509:  285:				if (free_tmp_path)
      509:  285-block  0
branch  0 taken 488 (fallthrough)
branch  1 taken 21
      488:  286:					free(tmp_path);
      488:  286-block  0
unconditional  0 taken 488
        -:  287:
      509:  288:				goto add_string;
      509:  288-block  0
unconditional  0 taken 509
        -:  289:			}
        -:  290:
      509:  291:			case '$': /* '$' or '#' for normal and root user */
      509:  292:				if ((flags & ROOT_USR))
      509:  292-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 508
        1:  293:					temp = savestring("#", 1);
        1:  293-block  0
call    0 returned 1
unconditional  1 taken 1
        -:  294:				else
      508:  295:					temp = savestring("$", 1);
      508:  295-block  0
call    0 returned 508
unconditional  1 taken 508
      509:  296:				goto add_string;
      509:  296-block  0
unconditional  0 taken 509
        -:  297:
      507:  298:			case 'a': /* Bell character */
        -:  299:			case 'r': /* Carriage return */
        -:  300:			case 'n': /* New line char */
      507:  301:				temp = savestring(" ", 1);
      507:  301-block  0
call    0 returned 507
      507:  302:				if (c == 'n')
branch  0 taken 507 (fallthrough)
branch  1 taken 0
      507:  303:					temp[0] = '\n';
      507:  303-block  0
unconditional  0 taken 507
    #####:  304:				else if (c == 'r')
    %%%%%:  304-block  0
branch  0 never executed
branch  1 never executed
    #####:  305:					temp[0] = '\r';
    %%%%%:  305-block  0
unconditional  0 never executed
        -:  306:				else
    #####:  307:					temp[0] = '\a';
    %%%%%:  307-block  0
unconditional  0 never executed
      507:  308:				goto add_string;
      507:  308-block  0
unconditional  0 taken 507
        -:  309:
     7096:  310:			case '[': /* Begin a sequence of non-printing characters.
        -:  311:			Mostly used to add color sequences. Ex: \[\033[1;34m\] */
        -:  312:			case ']': /* End the sequence */
     7096:  313:				temp = xnmalloc(2, sizeof(char));
     7096:  313-block  0
call    0 returned 7096
     7096:  314:				temp[0] = (c == '[') ? RL_PROMPT_START_IGNORE
branch  0 taken 3548 (fallthrough)
branch  1 taken 3548
     3548:  314-block  0
unconditional  2 taken 3548
     3548:  314-block  1
unconditional  3 taken 3548
        -:  315:						     : RL_PROMPT_END_IGNORE;
     7096:  316:				temp[1] = '\0';
     7096:  317:				goto add_string;
     7096:  317-block  0
unconditional  0 taken 7096
        -:  318:
    #####:  319:			case '\\': /* Literal backslash */
    #####:  320:				temp = savestring("\\", 1);
    %%%%%:  320-block  0
call    0 never executed
    #####:  321:				goto add_string;
unconditional  0 never executed
        -:  322:
        1:  323:			default:
        1:  324:				temp = savestring("\\ ", 2);
        1:  324-block  0
call    0 returned 1
        1:  325:				temp[1] = (char)c;
unconditional  0 taken 1
        -:  326:
    15214:  327:			add_string:
    15214:  328:				if (c)
    15214:  328-block  0
branch  0 taken 11667 (fallthrough)
branch  1 taken 3547
    11667:  329:					line++;
    11667:  329-block  0
unconditional  0 taken 11667
    15214:  330:				result_len += strlen(temp);
    15214:  331:				if (!result)
    15214:  331-block  0
branch  0 taken 507 (fallthrough)
branch  1 taken 14707
      507:  332:					result = (char *)xcalloc(result_len + 1, sizeof(char));
      507:  332-block  0
call    0 returned 507
unconditional  1 taken 507
        -:  333:				else
    14707:  334:					result = (char *)xrealloc(result, (result_len + 1) * sizeof(char));
    14707:  334-block  0
call    0 returned 14707
unconditional  1 taken 14707
    15214:  335:				strcat(result, temp);
    15214:  336:				free(temp);
    15214:  337:				break;
    15214:  337-block  0
unconditional  0 taken 15214
        -:  338:			}
        -:  339:		}
        -:  340:
        -:  341:		/* If not escape code, check for command substitution, and if not,
        -:  342:		 * just add whatever char is there */
        -:  343:		else {
        -:  344:			/* Remove non-escaped quotes */
    21342:  345:			if (c == '\'' || c == '"')
    21342:  345-block  0
branch  0 taken 21342 (fallthrough)
branch  1 taken 0
    21342:  345-block  1
branch  2 taken 1018 (fallthrough)
branch  3 taken 20324
     1018:  346:				continue;
     1018:  346-block  0
unconditional  0 taken 1018
        -:  347:
        -:  348:#if !defined(__HAIKU__) && !defined(__OpenBSD__)
        -:  349:			/* Command substitution */
   20324*:  350:			if (c == '$' && *line == '(') {
    20324:  350-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 20324
    %%%%%:  350-block  1
branch  2 never executed
branch  3 never executed
        -:  351:				/* Look for the ending parenthesis */
    #####:  352:				int tmp = strcntchr(line, ')');
    %%%%%:  352-block  0
call    0 never executed
    #####:  353:				if (tmp == -1)
branch  0 never executed
branch  1 never executed
    #####:  354:					continue;
    %%%%%:  354-block  0
unconditional  0 never executed
        -:  355:
        -:  356:				/* Copy the cmd to be substituted and pass it to wordexp */
    #####:  357:				char *tmp_str = (char *)xnmalloc(strlen(line) + 2, sizeof(char));
    %%%%%:  357-block  0
call    0 never executed
    #####:  358:				sprintf(tmp_str, "$%s", line);
        -:  359:
    #####:  360:				tmp_str[tmp + 2] = '\0';
    #####:  361:				line += tmp + 1;
        -:  362:
    #####:  363:				const char *old_value = getenv("IFS");
call    0 never executed
    #####:  364:				setenv("IFS", "", 1);
call    0 never executed
        -:  365:
        -:  366:				wordexp_t wordbuf;
    #####:  367:				if (wordexp(tmp_str, &wordbuf, 0) != EXIT_SUCCESS) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  368:					free(tmp_str);
    #####:  369:					if (old_value)
    %%%%%:  369-block  0
branch  0 never executed
branch  1 never executed
    #####:  370:						setenv("IFS", old_value, 1);
    %%%%%:  370-block  0
call    0 never executed
unconditional  1 never executed
        -:  371:					else
    #####:  372:						unsetenv("IFS");
    %%%%%:  372-block  0
call    0 never executed
unconditional  1 never executed
    #####:  373:					continue;
    %%%%%:  373-block  0
unconditional  0 never executed
        -:  374:				}
        -:  375:
    #####:  376:				if (old_value)
    %%%%%:  376-block  0
branch  0 never executed
branch  1 never executed
    #####:  377:					setenv("IFS", old_value, 1);
    %%%%%:  377-block  0
call    0 never executed
unconditional  1 never executed
        -:  378:				else
    #####:  379:					unsetenv("IFS");
    %%%%%:  379-block  0
call    0 never executed
unconditional  1 never executed
        -:  380:
    #####:  381:				free(tmp_str);
        -:  382:
    #####:  383:				if (wordbuf.we_wordc) {
    %%%%%:  383-block  0
branch  0 never executed
branch  1 never executed
        -:  384:					size_t j;
    #####:  385:					for (j = 0; j < wordbuf.we_wordc; j++) {
    %%%%%:  385-block  0
unconditional  0 never executed
    %%%%%:  385-block  1
branch  1 never executed
branch  2 never executed
        -:  386:
    #####:  387:						size_t word_len = strlen(wordbuf.we_wordv[j]);
    #####:  388:						result_len += word_len;
        -:  389:
    #####:  390:						if (!result)
    %%%%%:  390-block  0
branch  0 never executed
branch  1 never executed
    #####:  391:							result = (char *)xcalloc(result_len + 2, sizeof(char));
    %%%%%:  391-block  0
call    0 never executed
unconditional  1 never executed
        -:  392:						else
    #####:  393:							result = (char *)xrealloc(result, (result_len + 2)
    %%%%%:  393-block  0
call    0 never executed
unconditional  1 never executed
        -:  394:													* sizeof(char));
    #####:  395:						strcat(result, wordbuf.we_wordv[j]);
    %%%%%:  395-block  0
unconditional  0 never executed
        -:  396:
        -:  397:						/* If not the last word in cmd output, add an space */
        -:  398:/*						if (j < wordbuf.we_wordc - 1) {
        -:  399:							result[result_len++] = ' ';
        -:  400:							result[result_len] = '\0';
        -:  401:						} */
        -:  402:					}
        -:  403:				}
        -:  404:
    #####:  405:				wordfree(&wordbuf);
    %%%%%:  405-block  0
call    0 never executed
    #####:  406:				continue;
unconditional  0 never executed
        -:  407:			}
        -:  408:#endif /* __HAIKU__ && __OpenBSD__ */
        -:  409:
    20324:  410:			result = (char *)xrealloc(result, (result_len + 2) * sizeof(char));
    20324:  410-block  0
call    0 returned 20324
    20324:  411:			result[result_len++] = (char)c;
    20324:  412:			result[result_len] = '\0';
unconditional  0 taken 20324
        -:  413:		}
        -:  414:	}
        -:  415:
        -:  416:	/* Remove trailing new line char, if any */
      509:  417:	if (result && result[result_len - 1] == '\n')
      509:  417-block  0
branch  0 taken 509 (fallthrough)
branch  1 taken 0
      509:  417-block  1
branch  2 taken 509 (fallthrough)
branch  3 taken 0
      509:  418:		result[result_len - 1] = '\0';
      509:  418-block  0
unconditional  0 taken 509
        -:  419:
      509:  420:	return result;
      509:  420-block  0
unconditional  0 taken 509
        -:  421:}
        -:  422:
        -:  423:/* Print the prompt and return the string entered by the user (to be
        -:  424: * parsed later by parse_input_str()) */
        -:  425:char *
function prompt called 509 returned 100% blocks executed 71%
      509:  426:prompt(void)
        -:  427:{
        -:  428:	/* Make sure CWD exists; if not, go up to the parent, and so
        -:  429:	 * on */
      509:  430:	while (xchdir(ws[cur_ws].path, SET_TITLE) != EXIT_SUCCESS) {
      509:  430-block  0
unconditional  0 taken 509
      509:  430-block  1
call    1 returned 509
branch  2 taken 0
branch  3 taken 509 (fallthrough)
    #####:  431:		char *ret = strrchr(ws[cur_ws].path, '/');
    #####:  432:		if (ret && ret != ws[cur_ws].path)
    %%%%%:  432-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  432-block  1
branch  2 never executed
branch  3 never executed
    #####:  433:			*ret = '\0';
    %%%%%:  433-block  0
unconditional  0 never executed
        -:  434:		else
        -:  435:			break;
        -:  436:	}
        -:  437:
        -:  438:	/* Remove all final slash(es) from path, if any */
      509:  439:	size_t path_len = strlen(ws[cur_ws].path), i;
        -:  440:
     509*:  441:	for (i = path_len - 1; ws[cur_ws].path[i] && i > 0; i--) {
      509:  441-block  0
unconditional  0 taken 509
      509:  441-block  1
branch  1 taken 509 (fallthrough)
branch  2 taken 0
      509:  441-block  2
branch  3 taken 508
branch  4 taken 1 (fallthrough)
      508:  442:		if (ws[cur_ws].path[i] != '/')
      508:  442-block  0
branch  0 taken 508 (fallthrough)
branch  1 taken 0
      508:  443:			break;
      508:  443-block  0
unconditional  0 taken 508
        -:  444:		else
    #####:  445:			ws[cur_ws].path[i] = '\0';
    %%%%%:  445-block  0
unconditional  0 never executed
        -:  446:	}
        -:  447:
      509:  448:	if (welcome_message) {
      509:  448-block  0
branch  0 taken 13 (fallthrough)
branch  1 taken 496
       13:  449:		printf(_("%s%s > %s\n%s%s\n"), wc_c, PROGRAM_NAME, PROG_DESC,
       13:  449-block  0
call    0 returned 13
call    1 returned 13
call    2 returned 13
        -:  450:				df_c, _(HELP_MESSAGE));
       13:  451:		welcome_message = 0;
unconditional  0 taken 13
        -:  452:	}
        -:  453:
        -:  454:	/* Print the tip of the day (only for the first run) */
      509:  455:	if (tips) {
      509:  455-block  0
branch  0 taken 509 (fallthrough)
branch  1 taken 0
        -:  456:		static int first_run = 1;
      509:  457:		if (first_run) {
      509:  457-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 505
        4:  458:			print_tips(0);
        4:  458-block  0
call    0 returned 4
        4:  459:			first_run = 0;
unconditional  0 taken 4
        -:  460:		}
        -:  461:	}
        -:  462:
      509:  463:	fputs(df_c, stdout);
      509:  463-block  0
call    0 returned 509
      509:  464:	fflush(stdout);
call    0 returned 509
        -:  465:	/* Execute prompt commands, if any, and only if external commands
        -:  466:	 * are allowed */
      509:  467:	if (ext_cmd_ok && prompt_cmds_n > 0) {
branch  0 taken 505 (fallthrough)
branch  1 taken 4
      505:  467-block  0
branch  2 taken 505 (fallthrough)
branch  3 taken 0
     2015:  468:		for (i = 0; i < prompt_cmds_n; i++)
      505:  468-block  0
unconditional  0 taken 505
unconditional  1 taken 1510
     2015:  468-block  1
branch  2 taken 1510
branch  3 taken 505 (fallthrough)
     1510:  469:			launch_execle(prompt_cmds[i]);
     1510:  469-block  0
call    0 returned 1510
        -:  470:	}
        -:  471:#ifndef _NO_TRASH
        -:  472:	/* Update trash and sel file indicator on every prompt call */
      509:  473:	if (trash_ok) {
      509:  473-block  0
branch  0 taken 509 (fallthrough)
branch  1 taken 0
      509:  474:		trash_n = count_dir(trash_files_dir, NO_CPOP);
      509:  474-block  0
call    0 returned 509
      509:  475:		if (trash_n <= 2)
branch  0 taken 501 (fallthrough)
branch  1 taken 8
      501:  476:			trash_n = 0;
      501:  476-block  0
unconditional  0 taken 501
        -:  477:	}
        -:  478:#endif
      509:  479:	get_sel_files();
      509:  479-block  0
call    0 returned 509
        -:  480:
        -:  481:	/* Messages are categorized in three groups: errors, warnings, and
        -:  482:	 * notices. The kind of message should be specified by the function
        -:  483:	 * printing the message itself via a global enum: pmsg, with the
        -:  484:	 * following values: NOMSG, ERROR, WARNING, and NOTICE. */
      509:  485:	char msg_str[MAX_COLOR + 1 + 16] = "";
        -:  486:
      509:  487:	if (msgs_n) {
branch  0 taken 74 (fallthrough)
branch  1 taken 435
        -:  488:		/* Errors take precedence over warnings, and warnings over
        -:  489:		 * notices. That is to say, if there is an error message AND a
        -:  490:		 * warning message, the prompt will always display the error
        -:  491:		 * message sign: a red 'E'. */
       74:  492:		switch (pmsg) {
       74:  492-block  0
branch  0 taken 71
branch  1 taken 0
branch  2 taken 1
branch  3 taken 2
branch  4 taken 0
       71:  493:		case NOMSG:	break;
       71:  493-block  0
unconditional  0 taken 71
    #####:  494:		case ERROR:	sprintf(msg_str, "%sE%s", em_c, RL_NC); break;
    %%%%%:  494-block  0
unconditional  0 never executed
        1:  495:		case WARNING: sprintf(msg_str, "%sW%s", wm_c, RL_NC); break;
        1:  495-block  0
unconditional  0 taken 1
        2:  496:		case NOTICE: sprintf(msg_str, "%sN%s", nm_c, RL_NC); break;
        2:  496-block  0
unconditional  0 taken 2
    #####:  497:		default: break;
    %%%%%:  497-block  0
unconditional  0 never executed
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	/* Generate the prompt string */
      509:  502:	if (prompt_style == CUSTOM_PROMPT_STYLE) {
      509:  502-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
        -:  503:		/* Set environment variables with CliFM state information
        -:  504:		 * (sel files, trash, stealth mode, messages) to be handled by
        -:  505:		 * the prompt itself */
        -:  506:		char t[32];
    #####:  507:		sprintf(t, "%d", (int)sel_n);
    #####:  508:		setenv("CLIFM_STAT_SEL", t, 1);
    %%%%%:  508-block  0
call    0 never executed
    #####:  509:		sprintf(t, "%d", (int)trash_n);
    #####:  510:		setenv("CLIFM_STAT_TRASH", t, 1);
call    0 never executed
    #####:  511:		sprintf(t, "%d", (msgs_n && pmsg) ? (int)msgs_n : 0);
branch  0 never executed
branch  1 never executed
    %%%%%:  511-block  0
branch  2 never executed
branch  3 never executed
    %%%%%:  511-block  1
unconditional  4 never executed
    %%%%%:  511-block  2
unconditional  5 never executed
    #####:  512:		setenv("CLIFM_STAT_MSG", t, 1);
    %%%%%:  512-block  0
call    0 never executed
    #####:  513:		sprintf(t, "%d", cur_ws + 1);
    #####:  514:		setenv("CLIFM_STAT_WS", t, 1);
call    0 never executed
    #####:  515:		sprintf(t, "%d", exit_code);
    #####:  516:		setenv("CLIFM_STAT_EXIT", t, 1);
call    0 never executed
    #####:  517:		setenv("CLIFM_STAT_ROOT", (flags & ROOT_USR) ? "1" : "0", 1);
branch  0 never executed
branch  1 never executed
    %%%%%:  517-block  0
unconditional  2 never executed
    %%%%%:  517-block  1
unconditional  3 never executed
    %%%%%:  517-block  2
call    4 never executed
    #####:  518:		setenv("CLIFM_STAT_STEALTH", (xargs.stealth_mode == 1) ? "1" : "0", 1);
branch  0 never executed
branch  1 never executed
    %%%%%:  518-block  0
unconditional  2 never executed
    %%%%%:  518-block  1
unconditional  3 never executed
    %%%%%:  518-block  2
call    4 never executed
        -:  519:	}
        -:  520:
        -:  521:	/* First, grab and decode the prompt line of the config file (stored
        -:  522:	 * in encoded_prompt at startup) */
      509:  523:	char *decoded_prompt = decode_prompt(encoded_prompt);
      509:  523-block  0
call    0 returned 509
        -:  524:
        -:  525:	/* Emergency prompt, just in case decode_prompt fails */
      509:  526:	if (!decoded_prompt) {
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    #####:  527:		fprintf(stderr, _("%s: Error decoding prompt line. Using an "
    %%%%%:  527-block  0
call    0 never executed
call    1 never executed
        -:  528:				"emergency prompt\n"), PROGRAM_NAME);
    #####:  529:		decoded_prompt = (char *)xnmalloc(9, sizeof(char));
call    0 never executed
    #####:  530:		sprintf(decoded_prompt, "\001\x1b[0m\002> ");
unconditional  0 never executed
        -:  531:	}
        -:  532:
        -:  533:	size_t decoded_prompt_len;
        -:  534:/*	if (unicode || prompt_style == CUSTOM_PROMPT_STYLE)
        -:  535:		decoded_prompt_len = u8_xstrlen(decoded_prompt);
        -:  536:	else */
      509:  537:	decoded_prompt_len = strlen(decoded_prompt);
        -:  538:
      509:  539:	size_t prompt_length = 0;
        -:  540:
      509:  541:	if (prompt_style == DEF_PROMPT_STYLE) {
      509:  541-block  0
branch  0 taken 509 (fallthrough)
branch  1 taken 0
      509:  542:		prompt_length = (size_t)(decoded_prompt_len
     509*:  543:		+ (xargs.stealth_mode == 1 ? 16 : 0) + ((flags & ROOT_USR) ? 16 : 0)
      509:  543-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    %%%%%:  543-block  1
unconditional  2 never executed
      509:  543-block  2
unconditional  3 taken 509
      509:  544:		+ (sel_n ? 16 : 0) + (trash_n ? 16 : 0) + ((msgs_n && pmsg) ? 16 : 0)
      509:  544-block  0
branch  0 taken 53 (fallthrough)
branch  1 taken 456
       53:  544-block  1
unconditional  2 taken 53
      456:  544-block  2
unconditional  3 taken 456
      509:  544-block  3
branch  4 taken 8 (fallthrough)
branch  5 taken 501
        8:  544-block  4
unconditional  6 taken 8
      501:  544-block  5
unconditional  7 taken 501
      509:  544-block  6
branch  8 taken 74 (fallthrough)
branch  9 taken 435
       74:  544-block  7
branch 10 taken 3 (fallthrough)
branch 11 taken 71
        3:  544-block  8
unconditional 12 taken 3
      506:  544-block  9
unconditional 13 taken 506
      509:  544-block 10
unconditional 14 taken 509
        -:  545:		+ 6 + sizeof(tx_c) + 1);
        -:  546:	} else {
    #####:  547:		prompt_length = (size_t)(decoded_prompt_len + 6 + sizeof(tx_c) + 1);
    %%%%%:  547-block  0
unconditional  0 never executed
        -:  548:	}
        -:  549:
        -:  550:	/* 16 = color_b({red,green,yellow}_b)+letter (sel, trash, msg)+RL_NC;
        -:  551:	 * 6 = RL_NC
        -:  552:	 * 1 = null terminating char */
        -:  553:
      509:  554:	char *the_prompt = (char *)xnmalloc(prompt_length, sizeof(char));
      509:  554-block  0
call    0 returned 509
        -:  555:
      509:  556:	if (prompt_style == DEF_PROMPT_STYLE) {
branch  0 taken 509 (fallthrough)
branch  1 taken 0
    4072*:  557:		snprintf(the_prompt, prompt_length, "%s%s%s%s%s%s%s%s%s%s%s",
       53:  557-block  0
unconditional  0 taken 53
      456:  557-block  1
unconditional  1 taken 456
       53:  557-block  2
unconditional  2 taken 53
      456:  557-block  3
unconditional  3 taken 456
        8:  557-block  4
unconditional  4 taken 8
      501:  557-block  5
unconditional  5 taken 501
        8:  557-block  6
unconditional  6 taken 8
      501:  557-block  7
unconditional  7 taken 501
    %%%%%:  557-block  8
unconditional  8 never executed
      509:  557-block  9
unconditional  9 taken 509
    %%%%%:  557-block 10
unconditional 10 never executed
      509:  557-block 11
unconditional 11 taken 509
        3:  557-block 12
unconditional 12 taken 3
      506:  557-block 13
unconditional 13 taken 506
        1:  557-block 14
unconditional 14 taken 1
      508:  557-block 15
unconditional 15 taken 508
      509:  557-block 16
unconditional 16 taken 509
      509:  558:			(flags & ROOT_USR) ? "\001\x1b[1;31mR\x1b[0m\002" : "",
      509:  558-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 508
     1018:  559:			(msgs_n && pmsg) ? msg_str : "", (xargs.stealth_mode == 1)
      509:  559-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
      509:  559-block  1
branch  2 taken 74 (fallthrough)
branch  3 taken 435
       74:  559-block  2
branch  4 taken 3 (fallthrough)
branch  5 taken 71
      509:  560:			? si_c : "", (xargs.stealth_mode == 1) ? "S\001\x1b[0m\002"
      509:  560-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 509
     1018:  561:			: "", (trash_n) ? ti_c : "", (trash_n) ? "T\001\x1b[0m\002" : "",
      509:  561-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 501
      509:  561-block  1
branch  2 taken 8 (fallthrough)
branch  3 taken 501
     1018:  562:			(sel_n) ? li_c : "", (sel_n) ? "*\001\x1b[0m\002" : "",
      509:  562-block  0
branch  0 taken 53 (fallthrough)
branch  1 taken 456
      509:  562-block  1
branch  2 taken 53 (fallthrough)
branch  3 taken 456
        -:  563:			decoded_prompt, RL_NC, tx_c);
        -:  564:	} else {
    #####:  565:		snprintf(the_prompt, prompt_length, "%s%s%s", decoded_prompt, RL_NC,
    %%%%%:  565-block  0
unconditional  0 never executed
        -:  566:				tx_c);
        -:  567:	}
        -:  568:
      509:  569:	free(decoded_prompt);
        -:  570:
        -:  571:	/* Print error messages, if any. 'print_errors' is set to true by
        -:  572:	 * log_msg() with the PRINT_PROMPT flag. If NOPRINT_PROMPT is
        -:  573:	 * passed instead, 'print_msg' will be false and the message will
        -:  574:	 * be printed in place by log_msg() itself, without waiting for
        -:  575:	 * the next prompt */
      509:  576:	if (print_msg && msgs_n) {
      509:  576-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 506
        3:  576-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:  577:		fputs(messages[msgs_n - 1], stderr);
        3:  577-block  0
call    0 returned 3
        3:  578:		print_msg = 0; /* Print messages only once */
unconditional  0 taken 3
        -:  579:	}
        -:  580:
      509:  581:	args_n = 0;
        -:  582:
        -:  583:	/* Restore forground color */
      509:  584:	fputs(df_c, stdout);
      509:  584-block  0
call    0 returned 509
        -:  585:	/* Print the prompt and get user input */
      509:  586:	char *input = (char *)NULL;
      509:  587:	input = readline(the_prompt);
call    0 returned 509
      509:  588:	free(the_prompt);
        -:  589:
      509:  590:	if (!input)
branch  0 taken 0 (fallthrough)
branch  1 taken 509
    #####:  591:		return (char *)NULL;
    %%%%%:  591-block  0
unconditional  0 never executed
        -:  592:
      509:  593:	if (!*input) {
      509:  593-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 508
        1:  594:		free(input);
        1:  595:		input = (char *)NULL;
        1:  596:		return (char *)NULL;
        1:  596-block  0
unconditional  0 taken 1
        -:  597:	}
        -:  598:
        -:  599:	/* Keep a literal copy of the last entered command to compose the
        -:  600:	 * commands log, if needed and enabled */
      508:  601:	if (logs_enabled) {
      508:  601-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 508
    #####:  602:		if (last_cmd)
    %%%%%:  602-block  0
branch  0 never executed
branch  1 never executed
    #####:  603:			free(last_cmd);
    %%%%%:  603-block  0
unconditional  0 never executed
    #####:  604:		last_cmd = savestring(input, strlen(input));
    %%%%%:  604-block  0
call    0 never executed
unconditional  1 never executed
        -:  605:	}
        -:  606:
        -:  607:	/* Do not record empty lines, exit, history commands, consecutively
        -:  608:	 * equal inputs, or lines starting with space */
      508:  609:	if (record_cmd(input))
      508:  609-block  0
call    0 returned 508
branch  1 taken 247 (fallthrough)
branch  2 taken 261
      247:  610:		add_to_cmdhist(input);
      247:  610-block  0
call    0 returned 247
unconditional  1 taken 247
        -:  611:
      508:  612:	return input;
      508:  612-block  0
unconditional  0 taken 508
        -:  613:}
