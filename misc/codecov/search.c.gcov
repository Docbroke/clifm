        -:    0:Source:search.c
        -:    1:/* search.c -- functions for the search system */
        -:    2:
        -:    3:/*
        -:    4: * This file is part of CliFM
        -:    5: * 
        -:    6: * Copyright (C) 2016-2021, L. Abramovich <johndoe.arch@outlook.com>
        -:    7: * All rights reserved.
        -:    8:
        -:    9: * CliFM is free software; you can redistribute it and/or modify
        -:   10: * it under the terms of the GNU General Public License as published by
        -:   11: * the Free Software Foundation; either version 2 of the License, or
        -:   12: * (at your option) any later version.
        -:   13: *
        -:   14: * CliFM is distributed in the hope that it will be useful,
        -:   15: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   16: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   17: * GNU General Public License for more details.
        -:   18: *
        -:   19: * You should have received a copy of the GNU General Public License
        -:   20: * along with this program; if not, write to the Free Software
        -:   21: * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
        -:   22: * MA 02110-1301, USA.
        -:   23:*/
        -:   24:
        -:   25:#include "helpers.h"
        -:   26:
        -:   27:#include <dirent.h>
        -:   28:#include <errno.h>
        -:   29:#include <fcntl.h>
        -:   30:#include <regex.h>
        -:   31:#include <stdio.h>
        -:   32:#include <string.h>
        -:   33:#include <sys/ioctl.h>
        -:   34:#include <sys/stat.h>
        -:   35:#include <unistd.h>
        -:   36:
        -:   37:#include "aux.h"
        -:   38:#include "checks.h"
        -:   39:#include "colors.h"
        -:   40:#include "exec.h"
        -:   41:#include "glob.h"
        -:   42:#include "navigation.h"
        -:   43:#include "sort.h"
        -:   44:
        -:   45:/* List matching file names in the specified directory */
        -:   46:int
function search_glob called 5 returned 100% blocks executed 50%
        5:   47:search_glob(char **comm, int invert)
        -:   48:{
        5:   49:	if (!comm || !comm[0])
        5:   49-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5:   49-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 5
    #####:   50:		return EXIT_FAILURE;
    %%%%%:   50-block  0
unconditional  0 never executed
        -:   51:
        5:   52:	char *search_str = (char *)NULL,
        5:   53:		 *search_path = (char *)NULL;
        -:   54:
        5:   55:	mode_t file_type = 0;
        -:   56:	struct stat file_attrib;
        -:   57:
        -:   58:	/* If there are two arguments, the one starting with '-' is the
        -:   59:	 * file type and the other is the path */
        5:   60:	if (comm[1] && comm[2]) {
        5:   60-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2:   60-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        -:   61:
        1:   62:		if (comm[1][0] == '-') {
        1:   62-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   63:			file_type = (mode_t)comm[1][1];
        1:   64:			search_path = comm[2];
        1:   64-block  0
unconditional  0 taken 1
        -:   65:		}
        -:   66:
    #####:   67:		else if (comm[2][0] == '-') {
    %%%%%:   67-block  0
branch  0 never executed
branch  1 never executed
    #####:   68:			file_type = (mode_t)comm[2][1];
    #####:   69:			search_path = comm[1];
    %%%%%:   69-block  0
unconditional  0 never executed
        -:   70:		}
        -:   71:
        -:   72:		else
    #####:   73:			search_path = comm[1];
    %%%%%:   73-block  0
unconditional  0 never executed
        -:   74:	}
        -:   75:
        -:   76:	/* If just one argument, '-' indicates file type. Else, we have a
        -:   77:	 * path */
        4:   78:	else if (comm[1]) {
        4:   78-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        -:   79:
        1:   80:		if (comm[1][0] == '-')
        1:   80-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   81:			file_type = (mode_t)comm[1][1];
    %%%%%:   81-block  0
unconditional  0 never executed
        -:   82:		else
        1:   83:			search_path = comm[1];
        1:   83-block  0
unconditional  0 taken 1
        -:   84:	}
        -:   85:
        -:   86:	/* If no arguments, search_path will be NULL and file_type zero */
        -:   87:
        5:   88:	int recursive = 0;
        -:   89:
        5:   90:	if (file_type) {
        5:   90-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        -:   91:
        -:   92:		/* Convert file type into a macro that can be decoded by stat().
        -:   93:		 * If file type is specified, matches will be checked against
        -:   94:		 * this value */
        1:   95:		switch (file_type) {
        1:   95-block  0
branch  0 taken 0
branch  1 taken 1
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
    #####:   96:		case 'd':
    #####:   97:			file_type = invert ? DT_DIR : S_IFDIR;
    %%%%%:   97-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   97-block  1
unconditional  2 never executed
    %%%%%:   97-block  2
unconditional  3 never executed
    #####:   98:			break;
    %%%%%:   98-block  0
unconditional  0 never executed
        1:   99:		case 'r':
       1*:  100:			file_type = invert ? DT_REG : S_IFREG;
        1:  100-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  100-block  1
unconditional  2 never executed
        1:  100-block  2
unconditional  3 taken 1
        1:  101:			break;
        1:  101-block  0
unconditional  0 taken 1
    #####:  102:		case 'l':
    #####:  103:			file_type = invert ? DT_LNK : S_IFLNK;
    %%%%%:  103-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  103-block  1
unconditional  2 never executed
    %%%%%:  103-block  2
unconditional  3 never executed
    #####:  104:			break;
    %%%%%:  104-block  0
unconditional  0 never executed
    #####:  105:		case 's':
    #####:  106:			file_type = invert ? DT_SOCK : S_IFSOCK;
    %%%%%:  106-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  106-block  1
unconditional  2 never executed
    %%%%%:  106-block  2
unconditional  3 never executed
    #####:  107:			break;
    %%%%%:  107-block  0
unconditional  0 never executed
    #####:  108:		case 'f':
    #####:  109:			file_type = invert ? DT_FIFO : S_IFIFO;
    %%%%%:  109-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  109-block  1
unconditional  2 never executed
    %%%%%:  109-block  2
unconditional  3 never executed
    #####:  110:			break;
    %%%%%:  110-block  0
unconditional  0 never executed
    #####:  111:		case 'b':
    #####:  112:			file_type = invert ? DT_BLK : S_IFBLK;
    %%%%%:  112-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  112-block  1
unconditional  2 never executed
    %%%%%:  112-block  2
unconditional  3 never executed
    #####:  113:			break;
    %%%%%:  113-block  0
unconditional  0 never executed
    #####:  114:		case 'c':
    #####:  115:			file_type = invert ? DT_CHR : S_IFCHR;
    %%%%%:  115-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  115-block  1
unconditional  2 never executed
    %%%%%:  115-block  2
unconditional  3 never executed
    #####:  116:			break;
    %%%%%:  116-block  0
unconditional  0 never executed
    #####:  117:		case 'x':
    #####:  118:			recursive = 1;
    #####:  119:			break;
    %%%%%:  119-block  0
unconditional  0 never executed
        -:  120:
    #####:  121:		default:
    #####:  122:			fprintf(stderr, _("%s: '%c': Unrecognized file type\n"),
call    0 never executed
    #####:  123:			    PROGRAM_NAME, (char)file_type);
    %%%%%:  123-block  0
call    0 never executed
    #####:  124:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  125:		}
        -:  126:	}
        -:  127:
        5:  128:	if (recursive) {
        5:  128-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  129:		char *cmd[] = {"find", (search_path && *search_path) ? search_path
    %%%%%:  129-block  0
branch  0 never executed
branch  1 never executed
    #####:  130:					: ".", "-name", comm[0] + 1, NULL};
    %%%%%:  130-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  130-block  1
unconditional  2 never executed
    %%%%%:  130-block  2
unconditional  3 never executed
    #####:  131:		launch_execve(cmd, FOREGROUND, E_NOSTDERR);
    %%%%%:  131-block  0
call    0 never executed
    #####:  132:		return EXIT_SUCCESS;
unconditional  0 never executed
        -:  133:	}
        -:  134:
        -:  135:	/* If we have a path ("/str /path"), chdir into it, since
        -:  136:	 * glob() works on CWD */
        5:  137:	if (search_path && *search_path) {
        5:  137-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2:  137-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        -:  138:
        -:  139:		/* Deescape the search path, if necessary */
        2:  140:		if (strchr(search_path, '\\')) {
        2:  140-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  141:			char *deq_dir = dequote_str(search_path, 0);
    %%%%%:  141-block  0
call    0 never executed
        -:  142:
    #####:  143:			if (!deq_dir) {
branch  0 never executed
branch  1 never executed
    #####:  144:				fprintf(stderr, _("%s: %s: Error dequoting file name\n"),
call    0 never executed
    #####:  145:				    PROGRAM_NAME, comm[1]);
    %%%%%:  145-block  0
call    0 never executed
    #####:  146:				return EXIT_FAILURE;
unconditional  0 never executed
        -:  147:			}
        -:  148:
    #####:  149:			strcpy(search_path, deq_dir);
    #####:  150:			free(deq_dir);
    %%%%%:  150-block  0
unconditional  0 never executed
        -:  151:		}
        -:  152:
        2:  153:		size_t path_len = strlen(search_path);
        2:  154:		if (search_path[path_len - 1] == '/')
        2:  154-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  155:			search_path[path_len - 1] = '\0';
    %%%%%:  155-block  0
unconditional  0 never executed
        -:  156:
        -:  157:		/* If search is current directory */
       2*:  158:		if ((*search_path == '.' && !search_path[1]) ||
        2:  158-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  158-block  1
branch  2 never executed
branch  3 never executed
        2:  159:		    (search_path[1] == ws[cur_ws].path[1]
        2:  159-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  160:		    && strcmp(search_path, ws[cur_ws].path) == 0)) {
        1:  160-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  161:			search_path = (char *)NULL;
        1:  161-block  0
unconditional  0 taken 1
        1:  162:		} else if (xchdir(search_path, NO_TITLE) == -1) {
        1:  162-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  163:			fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, search_path,
call    0 never executed
    #####:  164:			    strerror(errno));
    %%%%%:  164-block  0
call    0 never executed
    #####:  165:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  166:		}
        -:  167:	}
        -:  168:
        -:  169:	int i;
        -:  170:
        5:  171:	char *tmp = comm[0];
        -:  172:
        5:  173:	if (invert)
        5:  173-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        1:  174:		tmp++;
        1:  174-block  0
unconditional  0 taken 1
        -:  175:
        -:  176:	/* Search for globbing char */
        5:  177:	int glob_char_found = 0;
       17:  178:	for (i = 1; tmp[i]; i++) {
        5:  178-block  0
unconditional  0 taken 5
       12:  178-block  1
unconditional  1 taken 12
       17:  178-block  2
branch  2 taken 14
branch  3 taken 3 (fallthrough)
       14:  179:		if (tmp[i] == '*' || tmp[i] == '?' || tmp[i] == '[' || tmp[i] == '{'
       14:  179-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14:  179-block  1
branch  2 taken 14 (fallthrough)
branch  3 taken 0
       14:  179-block  2
branch  4 taken 14 (fallthrough)
branch  5 taken 0
       14:  179-block  3
branch  6 taken 14 (fallthrough)
branch  7 taken 0
        -:  180:		    /* Consider regex chars as well: we don't want this "r$"
        -:  181:		 * to become this "*r$*" */
       14:  182:		    || tmp[i] == '|' || tmp[i] == '^' || tmp[i] == '+' || tmp[i] == '$'
       14:  182-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14:  182-block  1
branch  2 taken 14 (fallthrough)
branch  3 taken 0
       14:  182-block  2
branch  4 taken 14 (fallthrough)
branch  5 taken 0
       14:  182-block  3
branch  6 taken 14 (fallthrough)
branch  7 taken 0
       14:  183:		    || tmp[i] == '.') {
       14:  183-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 12
        2:  184:			glob_char_found = 1;
        2:  185:			break;
        2:  185-block  0
unconditional  0 taken 2
        -:  186:		}
        -:  187:	}
        -:  188:
        -:  189:	/* If search string is just "STR" (no glob chars), change it
        -:  190:	 * to "*STR*" */
        -:  191:
        5:  192:	if (!glob_char_found) {
        5:  192-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3:  193:		size_t search_str_len = strlen(comm[0]);
        -:  194:
        3:  195:		comm[0] = (char *)xrealloc(comm[0], (search_str_len + 2) *
        3:  195-block  0
call    0 returned 3
        -:  196:							sizeof(char));
        3:  197:		tmp = comm[0];
        3:  198:		if (invert) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  199:			++tmp;
    #####:  200:			search_str_len = strlen(tmp);
    %%%%%:  200-block  0
unconditional  0 never executed
        -:  201:		}
        -:  202:
        3:  203:		tmp[0] = '*';
        3:  204:		tmp[search_str_len] = '*';
        3:  205:		tmp[search_str_len + 1] = '\0';
        3:  206:		search_str = tmp;
        3:  206-block  0
unconditional  0 taken 3
        -:  207:	}
        -:  208:
        -:  209:	else
        2:  210:		search_str = tmp + 1;
        2:  210-block  0
unconditional  0 taken 2
        -:  211:
        -:  212:	/* Get matches, if any */
        -:  213:	glob_t globbed_files;
        5:  214:	int ret = glob(search_str, GLOB_BRACE, NULL, &globbed_files);
        5:  214-block  0
call    0 returned 5
        -:  215:
        5:  216:	if (ret != 0) {
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2:  217:		puts(_("Glob: No matches found. Trying regex..."));
        2:  217-block  0
call    0 returned 2
call    1 returned 2
        -:  218:
        2:  219:		globfree(&globbed_files);
call    0 returned 2
        -:  220:
        2:  221:		if (search_path) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:  222:			/* Go back to the directory we came from */
    #####:  223:			if (xchdir(ws[cur_ws].path, NO_TITLE) == -1)
    %%%%%:  223-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  224:				fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
    #####:  225:				    ws[cur_ws].path, strerror(errno));
    %%%%%:  225-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  226:		}
        -:  227:
        2:  228:		return EXIT_FAILURE;
        2:  228-block  0
unconditional  0 taken 2
        -:  229:	}
        -:  230:
        -:  231:	/* We have matches */
        3:  232:	int scandir_files = 0,
        3:  233:		found = 0;
        -:  234:
        3:  235:	size_t flongest = 0;
        -:  236:
        -:  237:	/* We need to store pointers to matching file names in array of
        -:  238:	 * pointers, just as the file name length (to construct the
        -:  239:	 * columned output), and, if searching in CWD, its index (ELN)
        -:  240:	 * in the dirlist array as well */
        3:  241:	char **pfiles = (char **)NULL;
        3:  242:	int *eln = (int *)0;
        3:  243:	size_t *files_len = (size_t *)0;
        3:  244:	struct dirent **ent = (struct dirent **)NULL;
        -:  245:
        3:  246:	if (invert) {
        3:  246-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  247:		if (!search_path) {
    %%%%%:  247-block  0
branch  0 never executed
branch  1 never executed
        -:  248:			int k;
        -:  249:
    #####:  250:			pfiles = (char **)xnmalloc(files + 1, sizeof(char *));
    %%%%%:  250-block  0
call    0 never executed
    #####:  251:			eln = (int *)xnmalloc(files + 1, sizeof(int));
call    0 never executed
    #####:  252:			files_len = (size_t *)xnmalloc(files + 1, sizeof(size_t));
call    0 never executed
        -:  253:
    #####:  254:			for (k = 0; file_info[k].name; k++) {
unconditional  0 never executed
    %%%%%:  254-block  0
unconditional  1 never executed
    %%%%%:  254-block  1
branch  2 never executed
branch  3 never executed
    #####:  255:				int l, f = 0;
        -:  256:
    #####:  257:				for (l = 0; globbed_files.gl_pathv[l]; l++) {
    %%%%%:  257-block  0
unconditional  0 never executed
    %%%%%:  257-block  1
unconditional  1 never executed
    %%%%%:  257-block  2
branch  2 never executed
branch  3 never executed
    #####:  258:					if (*globbed_files.gl_pathv[l] == *file_info[k].name
    %%%%%:  258-block  0
branch  0 never executed
branch  1 never executed
    #####:  259:					&& strcmp(globbed_files.gl_pathv[l], file_info[k].name) == 0) {
    %%%%%:  259-block  0
branch  0 never executed
branch  1 never executed
    #####:  260:						f = 1;
    #####:  261:						break;
    %%%%%:  261-block  0
unconditional  0 never executed
        -:  262:					}
        -:  263:				}
        -:  264:
    #####:  265:				if (!f) {
    %%%%%:  265-block  0
branch  0 never executed
branch  1 never executed
        -:  266:
    #####:  267:					if (file_type && file_info[k].type != file_type)
    %%%%%:  267-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  267-block  1
branch  2 never executed
branch  3 never executed
    #####:  268:						continue;
    %%%%%:  268-block  0
unconditional  0 never executed
        -:  269:
    #####:  270:					eln[found] = (int)(k + 1);
    #####:  271:					files_len[found] = file_info[k].len
    #####:  272:								+ (size_t)file_info[k].eln_n + 1;
    #####:  273:					if (files_len[found] > flongest)
    %%%%%:  273-block  0
branch  0 never executed
branch  1 never executed
    #####:  274:						flongest = files_len[found];
    %%%%%:  274-block  0
unconditional  0 never executed
        -:  275:
    #####:  276:					pfiles[found++] = file_info[k].name;
    %%%%%:  276-block  0
unconditional  0 never executed
        -:  277:				}
        -:  278:			}
        -:  279:		}
        -:  280:
        -:  281:		else {
    #####:  282:			scandir_files = scandir(search_path, &ent, skip_files,
    %%%%%:  282-block  0
call    0 never executed
        -:  283:			    xalphasort);
        -:  284:
    #####:  285:			if (scandir_files != -1) {
branch  0 never executed
branch  1 never executed
        -:  286:
    #####:  287:				pfiles = (char **)xnmalloc((size_t)scandir_files + 1,
    %%%%%:  287-block  0
call    0 never executed
        -:  288:				    sizeof(char *));
    #####:  289:				eln = (int *)xnmalloc((size_t)scandir_files + 1,
call    0 never executed
        -:  290:				    sizeof(int));
    #####:  291:				files_len = (size_t *)xnmalloc((size_t)scandir_files + 1,
call    0 never executed
        -:  292:				    sizeof(size_t));
        -:  293:
        -:  294:				int k, l;
        -:  295:
    #####:  296:				for (k = 0; k < scandir_files; k++) {
unconditional  0 never executed
    %%%%%:  296-block  0
unconditional  1 never executed
    %%%%%:  296-block  1
branch  2 never executed
branch  3 never executed
    #####:  297:					int f = 0;
        -:  298:
    #####:  299:					for (l = 0; globbed_files.gl_pathv[l]; l++) {
    %%%%%:  299-block  0
unconditional  0 never executed
    %%%%%:  299-block  1
unconditional  1 never executed
    %%%%%:  299-block  2
branch  2 never executed
branch  3 never executed
    #####:  300:						if (*ent[k]->d_name == *globbed_files.gl_pathv[l]
    %%%%%:  300-block  0
branch  0 never executed
branch  1 never executed
    #####:  301:						&& strcmp(ent[k]->d_name, globbed_files.gl_pathv[l]) == 0) {
    %%%%%:  301-block  0
branch  0 never executed
branch  1 never executed
    #####:  302:							f = 1;
    #####:  303:							break;
    %%%%%:  303-block  0
unconditional  0 never executed
        -:  304:						}
        -:  305:					}
        -:  306:
    #####:  307:					if (!f) {
    %%%%%:  307-block  0
branch  0 never executed
branch  1 never executed
        -:  308:
        -:  309:#if !defined(_DIRENT_HAVE_D_TYPE)
        -:  310:						struct stat attr;
        -:  311:						mode_t type;
        -:  312:						if (lstat(ent[k]->d_name, &attr) == -1)
        -:  313:							continue;
        -:  314:						switch (attr.st_mode & S_IFMT) {
        -:  315:						case S_IFBLK: type = DT_BLK; break;
        -:  316:						case S_IFCHR: type = DT_CHR; break;
        -:  317:						case S_IFDIR: type = DT_DIR; break;
        -:  318:						case S_IFIFO: type = DT_FIFO; break;
        -:  319:						case S_IFLNK: type = DT_LNK; break;
        -:  320:						case S_IFREG: type = DT_REG; break;
        -:  321:						case S_IFSOCK: type = DT_SOCK; break;
        -:  322:						default: type = DT_UNKNOWN; break;
        -:  323:						}
        -:  324:
        -:  325:						if (file_type && type != file_type)
        -:  326:#else
    #####:  327:						if (file_type && ent[k]->d_type != file_type)
    %%%%%:  327-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  327-block  1
branch  2 never executed
branch  3 never executed
        -:  328:#endif
    #####:  329:							continue;
    %%%%%:  329-block  0
unconditional  0 never executed
        -:  330:
    #####:  331:						eln[found] = -1;
    #####:  332:						files_len[found] = unicode
    #####:  333:								       ? wc_xstrlen(ent[k]->d_name)
    %%%%%:  333-block  0
call    0 never executed
unconditional  1 never executed
    #####:  334:								       : strlen(ent[k]->d_name);
    %%%%%:  334-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  334-block  1
unconditional  2 never executed
        -:  335:
    #####:  336:						if (files_len[found] > flongest)
    %%%%%:  336-block  0
branch  0 never executed
branch  1 never executed
    #####:  337:							flongest = files_len[found];
    %%%%%:  337-block  0
unconditional  0 never executed
        -:  338:
    #####:  339:						pfiles[found++] = ent[k]->d_name;
    %%%%%:  339-block  0
unconditional  0 never executed
        -:  340:					}
        -:  341:				}
        -:  342:			}
        -:  343:		}
        -:  344:	}
        -:  345:
        -:  346:	else { /* No invert search */
        -:  347:
        3:  348:		pfiles = (char **)xnmalloc(globbed_files.gl_pathc + 1,
        3:  348-block  0
call    0 returned 3
        -:  349:		    sizeof(char *));
        3:  350:		eln = (int *)xnmalloc(globbed_files.gl_pathc + 1, sizeof(int));
call    0 returned 3
        3:  351:		files_len = (size_t *)xnmalloc(globbed_files.gl_pathc + 1, sizeof(size_t));
call    0 returned 3
        -:  352:
       12:  353:		for (i = 0; globbed_files.gl_pathv[i]; i++) {
unconditional  0 taken 3
        9:  353-block  0
unconditional  1 taken 9
       12:  353-block  1
branch  2 taken 9
branch  3 taken 3 (fallthrough)
        -:  354:
       9*:  355:			if (*globbed_files.gl_pathv[i] == '.'
        9:  355-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  356:			&& (!globbed_files.gl_pathv[i][1]
    %%%%%:  356-block  0
branch  0 never executed
branch  1 never executed
    #####:  357:			|| (globbed_files.gl_pathv[i][1] == '.'
    %%%%%:  357-block  0
branch  0 never executed
branch  1 never executed
    #####:  358:			&& !globbed_files.gl_pathv[i][2])))
    %%%%%:  358-block  0
branch  0 never executed
branch  1 never executed
    #####:  359:				continue;
    %%%%%:  359-block  0
unconditional  0 never executed
        -:  360:
        9:  361:			if (file_type) {
        9:  361-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        -:  362:
        -:  363:				/* Simply skip all files not matching file_type */
       3*:  364:				if (lstat(globbed_files.gl_pathv[i], &file_attrib) == -1)
        3:  364-block  0
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    #####:  365:					continue;
    %%%%%:  365-block  0
unconditional  0 never executed
        -:  366:
       3*:  367:				if ((file_attrib.st_mode & S_IFMT) != file_type)
        3:  367-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  368:					continue;
    %%%%%:  368-block  0
unconditional  0 never executed
        -:  369:			}
        -:  370:
        9:  371:			pfiles[found] = globbed_files.gl_pathv[i];
        -:  372:
        -:  373:			/* Get the longest file name in the list */
        -:  374:
        -:  375:			/* If not searching in CWD, we only need to know the file's
        -:  376:			 * length (no ELN) */
        9:  377:			if (search_path) {
        9:  377-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        -:  378:
        -:  379:				/* This will be passed to colors_list(): -1 means no ELN */
        3:  380:				eln[found] = -1;
        -:  381:
        3:  382:				files_len[found] = unicode ? wc_xstrlen(pfiles[found])
        3:  382-block  0
call    0 returned 3
unconditional  1 taken 3
       3*:  383:							   : strlen(pfiles[found]);
        3:  383-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
    %%%%%:  383-block  1
unconditional  2 never executed
        -:  384:
        3:  385:				if (files_len[found] > flongest)
        3:  385-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  386:					flongest = files_len[found];
        3:  386-block  0
unconditional  0 taken 3
        -:  387:
        3:  388:				found++;
        3:  388-block  0
unconditional  0 taken 3
        -:  389:			}
        -:  390:
        -:  391:			/* If searching in CWD, take into account the file's ELN
        -:  392:			 * when calculating its legnth */
        -:  393:			else {
        -:  394:				size_t j;
        -:  395:
       36:  396:				for (j = 0; file_info[j].name; j++) {
        6:  396-block  0
unconditional  0 taken 6
       30:  396-block  1
unconditional  1 taken 30
       36:  396-block  2
branch  2 taken 30
branch  3 taken 6 (fallthrough)
        -:  397:
       30:  398:					if (*pfiles[found] != *file_info[j].name
       30:  398-block  0
branch  0 taken 18 (fallthrough)
branch  1 taken 12
       18:  399:					|| strcmp(pfiles[found], file_info[j].name) != 0)
       18:  399-block  0
branch  0 taken 12 (fallthrough)
branch  1 taken 6
       24:  400:						continue;
       24:  400-block  0
unconditional  0 taken 24
        -:  401:
        6:  402:					eln[found] = (int)(j + 1);
        -:  403:
        6:  404:					files_len[found] = file_info[j].len
        6:  405:							+ (size_t)file_info[j].eln_n + 1;
        -:  406:
        6:  407:					if (files_len[found] > flongest)
        6:  407-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 4
        2:  408:						flongest = files_len[found];
        2:  408-block  0
unconditional  0 taken 2
        -:  409:				}
        -:  410:
        6:  411:				found++;
        6:  411-block  0
unconditional  0 taken 6
        -:  412:			}
        -:  413:		}
        -:  414:	}
        -:  415:
        -:  416:	/* Print the results using colors and columns */
        3:  417:	if (found) {
        3:  417-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -:  418:
        3:  419:		int columns_n = 0,
        3:  420:			last_column = 0;
        -:  421:
        -:  422:		struct winsize w;
        3:  423:		ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
        3:  423-block  0
call    0 returned 3
        3:  424:		unsigned short tcols = w.ws_col;
        -:  425:
        3:  426:		if (flongest == 0 || flongest > tcols)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  426-block  0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    #####:  427:			columns_n = 1;
    %%%%%:  427-block  0
unconditional  0 never executed
        -:  428:		else
        3:  429:			columns_n = (int)(tcols / (flongest + 1));
        3:  429-block  0
unconditional  0 taken 3
        -:  430:
        3:  431:		if (columns_n > found)
        3:  431-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  432:			columns_n = found;
        3:  432-block  0
unconditional  0 taken 3
        -:  433:
       12:  434:		for (i = 0; i < found; i++) {
        3:  434-block  0
unconditional  0 taken 3
        9:  434-block  1
unconditional  1 taken 9
       12:  434-block  2
branch  2 taken 9
branch  3 taken 3 (fallthrough)
        -:  435:
       9*:  436:			if (!pfiles[i])
        9:  436-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  437:				continue;
    %%%%%:  437-block  0
unconditional  0 never executed
        -:  438:
        9:  439:			if ((i + 1) % columns_n == 0)
        9:  439-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  440:				last_column = 1;
        3:  440-block  0
unconditional  0 taken 3
        -:  441:			else
        6:  442:				last_column = 0;
        6:  442-block  0
unconditional  0 taken 6
        -:  443:
       21:  444:			colors_list(pfiles[i], (eln[i] && eln[i] != -1) ? eln[i] : 0,
        9:  444-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 3
        3:  444-block  1
unconditional  2 taken 3
        6:  444-block  2
unconditional  3 taken 6
        9:  444-block  3
branch  4 taken 6 (fallthrough)
branch  5 taken 3
        3:  444-block  4
unconditional  6 taken 3
        9:  444-block  5
branch  7 taken 9 (fallthrough)
branch  8 taken 0
        9:  444-block  6
branch  9 taken 6 (fallthrough)
branch 10 taken 3
        6:  444-block  7
unconditional 11 taken 6
        3:  444-block  8
unconditional 12 taken 3
        9:  444-block  9
call   13 returned 9
unconditional 14 taken 9
        6:  445:			    (last_column || i == (found - 1)) ? 0 :
        6:  445-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6:  446:			    (int)(flongest - files_len[i]) + 1,
        6:  446-block  0
unconditional  0 taken 6
        6:  447:			    (last_column || i == found - 1) ? 1 : 0);
        6:  447-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -:  448:			/* Second argument to colors_list() is:
        -:  449:			 * 0: Do not print any ELN
        -:  450:			 * Positive number: Print positive number as ELN
        -:  451:			 * -1: Print "?" instead of an ELN */
        -:  452:		}
        -:  453:
        3:  454:		printf(_("Matches found: %d\n"), found);
        3:  454-block  0
call    0 returned 3
call    1 returned 3
        -:  455:	}
        -:  456:
        -:  457:	/*  else
        -:  458:		printf(_("%s: No matches found\n"), PROGRAM_NAME); */
        -:  459:
        -:  460:	/* Free stuff */
       3*:  461:	if (invert && search_path) {
        3:  461-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:  461-block  1
branch  2 never executed
branch  3 never executed
    #####:  462:		i = scandir_files;
    #####:  463:		while (--i >= 0)
    %%%%%:  463-block  0
unconditional  0 never executed
    %%%%%:  463-block  1
branch  1 never executed
branch  2 never executed
    #####:  464:			free(ent[i]);
    %%%%%:  464-block  0
unconditional  0 never executed
    #####:  465:		free(ent);
    %%%%%:  465-block  0
unconditional  0 never executed
        -:  466:	}
        -:  467:
        3:  468:	free(eln);
        3:  469:	free(files_len);
        3:  470:	free(pfiles);
        3:  471:	globfree(&globbed_files);
        3:  471-block  0
call    0 returned 3
        -:  472:
        -:  473:	/* If needed, go back to the directory we came from */
        3:  474:	if (search_path) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  475:		if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
        1:  475-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  476:			fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
    #####:  477:			    ws[cur_ws].path, strerror(errno));
    %%%%%:  477-block  0
call    0 never executed
call    1 never executed
    #####:  478:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  479:		}
        -:  480:	}
        -:  481:
        3:  482:	if (!found)
        3:  482-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  483:		return EXIT_FAILURE;
    %%%%%:  483-block  0
unconditional  0 never executed
        -:  484:
        3:  485:	return EXIT_SUCCESS;
        3:  485-block  0
unconditional  0 taken 3
        -:  486:}
        -:  487:
        -:  488:/* List matching (or not marching, if inverse is set to 1) file names
        -:  489: * in the specified directory */
        -:  490:int
function search_regex called 2 returned 100% blocks executed 37%
        2:  491:search_regex(char **comm, int invert)
        -:  492:{
        2:  493:	if (!comm || !comm[0])
        2:  493-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  493-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####:  494:		return EXIT_FAILURE;
    %%%%%:  494-block  0
unconditional  0 never executed
        -:  495:
        2:  496:	char *search_str = (char *)NULL, *search_path = (char *)NULL;
        2:  497:	mode_t file_type = 0;
        -:  498:
        -:  499:	/* If there are two arguments, the one starting with '-' is the
        -:  500:	 * file type and the other is the path */
       2*:  501:	if (comm[1] && comm[2]) {
        2:  501-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  501-block  1
branch  2 never executed
branch  3 never executed
        -:  502:
    #####:  503:		if (*comm[1] == '-') {
    %%%%%:  503-block  0
branch  0 never executed
branch  1 never executed
    #####:  504:			file_type = (mode_t) * (comm[1] + 1);
    #####:  505:			search_path = comm[2];
    %%%%%:  505-block  0
unconditional  0 never executed
        -:  506:		}
        -:  507:
    #####:  508:		else if (*comm[2] == '-') {
    %%%%%:  508-block  0
branch  0 never executed
branch  1 never executed
    #####:  509:			file_type = (mode_t) * (comm[2] + 1);
    #####:  510:			search_path = comm[1];
    %%%%%:  510-block  0
unconditional  0 never executed
        -:  511:		}
        -:  512:
        -:  513:		else
    #####:  514:			search_path = comm[1];
    %%%%%:  514-block  0
unconditional  0 never executed
        -:  515:	}
        -:  516:
        -:  517:	/* If just one argument, '-' indicates file type. Else, we have a
        -:  518:	 * path */
        2:  519:	else if (comm[1]) {
        2:  519-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  520:		if (*comm[1] == '-')
    %%%%%:  520-block  0
branch  0 never executed
branch  1 never executed
    #####:  521:			file_type = (mode_t) * (comm[1] + 1);
    %%%%%:  521-block  0
unconditional  0 never executed
        -:  522:		else
    #####:  523:			search_path = comm[1];
    %%%%%:  523-block  0
unconditional  0 never executed
        -:  524:	}
        -:  525:
        -:  526:	/* If no arguments, search_path will be NULL and file_type zero */
        -:  527:
        2:  528:	if (file_type) {
        2:  528-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -:  529:
        -:  530:		/* If file type is specified, matches will be checked against
        -:  531:		 * this value */
    #####:  532:		switch (file_type) {
    %%%%%:  532-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  533:		case 'd':
    #####:  534:			file_type = DT_DIR;
    #####:  535:			break;
    %%%%%:  535-block  0
unconditional  0 never executed
    #####:  536:		case 'r':
    #####:  537:			file_type = DT_REG;
    #####:  538:			break;
    %%%%%:  538-block  0
unconditional  0 never executed
    #####:  539:		case 'l':
    #####:  540:			file_type = DT_LNK;
    #####:  541:			break;
    %%%%%:  541-block  0
unconditional  0 never executed
    #####:  542:		case 's':
    #####:  543:			file_type = DT_SOCK;
    #####:  544:			break;
    %%%%%:  544-block  0
unconditional  0 never executed
    #####:  545:		case 'f':
    #####:  546:			file_type = DT_FIFO;
    #####:  547:			break;
    %%%%%:  547-block  0
unconditional  0 never executed
    #####:  548:		case 'b':
    #####:  549:			file_type = DT_BLK;
    #####:  550:			break;
    %%%%%:  550-block  0
unconditional  0 never executed
    #####:  551:		case 'c':
    #####:  552:			file_type = DT_CHR;
    #####:  553:			break;
    %%%%%:  553-block  0
unconditional  0 never executed
        -:  554:
    #####:  555:		default:
    #####:  556:			fprintf(stderr, _("%s: '%c': Unrecognized file type\n"),
call    0 never executed
    #####:  557:			    PROGRAM_NAME, (char)file_type);
    %%%%%:  557-block  0
call    0 never executed
    #####:  558:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  559:		}
        -:  560:	}
        -:  561:
        2:  562:	struct dirent **reg_dirlist = (struct dirent **)NULL;
        2:  563:	int tmp_files = 0;
        -:  564:
        -:  565:	/* If we have a path ("/str /path"), chdir into it, since
        -:  566:	 * regex() works on CWD */
       2*:  567:	if (search_path && *search_path) {
        2:  567-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  567-block  1
branch  2 never executed
branch  3 never executed
        -:  568:
        -:  569:		/* Deescape the search path, if necessary */
    #####:  570:		if (strchr(search_path, '\\')) {
    %%%%%:  570-block  0
branch  0 never executed
branch  1 never executed
    #####:  571:			char *deq_dir = dequote_str(search_path, 0);
    %%%%%:  571-block  0
call    0 never executed
        -:  572:
    #####:  573:			if (!deq_dir) {
branch  0 never executed
branch  1 never executed
    #####:  574:				fprintf(stderr, _("%s: %s: Error dequoting file name\n"),
call    0 never executed
    #####:  575:				    PROGRAM_NAME, comm[1]);
    %%%%%:  575-block  0
call    0 never executed
    #####:  576:				return EXIT_FAILURE;
unconditional  0 never executed
        -:  577:			}
        -:  578:
    #####:  579:			strcpy(search_path, deq_dir);
    #####:  580:			free(deq_dir);
    %%%%%:  580-block  0
unconditional  0 never executed
        -:  581:		}
        -:  582:
    #####:  583:		size_t path_len = strlen(search_path);
    #####:  584:		if (search_path[path_len - 1] == '/')
    %%%%%:  584-block  0
branch  0 never executed
branch  1 never executed
    #####:  585:			search_path[path_len - 1] = '\0';
    %%%%%:  585-block  0
unconditional  0 never executed
        -:  586:
    #####:  587:		if ((*search_path == '.' && !search_path[1])
    %%%%%:  587-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  587-block  1
branch  2 never executed
branch  3 never executed
    #####:  588:		|| (search_path[1] == ws[cur_ws].path[1]
    %%%%%:  588-block  0
branch  0 never executed
branch  1 never executed
    #####:  589:		&& strcmp(search_path, ws[cur_ws].path) == 0))
    %%%%%:  589-block  0
branch  0 never executed
branch  1 never executed
    #####:  590:			search_path = (char *)NULL;
    %%%%%:  590-block  0
unconditional  0 never executed
        -:  591:
    #####:  592:		if (search_path && *search_path) {
    %%%%%:  592-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  592-block  1
branch  2 never executed
branch  3 never executed
    #####:  593:			if (xchdir(search_path, NO_TITLE) == -1) {
    %%%%%:  593-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  594:				fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
call    0 never executed
    #####:  595:				    search_path, strerror(errno));
    %%%%%:  595-block  0
call    0 never executed
    #####:  596:				return EXIT_FAILURE;
unconditional  0 never executed
        -:  597:			}
        -:  598:
    #####:  599:			tmp_files = scandir(".", &reg_dirlist, skip_files, xalphasort);
    %%%%%:  599-block  0
call    0 never executed
        -:  600:
        -:  601:			/*      tmp_files = scandir(".", &reg_dirlist, skip_files,
        -:  602:							sort == 0 ? NULL : sort == 1 ? m_alphasort
        -:  603:							: sort == 2 ? size_sort : sort == 3
        -:  604:							? atime_sort : sort == 4 ? btime_sort
        -:  605:							: sort == 5 ? ctime_sort : sort == 6
        -:  606:							? mtime_sort : sort == 7 ? m_versionsort
        -:  607:							: sort == 8 ? ext_sort : inode_sort); */
        -:  608:
    #####:  609:			if (tmp_files == -1) {
branch  0 never executed
branch  1 never executed
    #####:  610:				fprintf(stderr, "scandir: %s: %s\n", search_path,
call    0 never executed
    #####:  611:				    strerror(errno));
    %%%%%:  611-block  0
call    0 never executed
        -:  612:
    #####:  613:				if (xchdir(ws[cur_ws].path, NO_TITLE) == -1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  614:					fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
    #####:  615:					    ws[cur_ws].path, strerror(errno));
    %%%%%:  615-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  616:
    #####:  617:				return EXIT_FAILURE;
    %%%%%:  617-block  0
unconditional  0 never executed
        -:  618:			}
        -:  619:		}
        -:  620:	}
        -:  621:
        -:  622:	size_t i;
        -:  623:
        -:  624:	/* Search for regex expression */
        2:  625:	int regex_found = check_regex(comm[0] + 1);
        2:  625-block  0
call    0 returned 2
        -:  626:
        -:  627:	/* If search string is just "STR" (no regex chars), change it
        -:  628:	 * to ".*STR.*" */
        2:  629:	if (regex_found == EXIT_FAILURE) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  630:		size_t search_str_len = strlen(comm[0]);
        -:  631:
    #####:  632:		comm[0] = (char *)xrealloc(comm[0], (search_str_len + 5) *
    %%%%%:  632-block  0
call    0 never executed
        -:  633:							sizeof(char));
        -:  634:
    #####:  635:		char *tmp_str = (char *)xnmalloc(search_str_len + 1, sizeof(char));
call    0 never executed
        -:  636:
    #####:  637:		strcpy(tmp_str, comm[0] + (invert ? 2 : 1));
branch  0 never executed
branch  1 never executed
    %%%%%:  637-block  0
unconditional  2 never executed
    %%%%%:  637-block  1
unconditional  3 never executed
        -:  638:
    #####:  639:		*comm[0] = '.';
    #####:  640:		*(comm[0] + 1) = '*';
    #####:  641:		*(comm[0] + 2) = '\0';
    #####:  642:		strcat(comm[0], tmp_str);
    #####:  643:		free(tmp_str);
    #####:  644:		*(comm[0] + search_str_len + 1) = '.';
    #####:  645:		*(comm[0] + search_str_len + 2) = '*';
    #####:  646:		*(comm[0] + search_str_len + 3) = '\0';
    #####:  647:		search_str = comm[0];
    %%%%%:  647-block  0
unconditional  0 never executed
        -:  648:	}
        -:  649:
        -:  650:	else
        2:  651:		search_str = comm[0] + (invert ? 2 : 1);
        2:  651-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  651-block  1
unconditional  2 taken 1
        1:  651-block  2
unconditional  3 taken 1
        2:  651-block  3
unconditional  4 taken 2
        -:  652:
        -:  653:	/* Get matches, if any, using regular expressions */
        -:  654:	regex_t regex_files;
        2:  655:	int ret = regcomp(&regex_files, search_str, REG_NOSUB | REG_EXTENDED);
        2:  655-block  0
call    0 returned 2
        -:  656:
        2:  657:	if (ret != EXIT_SUCCESS) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  658:		fprintf(stderr, _("'%s': Invalid regular expression\n"), search_str);
    %%%%%:  658-block  0
call    0 never executed
call    1 never executed
        -:  659:
    #####:  660:		regfree(&regex_files);
call    0 never executed
        -:  661:
    #####:  662:		if (search_path) {
branch  0 never executed
branch  1 never executed
    #####:  663:			for (i = 0; i < (size_t)tmp_files; i++)
    %%%%%:  663-block  0
unconditional  0 never executed
    %%%%%:  663-block  1
branch  1 never executed
branch  2 never executed
    #####:  664:				free(reg_dirlist[i]);
    %%%%%:  664-block  0
unconditional  0 never executed
        -:  665:
    #####:  666:			free(reg_dirlist);
        -:  667:
    #####:  668:			if (xchdir(ws[cur_ws].path, NO_TITLE) == -1)
    %%%%%:  668-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  669:				fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
    #####:  670:				    ws[cur_ws].path, strerror(errno));
    %%%%%:  670-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  671:		}
        -:  672:
    #####:  673:		return EXIT_FAILURE;
    %%%%%:  673-block  0
unconditional  0 never executed
        -:  674:	}
        -:  675:
        2:  676:	size_t found = 0;
       4*:  677:	int *regex_index = (int *)xnmalloc((search_path ? (size_t)tmp_files
        2:  677-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  677-block  1
unconditional  2 never executed
        2:  677-block  2
call    3 returned 2
        2:  678:							: files) +
        2:  678-block  0
unconditional  0 taken 2
        -:  679:					       1,
        -:  680:	    sizeof(int));
        -:  681:
      12*:  682:	for (i = 0; i < (search_path ? (size_t)tmp_files : files); i++) {
unconditional  0 taken 2
       10:  682-block  0
unconditional  1 taken 10
       12:  682-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 12
    %%%%%:  682-block  2
unconditional  4 never executed
       12:  682-block  3
unconditional  5 taken 12
       12:  682-block  4
branch  6 taken 10
branch  7 taken 2 (fallthrough)
      20*:  683:		if (regexec(&regex_files, (search_path ? reg_dirlist[i]->d_name
       10:  683-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 10
    %%%%%:  683-block  1
unconditional  2 never executed
       10:  683-block  2
call    3 returned 10
branch  4 taken 2 (fallthrough)
branch  5 taken 8
       10:  684:		: file_info[i].name), 0, NULL, 0) == EXIT_SUCCESS) {
       10:  684-block  0
unconditional  0 taken 10
        2:  685:			if (!invert)
        2:  685-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  686:				regex_index[found++] = (int)i;
        1:  686-block  0
unconditional  0 taken 1
        8:  687:		} else if (invert)
        8:  687-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 4
        4:  688:			regex_index[found++] = (int)i;
        4:  688-block  0
unconditional  0 taken 4
        -:  689:	}
        -:  690:
        2:  691:	regfree(&regex_files);
        2:  691-block  0
call    0 returned 2
        -:  692:
        2:  693:	if (!found) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  694:		fprintf(stderr, _("No matches found\n"));
    %%%%%:  694-block  0
call    0 never executed
call    1 never executed
    #####:  695:		free(regex_index);
        -:  696:
    #####:  697:		if (search_path) {
branch  0 never executed
branch  1 never executed
        -:  698:
    #####:  699:			int j = tmp_files;
    #####:  700:			while (--j >= 0)
    %%%%%:  700-block  0
unconditional  0 never executed
    %%%%%:  700-block  1
branch  1 never executed
branch  2 never executed
    #####:  701:				free(reg_dirlist[j]);
    %%%%%:  701-block  0
unconditional  0 never executed
        -:  702:
    #####:  703:			free(reg_dirlist);
        -:  704:
    #####:  705:			if (xchdir(ws[cur_ws].path, NO_TITLE) == -1)
    %%%%%:  705-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  706:				fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
    #####:  707:				    ws[cur_ws].path, strerror(errno));
    %%%%%:  707-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  708:		}
        -:  709:
    #####:  710:		return EXIT_FAILURE;
    %%%%%:  710-block  0
unconditional  0 never executed
        -:  711:	}
        -:  712:
        -:  713:	/* We have matches */
        2:  714:	size_t flongest = 0,
        2:  715:		   type_ok = 0;
        -:  716:
        2:  717:	size_t *files_len = (size_t *)xnmalloc(found + 1, sizeof(size_t));
        2:  717-block  0
call    0 returned 2
        2:  718:	int *match_type = (int *)xnmalloc(found + 1, sizeof(int));
call    0 returned 2
        -:  719:
        -:  720:	/* Get the longest file name in the list */
        2:  721:	int j = (int)found;
        7:  722:	while (--j >= 0) {
unconditional  0 taken 2
        7:  722-block  0
branch  1 taken 5
branch  2 taken 2 (fallthrough)
        -:  723:
        -:  724:		/* Simply skip all files not matching file_type */
        5:  725:		if (file_type) {
        5:  725-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        -:  726:
    #####:  727:			match_type[j] = 0;
        -:  728:
    #####:  729:			if (search_path) {
    %%%%%:  729-block  0
branch  0 never executed
branch  1 never executed
        -:  730:#if !defined(_DIRENT_HAVE_D_TYPE)
        -:  731:				mode_t type;
        -:  732:				struct stat attr;
        -:  733:				if (lstat(reg_dirlist[regex_index[j]]->d_name, &attr) == -1)
        -:  734:					continue;
        -:  735:				switch (attr.st_mode & S_IFMT) {
        -:  736:				case S_IFBLK: type = DT_BLK; break;
        -:  737:				case S_IFCHR: type = DT_CHR; break;
        -:  738:				case S_IFDIR: type = DT_DIR; break;
        -:  739:				case S_IFIFO: type = DT_FIFO; break;
        -:  740:				case S_IFLNK: type = DT_LNK; break;
        -:  741:				case S_IFREG: type = DT_REG; break;
        -:  742:				case S_IFSOCK: type = DT_SOCK; break;
        -:  743:				default: type = DT_UNKNOWN; break;
        -:  744:				}
        -:  745:				if (type != file_type)
        -:  746:#else
    #####:  747:				if (reg_dirlist[regex_index[j]]->d_type != file_type)
    %%%%%:  747-block  0
branch  0 never executed
branch  1 never executed
        -:  748:#endif
    #####:  749:					continue;
    %%%%%:  749-block  0
unconditional  0 never executed
    #####:  750:			} else if (file_info[regex_index[j]].type != file_type) {
    %%%%%:  750-block  0
branch  0 never executed
branch  1 never executed
    #####:  751:				continue;
    %%%%%:  751-block  0
unconditional  0 never executed
        -:  752:			}
        -:  753:		}
        -:  754:
        -:  755:		/* Amount of non-filtered files */
        5:  756:		type_ok++;
        -:  757:		/* Index of each non-filtered files */
        5:  758:		match_type[j] = 1;
        -:  759:
        -:  760:		/* If not searching in CWD, we only need to know the file's
        -:  761:		 * length (no ELN) */
        5:  762:		if (search_path) {
        5:  762-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  763:			files_len[j] = unicode ? wc_xstrlen(
    #####:  764:					reg_dirlist[regex_index[j]]->d_name)
    %%%%%:  764-block  0
call    0 never executed
unconditional  1 never executed
    #####:  765:					: strlen(reg_dirlist[regex_index[j]]->d_name);
    %%%%%:  765-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  765-block  1
unconditional  2 never executed
        -:  766:
    #####:  767:			if (files_len[j] > flongest)
    %%%%%:  767-block  0
branch  0 never executed
branch  1 never executed
    #####:  768:				flongest = files_len[j];
    %%%%%:  768-block  0
unconditional  0 never executed
        -:  769:		}
        -:  770:
        -:  771:		/* If searching in CWD, take into account the file's ELN
        -:  772:		 * when calculating its legnth */
        -:  773:		else {
       10:  774:			files_len[j] = file_info[regex_index[j]].len
       5*:  775:							+ (size_t)DIGINUM(regex_index[j] + 1) + 1;
        5:  775-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    %%%%%:  775-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  775-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  775-block  3
branch  6 never executed
branch  7 never executed
    %%%%%:  775-block  4
branch  8 never executed
branch  9 never executed
    %%%%%:  775-block  5
branch 10 never executed
branch 11 never executed
    %%%%%:  775-block  6
branch 12 never executed
branch 13 never executed
    %%%%%:  775-block  7
branch 14 never executed
branch 15 never executed
    %%%%%:  775-block  8
branch 16 never executed
branch 17 never executed
    %%%%%:  775-block  9
unconditional 18 never executed
    %%%%%:  775-block 10
unconditional 19 never executed
    %%%%%:  775-block 11
unconditional 20 never executed
    %%%%%:  775-block 12
unconditional 21 never executed
    %%%%%:  775-block 13
unconditional 22 never executed
    %%%%%:  775-block 14
unconditional 23 never executed
    %%%%%:  775-block 15
unconditional 24 never executed
    %%%%%:  775-block 16
unconditional 25 never executed
    %%%%%:  775-block 17
unconditional 26 never executed
    %%%%%:  775-block 18
unconditional 27 never executed
    %%%%%:  775-block 19
unconditional 28 never executed
    %%%%%:  775-block 20
unconditional 29 never executed
    %%%%%:  775-block 21
unconditional 30 never executed
    %%%%%:  775-block 22
unconditional 31 never executed
    %%%%%:  775-block 23
unconditional 32 never executed
    %%%%%:  775-block 24
unconditional 33 never executed
    %%%%%:  775-block 25
unconditional 34 never executed
        5:  775-block 26
unconditional 35 taken 5
        -:  776:
        5:  777:			if (files_len[j] > flongest)
        5:  777-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3:  778:				flongest = files_len[j];
        3:  778-block  0
unconditional  0 taken 3
        -:  779:		}
        -:  780:	}
        -:  781:
        2:  782:	if (type_ok) {
        2:  782-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -:  783:
        2:  784:		int last_column = 0;
        2:  785:		size_t total_cols = 0;
        -:  786:
        -:  787:		struct winsize w;
        2:  788:		ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
        2:  788-block  0
call    0 returned 2
        2:  789:		unsigned short terminal_cols = w.ws_col;
        -:  790:
        2:  791:		if (flongest == 0 || flongest > terminal_cols)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  791-block  0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####:  792:			total_cols = 1;
    %%%%%:  792-block  0
unconditional  0 never executed
        -:  793:		else
        2:  794:			total_cols = (size_t)terminal_cols / (flongest + 1);
        2:  794-block  0
unconditional  0 taken 2
        -:  795:
        2:  796:		if (total_cols > type_ok)
        2:  796-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  797:			total_cols = type_ok;
        2:  797-block  0
unconditional  0 taken 2
        -:  798:
        -:  799:		/* cur_col: Current columns number */
        2:  800:		size_t cur_col = 0,
        2:  801:			   counter = 0;
        -:  802:
        7:  803:		for (i = 0; i < found; i++) {
        2:  803-block  0
unconditional  0 taken 2
        5:  803-block  1
unconditional  1 taken 5
        7:  803-block  2
branch  2 taken 5
branch  3 taken 2 (fallthrough)
        -:  804:
       5*:  805:			if (match_type[i] == 0)
        5:  805-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:  806:				continue;
    %%%%%:  806-block  0
unconditional  0 never executed
        -:  807:
        -:  808:			/* Print the results using colors and columns */
        5:  809:			cur_col++;
        -:  810:
        -:  811:			/* If the current file is in the last column or is the last
        -:  812:			 * listed file, we need to print no pad and a newline char.
        -:  813:			 * Else, print the corresponding pad, to equate the longest
        -:  814:			 * file length, and no newline char */
        5:  815:			if (cur_col == total_cols) {
        5:  815-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 3
        2:  816:				last_column = 1;
        2:  817:				cur_col = 0;
        2:  817-block  0
unconditional  0 taken 2
        -:  818:			} else {
        3:  819:				last_column = 0;
        3:  819-block  0
unconditional  0 taken 3
        -:  820:			}
        -:  821:
        -:  822:			/* Counter: Current amount of non-filtered files: if
        -:  823:			 * COUNTER equals TYPE_OK (total amount of non-filtered
        -:  824:			 * files), we have the last file to be printed */
        5:  825:			counter++;
        -:  826:
      18*:  827:			colors_list(search_path ? reg_dirlist[regex_index[i]]->d_name
        5:  827-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 2
        3:  827-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 3
        2:  827-block  2
unconditional  4 taken 2
        3:  827-block  3
unconditional  5 taken 3
        5:  827-block  4
branch  6 taken 3 (fallthrough)
branch  7 taken 2
        2:  827-block  5
unconditional  8 taken 2
        5:  827-block  6
branch  9 taken 5 (fallthrough)
branch 10 taken 0
    %%%%%:  827-block  7
unconditional 11 never executed
        5:  827-block  8
branch 12 taken 0 (fallthrough)
branch 13 taken 5
    %%%%%:  827-block  9
unconditional 14 never executed
        5:  827-block 10
call   15 returned 5
unconditional 16 taken 5
        5:  828:					: file_info[regex_index[i]].name, search_path ? NO_ELN
        5:  828-block  0
unconditional  0 taken 5
        8:  829:					: regex_index[i] + 1, (last_column || counter == type_ok)
        3:  829-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        5:  829-block  1
unconditional  2 taken 5
        3:  830:					? NO_PAD : (int)(flongest - files_len[i]) + 1,
        3:  830-block  0
unconditional  0 taken 3
        -:  831:					(last_column || counter == type_ok) ? PRINT_NEWLINE
        -:  832:					: NO_NEWLINE);
        -:  833:		}
        -:  834:
        2:  835:		printf(_("Matches found: %zu\n"), counter);
        2:  835-block  0
call    0 returned 2
call    1 returned 2
        -:  836:	}
        -:  837:
        -:  838:	else
    #####:  839:		fputs(_("No matches found\n"), stderr);
    %%%%%:  839-block  0
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:  840:
        -:  841:	/* Free stuff */
        2:  842:	free(files_len);
        2:  843:	free(match_type);
        2:  844:	free(regex_index);
        2:  845:	regfree(&regex_files);
        2:  845-block  0
call    0 returned 2
        -:  846:
        -:  847:	/* If needed, go back to the directory we came from */
        2:  848:	if (search_path) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  849:		j = tmp_files;
    #####:  850:		while (--j >= 0)
    %%%%%:  850-block  0
unconditional  0 never executed
    %%%%%:  850-block  1
branch  1 never executed
branch  2 never executed
    #####:  851:			free(reg_dirlist[j]);
    %%%%%:  851-block  0
unconditional  0 never executed
        -:  852:
    #####:  853:		free(reg_dirlist);
        -:  854:
    #####:  855:		if (xchdir(ws[cur_ws].path, NO_TITLE) == -1) {
    %%%%%:  855-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  856:			fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME,
    #####:  857:			    ws[cur_ws].path, strerror(errno));
    %%%%%:  857-block  0
call    0 never executed
call    1 never executed
    #####:  858:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  859:		}
        -:  860:	}
        -:  861:
        2:  862:	if (type_ok)
        2:  862-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  863:		return EXIT_SUCCESS;
        2:  863-block  0
unconditional  0 taken 2
        -:  864:
    #####:  865:	return EXIT_FAILURE;
    %%%%%:  865-block  0
unconditional  0 never executed
        -:  866:}
