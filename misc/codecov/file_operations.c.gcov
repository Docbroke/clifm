        -:    0:Source:file_operations.c
        -:    1:/* file_operations.c -- control multiple file operations */
        -:    2:
        -:    3:/*
        -:    4: * This file is part of CliFM
        -:    5: * 
        -:    6: * Copyright (C) 2016-2021, L. Abramovich <johndoe.arch@outlook.com>
        -:    7: * All rights reserved.
        -:    8:
        -:    9: * CliFM is free software; you can redistribute it and/or modify
        -:   10: * it under the terms of the GNU General Public License as published by
        -:   11: * the Free Software Foundation; either version 2 of the License, or
        -:   12: * (at your option) any later version.
        -:   13: *
        -:   14: * CliFM is distributed in the hope that it will be useful,
        -:   15: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   16: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   17: * GNU General Public License for more details.
        -:   18: *
        -:   19: * You should have received a copy of the GNU General Public License
        -:   20: * along with this program; if not, write to the Free Software
        -:   21: * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
        -:   22: * MA 02110-1301, USA.
        -:   23:*/
        -:   24:
        -:   25:#include "helpers.h"
        -:   26:
        -:   27:#include <errno.h>
        -:   28:#include <stdio.h>
        -:   29:#include <string.h>
        -:   30:#include <sys/stat.h>
        -:   31:#include <unistd.h>
        -:   32:#include <time.h>
        -:   33:#include <readline/readline.h>
        -:   34:
        -:   35:#include <fcntl.h>
        -:   36:
        -:   37:#ifndef _NO_ARCHIVING
        -:   38:#include "archives.h"
        -:   39:#endif
        -:   40:#include "aux.h"
        -:   41:#include "checks.h"
        -:   42:#include "colors.h"
        -:   43:#include "exec.h"
        -:   44:#include "file_operations.h"
        -:   45:#include "history.h"
        -:   46:#include "listing.h"
        -:   47:#include "mime.h"
        -:   48:#include "misc.h"
        -:   49:#include "navigation.h"
        -:   50:#include "readline.h"
        -:   51:#include "selection.h"
        -:   52:#include "messages.h"
        -:   53:
        -:   54:/* Open a file via OPENER, if set, or via LIRA. If not compiled with
        -:   55: * Lira support, fallback to open (Haiku), or xdg-open. Returns zero
        -:   56: * on success and one on failure */
        -:   57:int
function open_file called 38 returned 100% blocks executed 58%
       38:   58:open_file(char *file)
        -:   59:{
       38:   60:	if (!file || !*file)
       38:   60-block  0
branch  0 taken 38 (fallthrough)
branch  1 taken 0
       38:   60-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 38
    #####:   61:		return EXIT_FAILURE;
    %%%%%:   61-block  0
unconditional  0 never executed
        -:   62:
       38:   63:	int exit_status = EXIT_SUCCESS;
        -:   64:
       38:   65:	if (opener) {
       38:   65-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 38
    #####:   66:		char *cmd[] = {opener, file, NULL};
    #####:   67:		if (launch_execve(cmd, FOREGROUND, E_NOSTDERR) != EXIT_SUCCESS)
    %%%%%:   67-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   68:			exit_status = EXIT_FAILURE;
    %%%%%:   68-block  0
unconditional  0 never executed
        -:   69:	} else {
        -:   70:#ifndef _NO_LIRA
       38:   71:		char *cmd[] = {"mm", file, NULL};
       38:   72:		exit_status = mime_open(cmd);
       38:   72-block  0
call    0 returned 38
        -:   73:#else
        -:   74:		/* Fallback to (xdg-)open */
        -:   75:#ifdef __HAIKU__
        -:   76:		char *cmd[] = {"open", file, NULL};
        -:   77:#else
        -:   78:		char *cmd[] = {"xdg-open", file, NULL};
        -:   79:#endif /* __HAIKU__ */
        -:   80:		if (launch_execve(cmd, FOREGROUND, E_NOSTDERR) != EXIT_SUCCESS)
        -:   81:			exit_status = EXIT_FAILURE;
        -:   82:#endif /* _NO_LIRA */
        -:   83:	}
        -:   84:
       38:   85:	return exit_status;
       38:   85-block  0
unconditional  0 taken 38
        -:   86:}
        -:   87:
        -:   88:/* Toggle executable bit on file */
        -:   89:int
function xchmod called 2 returned 100% blocks executed 73%
        2:   90:xchmod(const char *file, mode_t mode)
        -:   91:{
        -:   92:	/* Set or unset S_IXUSR, S_IXGRP, and S_IXOTH */
        2:   93:	(0100 & mode) ? (mode &= (mode_t)~0111) : (mode |= 0111);
        2:   93-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   93-block  1
unconditional  2 taken 1
        1:   93-block  2
unconditional  3 taken 1
        -:   94:
        2:   95:	log_function(NULL);
        2:   95-block  0
call    0 returned 2
        -:   96:
        2:   97:	if (chmod(file, mode) == -1) {
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:   98:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, file, strerror(errno));
    %%%%%:   98-block  0
call    0 never executed
call    1 never executed
    #####:   99:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  100:	}
        -:  101:
        2:  102:	return EXIT_SUCCESS;
        2:  102-block  0
unconditional  0 taken 2
        -:  103:}
        -:  104:
        -:  105:/* Create a duplicate of a file/dir using rsync or cp */
        -:  106:int
function dup_file called 2 returned 100% blocks executed 31%
        2:  107:dup_file(char *source, char *dest)
        -:  108:{
        2:  109:	if (!source || !*source)
        2:  109-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  109-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####:  110:		return EXIT_FAILURE;
    %%%%%:  110-block  0
unconditional  0 never executed
        -:  111:
        2:  112:	log_function(NULL);
        2:  112-block  0
call    0 returned 2
        -:  113:
        2:  114:	if (strchr(source, '\\')) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  115:		char *deq_str = dequote_str(source, 0);
    %%%%%:  115-block  0
call    0 never executed
    #####:  116:		if (!deq_str) {
branch  0 never executed
branch  1 never executed
    #####:  117:			fprintf(stderr, "%s: %s: Error dequoting file name\n",
    %%%%%:  117-block  0
call    0 never executed
        -:  118:				PROGRAM_NAME, source);
    #####:  119:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  120:		}
    #####:  121:		strcpy(source, deq_str);
    #####:  122:		free(deq_str);
    %%%%%:  122-block  0
unconditional  0 never executed
        -:  123:	}
        -:  124:
        2:  125:	if (dest) {
        2:  125-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  126:		if (strchr(dest, '\\')) {
        2:  126-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  127:			char *deq_str = dequote_str(dest, 0);
    %%%%%:  127-block  0
call    0 never executed
    #####:  128:			if (!deq_str) {
branch  0 never executed
branch  1 never executed
    #####:  129:				fprintf(stderr, "%s: %s: Error dequoting file name\n",
    %%%%%:  129-block  0
call    0 never executed
        -:  130:					PROGRAM_NAME, source);
    #####:  131:				return EXIT_FAILURE;
unconditional  0 never executed
        -:  132:			}
    #####:  133:			strcpy(dest, deq_str);
    #####:  134:			free(deq_str);
    %%%%%:  134-block  0
unconditional  0 never executed
        -:  135:		}
        -:  136:	}
        -:  137:
        2:  138:	int exit_status =  EXIT_SUCCESS;
        2:  139:	int free_dest = 0;
        -:  140:
        -:  141:	/* If no dest, use source as file name: source.copy, and, if already
        -:  142:	 * exists, source.copy.YYYYMMDDHHMMSS */
        2:  143:	if (!dest) {
        2:  143-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  144:		size_t source_len = strlen(source);
    #####:  145:		if (strcmp(source, "/") != 0 && source[source_len - 1] == '/')
    %%%%%:  145-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  145-block  1
branch  2 never executed
branch  3 never executed
    #####:  146:			source[source_len - 1] = '\0';
    %%%%%:  146-block  0
unconditional  0 never executed
        -:  147:
    #####:  148:		char *tmp = strrchr(source, '/');
        -:  149:		char *source_name;
        -:  150:
    #####:  151:		if (tmp && *(tmp + 1))
    %%%%%:  151-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  151-block  1
branch  2 never executed
branch  3 never executed
    #####:  152:			source_name = tmp + 1;
    %%%%%:  152-block  0
unconditional  0 never executed
        -:  153:		else
    #####:  154:			source_name = source;
    %%%%%:  154-block  0
unconditional  0 never executed
        -:  155:			
    #####:  156:		free_dest = 1;
    #####:  157:		dest = (char *)xnmalloc(strlen(source_name) + 6, sizeof(char));
    %%%%%:  157-block  0
call    0 never executed
    #####:  158:		sprintf(dest, "%s.copy", source_name);
        -:  159:
        -:  160:		struct stat attr;
    #####:  161:		if (stat(dest, &attr) == EXIT_SUCCESS) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  162:			time_t rawtime = time(NULL);
    %%%%%:  162-block  0
call    0 never executed
        -:  163:			struct tm tm;
    #####:  164:			localtime_r(&rawtime, &tm);
call    0 never executed
    #####:  165:			char date[64] = "";
    #####:  166:			strftime(date, sizeof(date), "%b %d %H:%M:%S %Y", &tm);
        -:  167:
    #####:  168:			char suffix[68] = "";
    #####:  169:			snprintf(suffix, 67, "%d%d%d%d%d%d", tm.tm_year + 1900,
    #####:  170:				tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min,
        -:  171:				tm.tm_sec);
        -:  172:
        -:  173:			char tmp_dest[PATH_MAX];
    #####:  174:			xstrsncpy(tmp_dest, dest, PATH_MAX);
call    0 never executed
    #####:  175:			dest = (char *)xrealloc(dest, (strlen(tmp_dest) + strlen(suffix) + 2)
call    0 never executed
        -:  176:									* sizeof(char));
    #####:  177:			sprintf(dest, "%s.%s", tmp_dest, suffix);
unconditional  0 never executed
        -:  178:		}
        -:  179:	}
        -:  180:
        2:  181:	char *rsync_path = get_cmd_path("rsync");
        2:  181-block  0
call    0 returned 2
        2:  182:	if (rsync_path) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  183:		char *cmd[] = {"rsync", "-aczvAXHS", "--progress", source, dest, NULL};
        2:  184:		if (launch_execve(cmd, FOREGROUND, E_NOFLAG) != EXIT_SUCCESS)
        2:  184-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  185:			exit_status = EXIT_FAILURE;
    %%%%%:  185-block  0
unconditional  0 never executed
        2:  186:		free(rsync_path);
        2:  186-block  0
unconditional  0 taken 2
        -:  187:	} else {
    #####:  188:		char *cmd[] = {"cp", "-a", source, dest, NULL};
    #####:  189:		if (launch_execve(cmd, FOREGROUND, E_NOFLAG) != EXIT_SUCCESS)
    %%%%%:  189-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  190:			exit_status = EXIT_FAILURE;
    %%%%%:  190-block  0
unconditional  0 never executed
        -:  191:	}
        -:  192:
        2:  193:	if (free_dest)
        2:  193-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  194:		free(dest);
    %%%%%:  194-block  0
unconditional  0 never executed
        2:  195:	return exit_status;
        2:  195-block  0
unconditional  0 taken 2
        -:  196:}
        -:  197:
        -:  198:int
function create_file called 2 returned 100% blocks executed 44%
        2:  199:create_file(char **cmd)
        -:  200:{
       2*:  201:	if (cmd[1] && *cmd[1] == '-' && strcmp(cmd[1], "--help") == 0) {
        2:  201-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  201-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    %%%%%:  201-block  2
branch  4 never executed
branch  5 never executed
    #####:  202:		puts(_(NEW_USAGE));
    %%%%%:  202-block  0
call    0 never executed
call    1 never executed
    #####:  203:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  204:	}
        -:  205:
        2:  206:	log_function(NULL);
        2:  206-block  0
call    0 returned 2
        -:  207:
        2:  208:	int exit_status = EXIT_SUCCESS;
        -:  209:#ifdef __HAIKU__
        -:  210:	int file_in_cwd = 0;
        -:  211:#endif
        2:  212:	int free_cmd = 0;
        -:  213:
        -:  214:	/* If no argument provided, ask the user for a filename */
        2:  215:	if (!cmd[1]) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  216:		char *filename = (char *)NULL;
    #####:  217:		while (!filename) {
    %%%%%:  217-block  0
unconditional  0 never executed
    %%%%%:  217-block  1
branch  1 never executed
branch  2 never executed
    #####:  218:			puts(_("End filename with a slash to create a directory"));
    %%%%%:  218-block  0
call    0 never executed
call    1 never executed
    #####:  219:			filename = rl_no_hist(_("Filename ('q' to quit): "));
call    0 never executed
call    1 never executed
        -:  220:
    #####:  221:			if (!filename)
branch  0 never executed
branch  1 never executed
    #####:  222:				continue;
    %%%%%:  222-block  0
unconditional  0 never executed
        -:  223:
    #####:  224:			if (!*filename) {
    %%%%%:  224-block  0
branch  0 never executed
branch  1 never executed
    #####:  225:				free(filename);
    #####:  226:				filename = (char *)NULL;
    #####:  227:				continue;
    %%%%%:  227-block  0
unconditional  0 never executed
        -:  228:			}
        -:  229:		}
        -:  230:
    #####:  231:		if (*filename == 'q' && !filename[1]) {
    %%%%%:  231-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  231-block  1
branch  2 never executed
branch  3 never executed
    #####:  232:			free(filename);
    #####:  233:			return EXIT_SUCCESS;
    %%%%%:  233-block  0
unconditional  0 never executed
        -:  234:		}
        -:  235:
        -:  236:		/* Once we have the filename, reconstruct the cmd array */
    #####:  237:		char **tmp_cmd = (char **)xnmalloc(args_n + 3, sizeof(char *));
    %%%%%:  237-block  0
call    0 never executed
    #####:  238:		tmp_cmd[0] = (char *)xnmalloc(2, sizeof(char));
call    0 never executed
    #####:  239:		*tmp_cmd[0] = 'n';
    #####:  240:		tmp_cmd[0][1] = '\0';
    #####:  241:		tmp_cmd[1] = (char *)xnmalloc(strlen(filename) + 1, sizeof(char));
call    0 never executed
    #####:  242:		strcpy(tmp_cmd[1], filename);
    #####:  243:		tmp_cmd[2] = (char *)NULL;
    #####:  244:		cmd = tmp_cmd;
    #####:  245:		free_cmd = 1;
    #####:  246:		free(filename);
unconditional  0 never executed
        -:  247:	}
        -:  248:
        -:  249:	/* Properly format filenames */
        -:  250:	size_t i;
        5:  251:	for (i = 1; cmd[i]; i++) {
        2:  251-block  0
unconditional  0 taken 2
        3:  251-block  1
unconditional  1 taken 3
        5:  251-block  2
branch  2 taken 3
branch  3 taken 2 (fallthrough)
        3:  252:		if (strchr(cmd[i], '\\')) {
        3:  252-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  253:			char *deq_str = dequote_str(cmd[i], 0);
    %%%%%:  253-block  0
call    0 never executed
    #####:  254:			if (!deq_str) {
branch  0 never executed
branch  1 never executed
    #####:  255:				_err('w', PRINT_PROMPT, _("%s: %s: Error dequoting filename\n"),
call    0 never executed
    #####:  256:					PROGRAM_NAME, cmd[i]);
    %%%%%:  256-block  0
call    0 never executed
    #####:  257:				continue;
unconditional  0 never executed
        -:  258:			}
        -:  259:
    #####:  260:			strcpy(cmd[i], deq_str);
    #####:  261:			free(deq_str);
    %%%%%:  261-block  0
unconditional  0 never executed
        -:  262:		}
        -:  263:
        3:  264:		if (*cmd[i] == '~') {
        3:  264-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  265:			char *exp_path = tilde_expand(cmd[i]);
    %%%%%:  265-block  0
call    0 never executed
    #####:  266:			if (exp_path) {
branch  0 never executed
branch  1 never executed
    #####:  267:				cmd[i] = (char *)xrealloc(cmd[i], (strlen(exp_path) + 1)
    %%%%%:  267-block  0
call    0 never executed
        -:  268:											* sizeof(char));
    #####:  269:				strcpy(cmd[i], exp_path);
    #####:  270:				free(exp_path);
unconditional  0 never executed
        -:  271:			}
        -:  272:		}
        -:  273:
        -:  274:#ifdef __HAIKU__
        -:  275:		/* If at least one filename lacks a slash (or it is the last char,
        -:  276:		 * in which case we have a directory in CWD), we are creating a
        -:  277:		 * file in CWD, and thereby we need to update the screen */
        -:  278:		char *ret = strrchr(cmd[i], '/');
        -:  279:		if (!ret || !*(ret + 1))
        -:  280:			file_in_cwd = 1;
        -:  281:#endif
        -:  282:	}
        -:  283:
        -:  284:	/* Construct commands */
        2:  285:	size_t files_num = i - 1;
        -:  286:
        2:  287:	char **nfiles = (char **)xnmalloc(files_num + 2, sizeof(char *));
        2:  287-block  0
call    0 returned 2
        2:  288:	char **ndirs = (char **)xnmalloc(files_num + 3, sizeof(char *));
call    0 returned 2
        -:  289:
        -:  290:	/* Let's use 'touch' for files and 'mkdir -p' for dirs */
        2:  291:	nfiles[0] = (char *)xnmalloc(6, sizeof(char));
call    0 returned 2
        2:  292:	strcpy(nfiles[0], "touch");
        -:  293:
        2:  294:	ndirs[0] = (char *)xnmalloc(6, sizeof(char));
call    0 returned 2
        2:  295:	strcpy(ndirs[0], "mkdir");
        -:  296:
        2:  297:	ndirs[1] = (char *)xnmalloc(3, sizeof(char));
call    0 returned 2
        2:  298:	ndirs[1][0] = '-';
        2:  299:	ndirs[1][1] = 'p';
        2:  300:	ndirs[1][2] = '\0';
        -:  301:
        2:  302:	size_t cnfiles = 1, cndirs = 2;
        -:  303:
        5:  304:	for (i = 1; cmd[i]; i++) {
unconditional  0 taken 2
        3:  304-block  0
unconditional  1 taken 3
        5:  304-block  1
branch  2 taken 3
branch  3 taken 2 (fallthrough)
        3:  305:		size_t cmd_len = strlen(cmd[i]);
        -:  306:		/* Filenames ending with a slash are taken as dir names */
        3:  307:		if (cmd[i][cmd_len - 1] == '/')
        3:  307-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:  308:			ndirs[cndirs++] = cmd[i];
        2:  308-block  0
unconditional  0 taken 2
        -:  309:		else
        1:  310:			nfiles[cnfiles++] = cmd[i];
        1:  310-block  0
unconditional  0 taken 1
        -:  311:	}
        -:  312:
        2:  313:	ndirs[cndirs] = (char *)NULL;
        2:  314:	nfiles[cnfiles] = (char *)NULL;
        -:  315:
        -:  316:	/* Execute commands */
        2:  317:	if (cnfiles > 1) {
        2:  317-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  318:		if (launch_execve(nfiles, FOREGROUND, 0) != EXIT_SUCCESS)
        1:  318-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  319:			exit_status = EXIT_FAILURE;
    %%%%%:  319-block  0
unconditional  0 never executed
        -:  320:	}
        -:  321:
        2:  322:	if (cndirs > 2) {
        2:  322-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  323:		if (launch_execve(ndirs, FOREGROUND, 0) != EXIT_SUCCESS)
        2:  323-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  324:			exit_status = EXIT_FAILURE;
    %%%%%:  324-block  0
unconditional  0 never executed
        -:  325:	}
        -:  326:
        2:  327:	free(nfiles[0]);
        2:  328:	free(ndirs[0]);
        2:  329:	free(ndirs[1]);
        2:  330:	free(nfiles);
        2:  331:	free(ndirs);
        2:  332:	if (free_cmd) {
        2:  332-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  333:		for (i = 0; cmd[i]; i++)
    %%%%%:  333-block  0
unconditional  0 never executed
    %%%%%:  333-block  1
branch  1 never executed
branch  2 never executed
    #####:  334:			free(cmd[i]);
    %%%%%:  334-block  0
unconditional  0 never executed
    #####:  335:		free(cmd);
    %%%%%:  335-block  0
unconditional  0 never executed
        -:  336:	}
        -:  337:
        -:  338:#ifdef __HAIKU__
        -:  339:	if (exit_status == EXIT_SUCCESS && cd_lists_on_the_fly && file_in_cwd) {
        -:  340:		free_dirlist();
        -:  341:		if (list_dir() != EXIT_SUCCESS)
        -:  342:			exit_status = EXIT_FAILURE;
        -:  343:	}
        -:  344:#endif
        -:  345:
        2:  346:	return exit_status;
        2:  346-block  0
unconditional  0 taken 2
        -:  347:}
        -:  348:
        -:  349:int
function open_function called 19 returned 100% blocks executed 55%
       19:  350:open_function(char **cmd)
        -:  351:{
       19:  352:	if (!cmd)
       19:  352-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 19
    #####:  353:		return EXIT_FAILURE;
    %%%%%:  353-block  0
unconditional  0 never executed
        -:  354:
       19:  355:	if (*cmd[0] == 'o' && (!cmd[0][1] || strcmp(cmd[0], "open") == 0)) {
       19:  355-block  0
branch  0 taken 19 (fallthrough)
branch  1 taken 0
       19:  355-block  1
branch  2 taken 13 (fallthrough)
branch  3 taken 6
       13:  355-block  2
branch  4 taken 13 (fallthrough)
branch  5 taken 0
       19:  356:		if (strchr(cmd[1], '\\')) {
       19:  356-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 19
    #####:  357:			char *deq_path = dequote_str(cmd[1], 0);
    %%%%%:  357-block  0
call    0 never executed
    #####:  358:			if (!deq_path) {
branch  0 never executed
branch  1 never executed
    #####:  359:				fprintf(stderr, _("%s: %s: Error dequoting filename\n"),
call    0 never executed
    #####:  360:					PROGRAM_NAME, cmd[1]);
    %%%%%:  360-block  0
call    0 never executed
    #####:  361:				return EXIT_FAILURE;
unconditional  0 never executed
        -:  362:			}
        -:  363:
    #####:  364:			strcpy(cmd[1], deq_path);
    #####:  365:			free(deq_path);
    %%%%%:  365-block  0
unconditional  0 never executed
        -:  366:		}
        -:  367:	}
        -:  368:
       19:  369:	char *file = cmd[1];
        -:  370:
        -:  371:	/* Check file existence */
        -:  372:	struct stat attr;
       19:  373:	if (stat(file, &attr) == -1) {
       19:  373-block  0
call    0 returned 19
branch  1 taken 3 (fallthrough)
branch  2 taken 16
        3:  374:		fprintf(stderr, "%s: open: %s: %s\n", PROGRAM_NAME, cmd[1],
call    0 returned 3
        3:  375:		    strerror(errno));
        3:  375-block  0
call    0 returned 3
        3:  376:		return EXIT_FAILURE;
unconditional  0 taken 3
        -:  377:	}
        -:  378:
        -:  379:	/* Check file type: only directories, symlinks, and regular files
        -:  380:	 * will be opened */
        -:  381:
       16:  382:	char no_open_file = 1, file_type[128];
        -:  383:	/* Reserve a good amount of bytes for file type: it cannot be
        -:  384:		  * known beforehand how many bytes the TRANSLATED string will
        -:  385:		  * need */
        -:  386:
       16:  387:	switch ((attr.st_mode & S_IFMT)) {
       16:  387-block  0
branch  0 taken 0
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 3
branch  5 taken 13
branch  6 taken 0
        -:  388:		/* Store file type to compose and print the error message, if
        -:  389:		 * necessary */
    #####:  390:	case S_IFBLK: strcpy(file_type, _("block device")); break;
    %%%%%:  390-block  0
call    0 never executed
unconditional  1 never executed
    #####:  391:	case S_IFCHR: strcpy(file_type, _("character device")); break;
    %%%%%:  391-block  0
call    0 never executed
unconditional  1 never executed
    #####:  392:	case S_IFSOCK: strcpy(file_type, _("socket")); break;
    %%%%%:  392-block  0
call    0 never executed
unconditional  1 never executed
    #####:  393:	case S_IFIFO: strcpy(file_type, _("FIFO/pipe")); break;
    %%%%%:  393-block  0
call    0 never executed
unconditional  1 never executed
        3:  394:	case S_IFDIR: return cd_function(file, CD_PRINT_ERROR);
        3:  394-block  0
call    0 returned 3
unconditional  1 taken 3
       13:  395:	case S_IFREG:
        -:  396:#ifndef _NO_ARCHIVING
        -:  397:		/* If an archive/compressed file, call archiver() */
       13:  398:		if (is_compressed(file, 1) == 0) {
       13:  398-block  0
call    0 returned 13
branch  1 taken 4 (fallthrough)
branch  2 taken 9
        4:  399:			char *tmp_cmd[] = {"ad", file, NULL};
        4:  400:			return archiver(tmp_cmd, 'd');
        4:  400-block  0
call    0 returned 4
unconditional  1 taken 4
        -:  401:		}
        -:  402:#endif
        9:  403:		no_open_file = 0;
        9:  404:		break;
        9:  404-block  0
unconditional  0 taken 9
        -:  405:
    #####:  406:	default:
    #####:  407:		strcpy(file_type, _("unknown file type"));
    %%%%%:  407-block  0
call    0 never executed
    #####:  408:		break;
unconditional  0 never executed
        -:  409:	}
        -:  410:
        -:  411:	/* If neither directory nor regular file nor symlink (to directory
        -:  412:	 * or regular file), print the corresponding error message and
        -:  413:	 * exit */
        9:  414:	if (no_open_file) {
        9:  414-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:  415:		fprintf(stderr, _("%s: %s (%s): Cannot open file. Try "
call    0 never executed
    #####:  416:			"'APPLICATION FILENAME'.\n"), PROGRAM_NAME, cmd[1], file_type);
    %%%%%:  416-block  0
call    0 never executed
    #####:  417:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  418:	}
        -:  419:
        -:  420:	/* At this point we know the file to be openend is either a regular
        -:  421:	 * file or a symlink to a regular file. So, just open the file */
       9*:  422:	if (!cmd[2] || (*cmd[2] == '&' && !cmd[2][1])) {
        9:  422-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 6
        3:  422-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 3
    %%%%%:  422-block  2
branch  4 never executed
branch  5 never executed
        6:  423:		int ret = open_file(file);
        6:  423-block  0
call    0 returned 6
        6:  424:		if (!opener && ret == EXIT_FAILURE) {
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6:  424-block  0
branch  2 taken 0 (fallthrough)
branch  3 taken 6
    #####:  425:			fputs("Add a new entry to the mimelist file ('mime "
    %%%%%:  425-block  0
call    0 never executed
        -:  426:			      "edit' or F6) or run 'open FILE APPLICATION'\n", stderr);
    #####:  427:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  428:		}
        6:  429:		return ret;
        6:  429-block  0
unconditional  0 taken 6
        -:  430:	}
        -:  431:
        -:  432:	/* If some application was specified to open the file */
        3:  433:	char *tmp_cmd[] = {cmd[2], file, NULL};
        3:  434:	int ret = launch_execve(tmp_cmd, bg_proc ? BACKGROUND : FOREGROUND, E_NOSTDERR);
        3:  434-block  0
call    0 returned 3
        3:  435:	if (ret != EXIT_SUCCESS)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  436:		return EXIT_FAILURE;
    %%%%%:  436-block  0
unconditional  0 never executed
        -:  437:
        3:  438:	return EXIT_SUCCESS;
        3:  438-block  0
unconditional  0 taken 3
        -:  439:}
        -:  440:
        -:  441:/* Relink symlink to new path */
        -:  442:int
function edit_link called 2 returned 100% blocks executed 48%
        2:  443:edit_link(char *link)
        -:  444:{
        2:  445:	if (!link || !*link)
        2:  445-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  445-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
    #####:  446:		return EXIT_FAILURE;
    %%%%%:  446-block  0
unconditional  0 never executed
        -:  447:
        2:  448:	log_function(NULL);
        2:  448-block  0
call    0 returned 2
        -:  449:
        -:  450:	/* Dequote the file name, if necessary */
        2:  451:	if (strchr(link, '\\')) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  452:		char *tmp = dequote_str(link, 0);
    %%%%%:  452-block  0
call    0 never executed
    #####:  453:		if (!tmp) {
branch  0 never executed
branch  1 never executed
    #####:  454:			fprintf(stderr, _("%s: %s: Error dequoting file\n"),
    %%%%%:  454-block  0
call    0 never executed
call    1 never executed
        -:  455:			    PROGRAM_NAME, link);
    #####:  456:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  457:		}
        -:  458:
    #####:  459:		strcpy(link, tmp);
    #####:  460:		free(tmp);
    %%%%%:  460-block  0
unconditional  0 never executed
        -:  461:	}
        -:  462:
        -:  463:	/* Check we have a valid symbolic link */
        -:  464:	struct stat file_attrib;
        2:  465:	if (lstat(link, &file_attrib) == -1) {
        2:  465-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  466:		fprintf(stderr, "%s: %s: %s\n", PROGRAM_NAME, link,
call    0 never executed
    #####:  467:		    strerror(errno));
    %%%%%:  467-block  0
call    0 never executed
    #####:  468:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  469:	}
        -:  470:
        2:  471:	if ((file_attrib.st_mode & S_IFMT) != S_IFLNK) {
        2:  471-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  472:		fprintf(stderr, _("%s: %s: Not a symbolic link\n"),
    %%%%%:  472-block  0
call    0 never executed
call    1 never executed
        -:  473:		    PROGRAM_NAME, link);
    #####:  474:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  475:	}
        -:  476:
        -:  477:	/* Get file pointed to by symlink and report to the user */
        2:  478:	char *real_path = realpath(link, NULL);
        2:  478-block  0
call    0 returned 2
        2:  479:	if (!real_path) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  480:		printf(_("%s%s%s currently pointing to nowhere (broken link)\n"),
        1:  480-block  0
call    0 returned 1
call    1 returned 1
unconditional  2 taken 1
        -:  481:		    or_c, link, df_c);
        -:  482:	} else {
        1:  483:		printf(_("%s%s%s currently pointing to "), ln_c, link, df_c);
        1:  483-block  0
call    0 returned 1
call    1 returned 1
        1:  484:		colors_list(real_path, NO_ELN, NO_PAD, PRINT_NEWLINE);
call    0 returned 1
        1:  485:		free(real_path);
        1:  486:		real_path = (char *)NULL;
unconditional  0 taken 1
        -:  487:	}
        -:  488:
        2:  489:	char *new_path = (char *)NULL;
        -:  490:	/* Enable autocd and auto-open (in case they are not already
        -:  491:	 * enabled) to allow TAB completion for ELN's */
        2:  492:	int autocd_status = autocd, auto_open_status = auto_open;
        2:  493:	autocd = auto_open = 1;
        -:  494:
        4:  495:	while (!new_path) {
        2:  495-block  0
unconditional  0 taken 2
        4:  495-block  1
branch  1 taken 2
branch  2 taken 2 (fallthrough)
        2:  496:		new_path = rl_no_hist(_("New path ('q' to quit): "));
        2:  496-block  0
call    0 returned 2
call    1 returned 2
       2*:  497:		if (!new_path)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  498:			continue;
    %%%%%:  498-block  0
unconditional  0 never executed
       2*:  499:		if (!*new_path) {
        2:  499-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  500:			free(new_path);
    #####:  501:			new_path = (char *)NULL;
    #####:  502:			continue;
    %%%%%:  502-block  0
unconditional  0 never executed
        -:  503:		}
        -:  504:
       2*:  505:		if (*new_path == 'q' && !new_path[1]) {
        2:  505-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  505-block  1
branch  2 never executed
branch  3 never executed
    #####:  506:			free(new_path);
    #####:  507:			return EXIT_SUCCESS;
    %%%%%:  507-block  0
unconditional  0 never executed
        -:  508:		}
        -:  509:	}
        -:  510:
        -:  511:	/* Set autocd and auto-open to their original values */
        2:  512:	autocd = autocd_status;
        2:  513:	auto_open = auto_open_status;
        -:  514:
        -:  515:	/* If an ELN, replace by the corresponding file name */
        2:  516:	if (is_number(new_path)) {
        2:  516-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  517:		int i_new_path = atoi(new_path) - 1;
    #####:  518:		if (file_info[i_new_path].name) {
    %%%%%:  518-block  0
branch  0 never executed
branch  1 never executed
    #####:  519:			new_path = (char *)xrealloc(new_path,
    #####:  520:			    (strlen(file_info[i_new_path].name) + 1) * sizeof(char));
    %%%%%:  520-block  0
call    0 never executed
    #####:  521:			strcpy(new_path, file_info[i_new_path].name);
unconditional  0 never executed
        -:  522:		}
        -:  523:	}
        -:  524:
        -:  525:	/* Remove terminating space. TAB completion puts a final space
        -:  526:	 * after file names */
        2:  527:	size_t path_len = strlen(new_path);
        2:  528:	if (new_path[path_len - 1] == ' ')
        2:  528-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  529:		new_path[path_len - 1] = '\0';
        1:  529-block  0
unconditional  0 taken 1
        -:  530:
        -:  531:	/* Dequote new path, if needed */
        2:  532:	if (strchr(new_path, '\\')) {
        2:  532-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  533:		char *tmp = dequote_str(new_path, 0);
    %%%%%:  533-block  0
call    0 never executed
    #####:  534:		if (!tmp) {
branch  0 never executed
branch  1 never executed
    #####:  535:			fprintf(stderr, _("%s: %s: Error dequoting file\n"),
    %%%%%:  535-block  0
call    0 never executed
call    1 never executed
        -:  536:			    PROGRAM_NAME, new_path);
    #####:  537:			free(new_path);
    #####:  538:			return EXIT_FAILURE;
unconditional  0 never executed
        -:  539:		}
        -:  540:
    #####:  541:		strcpy(new_path, tmp);
    #####:  542:		free(tmp);
    %%%%%:  542-block  0
unconditional  0 never executed
        -:  543:	}
        -:  544:
        -:  545:	/* Check new_path existence and warn the user if it does not
        -:  546:	 * exist */
        2:  547:	if (lstat(new_path, &file_attrib) == -1) {
        2:  547-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  548:		printf("'%s': %s\n", new_path, strerror(errno));
    %%%%%:  548-block  0
call    0 never executed
call    1 never executed
    #####:  549:		char *answer = (char *)NULL;
    #####:  550:		while (!answer) {
unconditional  0 never executed
    %%%%%:  550-block  0
branch  1 never executed
branch  2 never executed
    #####:  551:			answer = rl_no_hist(_("Relink as a broken symbolic link? [y/n] "));
    %%%%%:  551-block  0
call    0 never executed
call    1 never executed
    #####:  552:			if (!answer)
branch  0 never executed
branch  1 never executed
    #####:  553:				continue;
    %%%%%:  553-block  0
unconditional  0 never executed
    #####:  554:			if (!*answer) {
    %%%%%:  554-block  0
branch  0 never executed
branch  1 never executed
    #####:  555:				free(answer);
    #####:  556:				answer = (char *)NULL;
    #####:  557:				continue;
    %%%%%:  557-block  0
unconditional  0 never executed
        -:  558:			}
        -:  559:
    #####:  560:			if (*answer != 'y' && *answer != 'n') {
    %%%%%:  560-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  560-block  1
branch  2 never executed
branch  3 never executed
    #####:  561:				free(answer);
    #####:  562:				answer = (char *)NULL;
    #####:  563:				continue;
    %%%%%:  563-block  0
unconditional  0 never executed
        -:  564:			}
        -:  565:
    #####:  566:			if (answer[1]) {
    %%%%%:  566-block  0
branch  0 never executed
branch  1 never executed
    #####:  567:				free(answer);
    #####:  568:				answer = (char *)NULL;
    #####:  569:				continue;
    %%%%%:  569-block  0
unconditional  0 never executed
        -:  570:			}
        -:  571:
    #####:  572:			if (*answer == 'y') {
    %%%%%:  572-block  0
branch  0 never executed
branch  1 never executed
    #####:  573:				free(answer);
    #####:  574:				break;
    %%%%%:  574-block  0
unconditional  0 never executed
        -:  575:			} else {
    #####:  576:				free(answer);
    #####:  577:				free(new_path);
    #####:  578:				return EXIT_SUCCESS;
    %%%%%:  578-block  0
unconditional  0 never executed
        -:  579:			}
        -:  580:		}
        -:  581:	}
        -:  582:
        -:  583:	/* Finally, relink the symlink to new_path */
        2:  584:	char *cmd[] = {"ln", "-sfn", new_path, link, NULL};
        2:  585:	if (launch_execve(cmd, FOREGROUND, E_NOFLAG) != EXIT_SUCCESS) {
        2:  585-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  586:		free(new_path);
    #####:  587:		return EXIT_FAILURE;
    %%%%%:  587-block  0
unconditional  0 never executed
        -:  588:	}
        -:  589:
        2:  590:	real_path = realpath(link, NULL);
        2:  590-block  0
call    0 returned 2
       2*:  591:	printf(_("%s%s%s successfully relinked to "), real_path ? ln_c
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  591-block  0
unconditional  2 taken 2
    %%%%%:  591-block  1
unconditional  3 never executed
        2:  591-block  2
call    4 returned 2
call    5 returned 2
        -:  592:												: or_c, link, df_c);
        2:  593:	colors_list(new_path, NO_ELN, NO_PAD, PRINT_NEWLINE);
call    0 returned 2
        2:  594:	free(new_path);
        2:  595:	if (real_path)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  596:		free(real_path);
        2:  596-block  0
unconditional  0 taken 2
        -:  597:
        2:  598:	return EXIT_SUCCESS;
        2:  598-block  0
unconditional  0 taken 2
        -:  599:}
        -:  600:
        -:  601:int
function copy_function called 6 returned 100% blocks executed 53%
        6:  602:copy_function(char **comm)
        -:  603:{
        6:  604:	log_function(NULL);
        6:  604-block  0
call    0 returned 6
        -:  605:
        6:  606:	if (!is_sel)
branch  0 taken 3 (fallthrough)
branch  1 taken 3
        3:  607:		return run_and_refresh(comm);
        3:  607-block  0
call    0 returned 3
unconditional  1 taken 3
        -:  608:
        3:  609:	char *tmp_cmd = (char *)NULL;
        3:  610:	size_t total_len = 0, i = 0;
        -:  611:
       14:  612:	for (i = 0; i <= args_n; i++)
        3:  612-block  0
unconditional  0 taken 3
       14:  612-block  1
branch  1 taken 11
branch  2 taken 3 (fallthrough)
       11:  613:		total_len += strlen(comm[i]);
       11:  613-block  0
unconditional  0 taken 11
        -:  614:
        3:  615:	tmp_cmd = (char *)xcalloc(total_len + (i + 1) + 2, sizeof(char));
        3:  615-block  0
call    0 returned 3
        -:  616:
       14:  617:	for (i = 0; i <= args_n; i++) {
unconditional  0 taken 3
       14:  617-block  0
branch  1 taken 11
branch  2 taken 3 (fallthrough)
       11:  618:		strcat(tmp_cmd, comm[i]);
       11:  619:		strcat(tmp_cmd, " ");
       11:  619-block  0
unconditional  0 taken 11
        -:  620:	}
        -:  621:
        3:  622:	if (sel_is_last)
        3:  622-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:  623:		strcat(tmp_cmd, ".");
        2:  623-block  0
unconditional  0 taken 2
        -:  624:
        3:  625:	int ret = 0;
        3:  626:	ret = launch_execle(tmp_cmd);
        3:  626-block  0
call    0 returned 3
        3:  627:	free(tmp_cmd);
        -:  628:
        3:  629:	if (ret != EXIT_SUCCESS)
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  630:		return EXIT_FAILURE;
        1:  630-block  0
unconditional  0 taken 1
        -:  631:
        2:  632:	if (copy_n_rename) { /* vv */
        2:  632-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  633:		char **tmp = (char **)xnmalloc(sel_n + 3, sizeof(char *));
    %%%%%:  633-block  0
call    0 never executed
    #####:  634:		tmp[0] = savestring("br", 2);
call    0 never executed
        -:  635:
        -:  636:		size_t j;
    #####:  637:		for (j = 0; j < sel_n; j++) {
unconditional  0 never executed
    %%%%%:  637-block  0
branch  1 never executed
branch  2 never executed
    #####:  638:			size_t arg_len = strlen(sel_elements[j]);
        -:  639:
    #####:  640:			if (sel_elements[j][arg_len - 1] == '/')
    %%%%%:  640-block  0
branch  0 never executed
branch  1 never executed
    #####:  641:				sel_elements[j][arg_len - 1] = '\0';
    %%%%%:  641-block  0
unconditional  0 never executed
        -:  642:
    #####:  643:			if (*comm[args_n] == '~') {
    %%%%%:  643-block  0
branch  0 never executed
branch  1 never executed
    #####:  644:				char *exp_dest = tilde_expand(comm[args_n]);
    %%%%%:  644-block  0
call    0 never executed
    #####:  645:				comm[args_n] = xrealloc(comm[args_n],
    #####:  646:				    (strlen(exp_dest) + 1) * sizeof(char));
call    0 never executed
    #####:  647:				strcpy(comm[args_n], exp_dest);
    #####:  648:				free(exp_dest);
unconditional  0 never executed
        -:  649:			}
        -:  650:
    #####:  651:			size_t dest_len = strlen(comm[args_n]);
    #####:  652:			if (comm[args_n][dest_len - 1] == '/') {
    %%%%%:  652-block  0
branch  0 never executed
branch  1 never executed
    #####:  653:				comm[args_n][dest_len - 1] = '\0';
    %%%%%:  653-block  0
unconditional  0 never executed
        -:  654:			}
        -:  655:
        -:  656:			char dest[PATH_MAX];
    #####:  657:			strcpy(dest, (sel_is_last || strcmp(comm[args_n], ".") == 0)
    %%%%%:  657-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  657-block  1
branch  2 never executed
branch  3 never executed
    #####:  658:					 ? ws[cur_ws].path
    %%%%%:  658-block  0
unconditional  0 never executed
    #####:  659:					 : comm[args_n]);
    %%%%%:  659-block  0
unconditional  0 never executed
        -:  660:
    #####:  661:			char *ret_val = strrchr(sel_elements[j], '/');
    #####:  662:			char *tmp_str = (char *)xnmalloc(strlen(dest)
    #####:  663:								+ strlen(ret_val + 1) + 2, sizeof(char));
    %%%%%:  663-block  0
call    0 never executed
        -:  664:
    #####:  665:			sprintf(tmp_str, "%s/%s", dest, ret_val + 1);
        -:  666:
    #####:  667:			tmp[j + 1] = savestring(tmp_str, strlen(tmp_str));
call    0 never executed
    #####:  668:			free(tmp_str);
unconditional  0 never executed
        -:  669:		}
        -:  670:
    #####:  671:		tmp[j + 1] = (char *)NULL;
    #####:  672:		bulk_rename(tmp);
    %%%%%:  672-block  0
call    0 never executed
        -:  673:
    #####:  674:		for (i = 0; tmp[i]; i++)
unconditional  0 never executed
    %%%%%:  674-block  0
branch  1 never executed
branch  2 never executed
    #####:  675:			free(tmp[i]);
    %%%%%:  675-block  0
unconditional  0 never executed
    #####:  676:		free(tmp);
    #####:  677:		copy_n_rename = 0;
    #####:  678:		return EXIT_SUCCESS;
    %%%%%:  678-block  0
unconditional  0 never executed
        -:  679:	}
        -:  680:
        -:  681:	/* If 'mv sel' and command is successful deselect everything,
        -:  682:	 * since sel files are note there anymore */
        2:  683:	if (*comm[0] == 'm' && comm[0][1] == 'v'
        2:  683-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  683-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:  684:	&& (!comm[0][2] || comm[0][2] == ' ')) {
        1:  684-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  684-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        4:  685:		for (i = 0; i < sel_n; i++)
        1:  685-block  0
unconditional  0 taken 1
        4:  685-block  1
branch  1 taken 3
branch  2 taken 1 (fallthrough)
        3:  686:			free(sel_elements[i]);
        3:  686-block  0
unconditional  0 taken 3
        1:  687:		sel_n = 0;
        1:  688:		save_sel();
        1:  688-block  0
call    0 returned 1
unconditional  1 taken 1
        -:  689:	}
        -:  690:
        -:  691:#ifdef __HAIKU__
        -:  692:	if (cd_lists_on_the_fly) {
        -:  693:		free_dirlist();
        -:  694:		list_dir();
        -:  695:	}
        -:  696:#endif
        -:  697:
        2:  698:	return EXIT_SUCCESS;
        2:  698-block  0
unconditional  0 taken 2
        -:  699:}
        -:  700:
        -:  701:int
function remove_file called 4 returned 100% blocks executed 82%
        4:  702:remove_file(char **args)
        -:  703:{
        4:  704:	int cwd = 0, exit_status = EXIT_SUCCESS;
        -:  705:
        4:  706:	log_function(NULL);
        4:  706-block  0
call    0 returned 4
        -:  707:
        4:  708:	char **rm_cmd = (char **)xnmalloc(args_n + 4, sizeof(char *));
call    0 returned 4
        4:  709:	int i, j = 3, dirs = 0;
        -:  710:
       10:  711:	for (i = 1; args[i]; i++) {
unconditional  0 taken 4
        6:  711-block  0
unconditional  1 taken 6
       10:  711-block  1
branch  2 taken 6
branch  3 taken 4 (fallthrough)
        -:  712:		/* Check if at least one file is in the current directory. If not,
        -:  713:		 * there is no need to refresh the screen */
        6:  714:		if (!cwd) {
        6:  714-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 2
        4:  715:			char *ret = strchr(args[i], '/');
        -:  716:			/* If there's no slash, or if slash is the last char and
        -:  717:			 * the file is not root "/", we have a file in CWD */
        4:  718:			if (!ret || (!*(ret + 1) && ret != args[i]))
        4:  718-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  718-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        1:  718-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        3:  719:				cwd = 1;
        3:  719-block  0
unconditional  0 taken 3
        -:  720:		}
        -:  721:
        6:  722:		char *tmp = (char *)NULL;
        6:  723:		if (strchr(args[i], '\\')) {
        6:  723-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####:  724:			tmp = dequote_str(args[i], 0);
    %%%%%:  724-block  0
call    0 never executed
    #####:  725:			if (tmp) {
branch  0 never executed
branch  1 never executed
        -:  726:				/* Start storing file names in 3: 0 is for 'rm', and 1
        -:  727:				 * and 2 for parameters, including end of parameters (--) */
    #####:  728:				rm_cmd[j++] = savestring(tmp, strlen(tmp));
    %%%%%:  728-block  0
call    0 never executed
    #####:  729:				free(tmp);
unconditional  0 never executed
        -:  730:			} else {
    #####:  731:				fprintf(stderr, "%s: %s: Error dequoting file name\n",
    #####:  732:				    PROGRAM_NAME, args[i]);
    %%%%%:  732-block  0
call    0 never executed
    #####:  733:				continue;
unconditional  0 never executed
        -:  734:			}
        -:  735:		} else {
        6:  736:			rm_cmd[j++] = savestring(args[i], strlen(args[i]));
        6:  736-block  0
call    0 returned 6
unconditional  1 taken 6
        -:  737:		}
        -:  738:
        -:  739:		struct stat attr;
        6:  740:		if (!dirs && lstat(rm_cmd[j - 1], &attr) != -1
        6:  740-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6:  740-block  1
call    2 returned 6
branch  3 taken 6 (fallthrough)
branch  4 taken 0
        6:  741:		&& (attr.st_mode & S_IFMT) == S_IFDIR)
        6:  741-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 4
        2:  742:			dirs = 1;
        2:  742-block  0
unconditional  0 taken 2
        -:  743:	}
        -:  744:
        4:  745:	rm_cmd[j] = (char *)NULL;
        -:  746:
        4:  747:	rm_cmd[0] = savestring("rm", 2);
        4:  747-block  0
call    0 returned 4
        4:  748:	if (dirs)
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        -:  749:#if defined(__NetBSD__) || defined(__OpenBSD__)
        -:  750:		rm_cmd[1] = savestring("-r", 2);
        -:  751:#else
        2:  752:		rm_cmd[1] = savestring("-dIr", 4);
        2:  752-block  0
call    0 returned 2
unconditional  1 taken 2
        -:  753:#endif
        -:  754:	else
        -:  755:#if defined(__NetBSD__) || defined(__OpenBSD__)
        -:  756:		rm_cmd[1] = savestring("-f", 2);
        -:  757:#else
        2:  758:		rm_cmd[1] = savestring("-I", 2);
        2:  758-block  0
call    0 returned 2
unconditional  1 taken 2
        -:  759:#endif
        4:  760:	rm_cmd[2] = savestring("--", 2);
        4:  760-block  0
call    0 returned 4
        -:  761:
        4:  762:	if (launch_execve(rm_cmd, FOREGROUND, E_NOFLAG) != EXIT_SUCCESS)
call    0 returned 4
branch  1 taken 0 (fallthrough)
branch  2 taken 4
    #####:  763:		exit_status = EXIT_FAILURE;
    %%%%%:  763-block  0
unconditional  0 never executed
        -:  764:#ifdef __HAIKU__
        -:  765:	else {
        -:  766:		if (cwd && cd_lists_on_the_fly && strcmp(args[1], "--help") != 0
        -:  767:		&& strcmp(args[1], "--version") != 0) {
        -:  768:			free_dirlist();
        -:  769:			exit_status = list_dir();
        -:  770:		}
        -:  771:	}
        -:  772:#endif
        -:  773:
       22:  774:	for (i = 0; rm_cmd[i]; i++)
        4:  774-block  0
unconditional  0 taken 4
       22:  774-block  1
branch  1 taken 18
branch  2 taken 4 (fallthrough)
       18:  775:		free(rm_cmd[i]);
       18:  775-block  0
unconditional  0 taken 18
        4:  776:	free(rm_cmd);
        4:  777:	return exit_status;
        4:  777-block  0
unconditional  0 taken 4
        -:  778:}
        -:  779:
        -:  780:/* Rename a bulk of files (ARGS) at once. Takes files to be renamed
        -:  781: * as arguments, and returns zero on success and one on error. The
        -:  782: * procedude is quite simple: file names to be renamed are copied into
        -:  783: * a temporary file, which is opened via the mime function and shown
        -:  784: * to the user to modify it. Once the file names have been modified and
        -:  785: * saved, modifications are printed on the screen and the user is
        -:  786: * asked whether to perform the actual bulk renaming (via mv) or not.
        -:  787: * I took this bulk rename method, just because it is quite simple and
        -:  788: * KISS, from the fff filemanager. So, thanks fff! BTW, this method
        -:  789: * is also implemented by ranger and nnn */
        -:  790:int
function bulk_rename called 3 returned 100% blocks executed 55%
        3:  791:bulk_rename(char **args)
        -:  792:{
        3:  793:	if (!args[1])
        3:  793-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  794:		return EXIT_FAILURE;
    %%%%%:  794-block  0
unconditional  0 never executed
        -:  795:
        3:  796:	log_function(NULL);
        3:  796-block  0
call    0 returned 3
        -:  797:
        3:  798:	int exit_status = EXIT_SUCCESS;
        -:  799:
        -:  800:	char bulk_file[PATH_MAX];
        3:  801:	if (xargs.stealth_mode == 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  802:		sprintf(bulk_file, "/tmp/.clifm_bulk_rename");
    %%%%%:  802-block  0
unconditional  0 never executed
        -:  803:	else
        3:  804:		sprintf(bulk_file, "%s/.bulk_rename", tmp_dir);
        3:  804-block  0
unconditional  0 taken 3
        -:  805:
        -:  806:	int fd;
        3:  807:	FILE *fp = open_fstream_w(bulk_file, &fd);
        3:  807-block  0
call    0 returned 3
        3:  808:	if (!fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  809:		_err('e', PRINT_PROMPT, "bulk: '%s': %s\n", bulk_file, strerror(errno));
    %%%%%:  809-block  0
call    0 never executed
call    1 never executed
    #####:  810:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  811:	}
        -:  812:
        3:  813:	size_t i, arg_total = 0;
        -:  814:
        -:  815:	/* Copy all files to be renamed to the bulk file */
       10:  816:	for (i = 1; args[i]; i++) {
        3:  816-block  0
unconditional  0 taken 3
        7:  816-block  1
unconditional  1 taken 7
       10:  816-block  2
branch  2 taken 7
branch  3 taken 3 (fallthrough)
        -:  817:		/* Dequote file name, if necessary */
        7:  818:		if (strchr(args[i], '\\')) {
        7:  818-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  819:			char *deq_file = dequote_str(args[i], 0);
    %%%%%:  819-block  0
call    0 never executed
    #####:  820:			if (!deq_file) {
branch  0 never executed
branch  1 never executed
    #####:  821:				fprintf(stderr, _("bulk: %s: Error dequoting "
call    0 never executed
    #####:  822:						"file name\n"), args[i]);
    %%%%%:  822-block  0
call    0 never executed
    #####:  823:				continue;
unconditional  0 never executed
        -:  824:			}
    #####:  825:			strcpy(args[i], deq_file);
    #####:  826:			free(deq_file);
    %%%%%:  826-block  0
unconditional  0 never executed
        -:  827:		}
        -:  828:
        7:  829:		fprintf(fp, "%s\n", args[i]);
        7:  829-block  0
call    0 returned 7
unconditional  1 taken 7
        -:  830:	}
        -:  831:
        3:  832:	arg_total = i;
        3:  833:	close_fstream(fp, fd);
        3:  833-block  0
call    0 returned 3
        -:  834:
        3:  835:	fp = open_fstream_r(bulk_file, &fd);
call    0 returned 3
        3:  836:	if (!fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  837:		_err('e', PRINT_PROMPT, "bulk: '%s': %s\n", bulk_file, strerror(errno));
    %%%%%:  837-block  0
call    0 never executed
call    1 never executed
    #####:  838:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  839:	}
        -:  840:
        -:  841:	/* Store the last modification time of the bulk file. This time
        -:  842:	 * will be later compared to the modification time of the same
        -:  843:	 * file after shown to the user */
        -:  844:	struct stat attr;
        3:  845:	fstat(fd, &attr);
        3:  845-block  0
call    0 returned 3
        3:  846:	time_t mtime_bfr = (time_t)attr.st_mtime;
        -:  847:
        -:  848:	/* Open the bulk file */
        3:  849:	if (open_file(bulk_file) != EXIT_SUCCESS)
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    #####:  850:		return EXIT_FAILURE;
    %%%%%:  850-block  0
unconditional  0 never executed
        -:  851:
        -:  852:	/* Compare the new modification time to the stored one: if they
        -:  853:	 * match, nothing was modified */
        3:  854:	fstat(fd, &attr);
        3:  854-block  0
call    0 returned 3
        3:  855:	if (mtime_bfr == (time_t)attr.st_mtime) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  856:		puts(_("bulk: Nothing to do"));
    %%%%%:  856-block  0
call    0 never executed
call    1 never executed
    #####:  857:		if (unlinkat(fd, bulk_file, 0) == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  858:			_err('e', PRINT_PROMPT, "%s: '%s': %s\n", PROGRAM_NAME,
call    0 never executed
    #####:  859:			    bulk_file, strerror(errno));
    %%%%%:  859-block  0
call    0 never executed
    #####:  860:			exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  861:		}
    #####:  862:		close_fstream(fp, fd);
    %%%%%:  862-block  0
call    0 never executed
    #####:  863:		return exit_status;
unconditional  0 never executed
        -:  864:	}
        -:  865:
        -:  866:	/* Go back to the beginning of the bulk file */
        3:  867:	fseek(fp, 0, SEEK_SET);
        3:  867-block  0
call    0 returned 3
        -:  868:
        -:  869:	/* Make sure there are as many lines in the bulk file as files
        -:  870:	 * to be renamed */
        3:  871:	size_t file_total = 1;
        -:  872:	char tmp_line[256];
       10:  873:	while (fgets(tmp_line, (int)sizeof(tmp_line), fp))
unconditional  0 taken 3
       10:  873-block  0
call    1 returned 10
branch  2 taken 7
branch  3 taken 3 (fallthrough)
        7:  874:		file_total++;
        7:  874-block  0
unconditional  0 taken 7
        -:  875:
        3:  876:	if (arg_total != file_total) {
        3:  876-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  877:		fputs(_("bulk: Line mismatch in rename file\n"), stderr);
    %%%%%:  877-block  0
call    0 never executed
call    1 never executed
    #####:  878:		if (unlinkat(fd, bulk_file, 0) == -1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  879:			_err('e', PRINT_PROMPT, "%s: '%s': %s\n", PROGRAM_NAME,
call    0 never executed
unconditional  1 never executed
    #####:  880:			    bulk_file, strerror(errno));
    %%%%%:  880-block  0
call    0 never executed
    #####:  881:		close_fstream(fp, fd);
    %%%%%:  881-block  0
call    0 never executed
    #####:  882:		return EXIT_FAILURE;
unconditional  0 never executed
        -:  883:	}
        -:  884:
        -:  885:	/* Go back to the beginning of the bulk file, again */
        3:  886:	fseek(fp, 0L, SEEK_SET);
        3:  886-block  0
call    0 returned 3
        -:  887:
        3:  888:	size_t line_size = 0;
        3:  889:	char *line = (char *)NULL;
        3:  890:	ssize_t line_len = 0;
        3:  891:	int modified = 0;
        -:  892:
        3:  893:	i = 1;
        -:  894:	/* Print what would be done */
       10:  895:	while ((line_len = getline(&line, &line_size, fp)) > 0) {
unconditional  0 taken 3
       10:  895-block  0
call    1 returned 10
branch  2 taken 7
branch  3 taken 3 (fallthrough)
        7:  896:		if (line[line_len - 1] == '\n')
        7:  896-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7:  897:			line[line_len - 1] = '\0';
        7:  897-block  0
unconditional  0 taken 7
        -:  898:
        7:  899:		if (args[i] && strcmp(args[i], line) != 0) {
        7:  899-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7:  899-block  1
branch  2 taken 7 (fallthrough)
branch  3 taken 0
        7:  900:			printf("%s %s->%s %s\n", args[i], mi_c, df_c, line);
        7:  900-block  0
call    0 returned 7
        7:  901:			modified++;
unconditional  0 taken 7
        -:  902:		}
        -:  903:
        7:  904:		i++;
        7:  904-block  0
unconditional  0 taken 7
        -:  905:	}
        -:  906:
        -:  907:	/* If no file name was modified */
        3:  908:	if (!modified) {
        3:  908-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  909:		puts(_("bulk: Nothing to do"));
    %%%%%:  909-block  0
call    0 never executed
call    1 never executed
    #####:  910:		if (unlinkat(fd, bulk_file, 0) == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  911:			_err('e', PRINT_PROMPT, "%s: '%s': %s\n", PROGRAM_NAME,
call    0 never executed
    #####:  912:			    bulk_file, strerror(errno));
    %%%%%:  912-block  0
call    0 never executed
    #####:  913:			exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  914:		}
    #####:  915:		free(line);
    #####:  916:		close_fstream(fp, fd);
    %%%%%:  916-block  0
call    0 never executed
    #####:  917:		return exit_status;
unconditional  0 never executed
        -:  918:	}
        -:  919:
        -:  920:	/* Ask the user for confirmation */
        3:  921:	char *answer = (char *)NULL;
        6:  922:	while (!answer) {
        3:  922-block  0
unconditional  0 taken 3
        6:  922-block  1
branch  1 taken 3
branch  2 taken 3 (fallthrough)
        3:  923:		answer = rl_no_hist(_("Continue? [y/N] "));
        3:  923-block  0
call    0 returned 3
call    1 returned 3
       3*:  924:		if (strlen(answer) > 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  925:			free(answer);
    #####:  926:			answer = (char *)NULL;
    #####:  927:			continue;
    %%%%%:  927-block  0
unconditional  0 never executed
        -:  928:		}
        -:  929:
        3:  930:		switch (*answer) {
        3:  930-block  0
branch  0 taken 3
branch  1 taken 0
branch  2 taken 0
        3:  931:		case 'y': /* fallthrough */
        3:  932:		case 'Y': break;
        3:  932-block  0
unconditional  0 taken 3
        -:  933:
    #####:  934:		case 'n': /* fallthrough */
        -:  935:		case 'N': /* fallthrough */
        -:  936:		case '\0':
    #####:  937:			free(answer);
    #####:  938:			free(line);
    #####:  939:			close_fstream(fp, fd);
    %%%%%:  939-block  0
call    0 never executed
    #####:  940:			return EXIT_SUCCESS;
unconditional  0 never executed
        -:  941:
    #####:  942:		default:
    #####:  943:			free(answer);
    #####:  944:			answer = (char *)NULL;
    #####:  945:			break;
    %%%%%:  945-block  0
unconditional  0 never executed
        -:  946:		}
        -:  947:	}
        -:  948:
        3:  949:	free(answer);
        -:  950:
        -:  951:	/* Once again */
        3:  952:	fseek(fp, 0L, SEEK_SET);
        3:  952-block  0
call    0 returned 3
        -:  953:
        3:  954:	i = 1;
        -:  955:
        -:  956:	/* Rename each file */
       10:  957:	while ((line_len = getline(&line, &line_size, fp)) > 0) {
unconditional  0 taken 3
       10:  957-block  0
call    1 returned 10
branch  2 taken 7
branch  3 taken 3 (fallthrough)
       7*:  958:		if (!args[i]) {
        7:  958-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  959:			i++;
    #####:  960:			continue;
    %%%%%:  960-block  0
unconditional  0 never executed
        -:  961:		}
        -:  962:
        7:  963:		if (line[line_len - 1] == '\n')
        7:  963-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7:  964:			line[line_len - 1] = '\0';
        7:  964-block  0
unconditional  0 taken 7
        7:  965:		if (args[i] && strcmp(args[i], line) != 0) {
        7:  965-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7:  965-block  1
branch  2 taken 7 (fallthrough)
branch  3 taken 0
        7:  966:			if (renameat(AT_FDCWD, args[i], AT_FDCWD, line) == -1)
        7:  966-block  0
call    0 returned 7
branch  1 taken 0 (fallthrough)
branch  2 taken 7
    #####:  967:				exit_status = EXIT_FAILURE;
    %%%%%:  967-block  0
unconditional  0 never executed
        -:  968:		}
        -:  969:
        7:  970:		i++;
        7:  970-block  0
unconditional  0 taken 7
        -:  971:	}
        -:  972:
        3:  973:	free(line);
        -:  974:
        3:  975:	if (unlinkat(fd, bulk_file, 0) == -1) {
        3:  975-block  0
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
    #####:  976:		_err('e', PRINT_PROMPT, "%s: '%s': %s\n", PROGRAM_NAME,
call    0 never executed
    #####:  977:		    bulk_file, strerror(errno));
    %%%%%:  977-block  0
call    0 never executed
    #####:  978:		exit_status = EXIT_FAILURE;
unconditional  0 never executed
        -:  979:	}
        3:  980:	close_fstream(fp, fd);
        3:  980-block  0
call    0 returned 3
        -:  981:
        -:  982:#ifdef __HAIKU__
        -:  983:	if (cd_lists_on_the_fly) {
        -:  984:		free_dirlist();
        -:  985:		if (list_dir() != EXIT_SUCCESS)
        -:  986:			exit_status = EXIT_FAILURE;
        -:  987:	}
        -:  988:#endif
        -:  989:
        3:  990:	return exit_status;
unconditional  0 taken 3
        -:  991:}
        -:  992:
        -:  993:/* Export files in CWD (if FILENAMES is NULL), or files in FILENAMES,
        -:  994: * into a temporary file. Return the address of this empt file if
        -:  995: * success (it must be freed) or NULL in case of error */
function export called 2 returned 100% blocks executed 72%
        2:  996:char *export(char **filenames, int open)
        -:  997:{
        2:  998:	char *rand_ext = gen_rand_str(6);
        2:  998-block  0
call    0 returned 2
        2:  999:	if (!rand_ext)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1000:		return (char *)NULL;
    %%%%%: 1000-block  0
unconditional  0 never executed
        -: 1001:
        2: 1002:	char *tmp_file = (char *)xnmalloc(strlen(tmp_dir) + 14, sizeof(char));
        2: 1002-block  0
call    0 returned 2
        2: 1003:	sprintf(tmp_file, "%s/.clifm%s", tmp_dir, rand_ext);
        2: 1004:	free(rand_ext);
        -: 1005:
        2: 1006:	FILE *fp = fopen(tmp_file, "w");
call    0 returned 2
        2: 1007:	if (!fp) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1008:		free(tmp_file);
    #####: 1009:		return (char *)NULL;
    %%%%%: 1009-block  0
unconditional  0 never executed
        -: 1010:	}
        -: 1011:
        -: 1012:	size_t i;
        -: 1013:
        -: 1014:	/* If no argument, export files in CWD */
        2: 1015:	if (!filenames[1]) {
        2: 1015-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        6: 1016:		for (i = 0; file_info[i].name; i++)
        1: 1016-block  0
unconditional  0 taken 1
unconditional  1 taken 5
        6: 1016-block  1
branch  2 taken 5
branch  3 taken 1
        5: 1017:			fprintf(fp, "%s\n", file_info[i].name);
        5: 1017-block  0
call    0 returned 5
        -: 1018:	} else {
        2: 1019:		for (i = 1; filenames[i]; i++) {
        1: 1019-block  0
unconditional  0 taken 1
        1: 1019-block  1
unconditional  1 taken 1
        2: 1019-block  2
branch  2 taken 1
branch  3 taken 1 (fallthrough)
       1*: 1020:			if (*filenames[i] == '.' && (!filenames[i][1] || (filenames[i][1] == '.' && !filenames[i][2])))
        1: 1020-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1020-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1020-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1020-block  3
branch  6 never executed
branch  7 never executed
    #####: 1021:				continue;
    %%%%%: 1021-block  0
unconditional  0 never executed
        1: 1022:			fprintf(fp, "%s\n", filenames[i]);
        1: 1022-block  0
call    0 returned 1
unconditional  1 taken 1
        -: 1023:		}
        -: 1024:	}
        -: 1025:
        2: 1026:	fclose(fp);
        2: 1026-block  0
call    0 returned 2
        -: 1027:
        2: 1028:	if (!open)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 1029:		return tmp_file;
    %%%%%: 1029-block  0
unconditional  0 never executed
        -: 1030:
        2: 1031:	int ret = open_file(tmp_file);
        2: 1031-block  0
call    0 returned 2
        2: 1032:	if (ret == EXIT_SUCCESS) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1033:		return tmp_file;
        2: 1033-block  0
unconditional  0 taken 2
        -: 1034:	} else {
    #####: 1035:		free(tmp_file);
    #####: 1036:		return (char *)NULL;
    %%%%%: 1036-block  0
unconditional  0 never executed
        -: 1037:	}
        -: 1038:}
        -: 1039:
        -: 1040:int
function batch_link called 0 returned 0% blocks executed 0%
    #####: 1041:batch_link(char **args)
        -: 1042:{
    #####: 1043:	if (!args)
    %%%%%: 1043-block  0
branch  0 never executed
branch  1 never executed
    #####: 1044:		return EXIT_FAILURE;
    %%%%%: 1044-block  0
unconditional  0 never executed
        -: 1045:
    #####: 1046:	if (!args[1] || (*args[1] == '-' && strcmp(args[1], "--help") == 0)) {
    %%%%%: 1046-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1046-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1046-block  2
branch  4 never executed
branch  5 never executed
    #####: 1047:		puts(_(BL_USAGE));
    %%%%%: 1047-block  0
call    0 never executed
call    1 never executed
    #####: 1048:		return EXIT_SUCCESS;
unconditional  0 never executed
        -: 1049:	}
        -: 1050:
    #####: 1051:	log_function(NULL);
    %%%%%: 1051-block  0
call    0 never executed
        -: 1052:
    #####: 1053:	char *suffix = (char *)NULL;
    #####: 1054:	while (!suffix) {
unconditional  0 never executed
    %%%%%: 1054-block  0
branch  1 never executed
branch  2 never executed
    #####: 1055:		suffix = rl_no_hist(_("Enter links suffix ('n' for none): "));
    %%%%%: 1055-block  0
call    0 never executed
call    1 never executed
    #####: 1056:		if (!suffix)
branch  0 never executed
branch  1 never executed
    #####: 1057:			continue;
    %%%%%: 1057-block  0
unconditional  0 never executed
    #####: 1058:		if (!*suffix) {
    %%%%%: 1058-block  0
branch  0 never executed
branch  1 never executed
    #####: 1059:			free(suffix);
    #####: 1060:			suffix = (char *)NULL;
    #####: 1061:			continue;
    %%%%%: 1061-block  0
unconditional  0 never executed
        -: 1062:		}
        -: 1063:	}
        -: 1064:
        -: 1065:	size_t i;
    #####: 1066:	int exit_status = EXIT_SUCCESS;
        -: 1067:	char tmp[NAME_MAX];
        -: 1068:
    #####: 1069:	for (i = 1; args[i]; i++) {
    %%%%%: 1069-block  0
unconditional  0 never executed
    %%%%%: 1069-block  1
unconditional  1 never executed
    %%%%%: 1069-block  2
branch  2 never executed
branch  3 never executed
    #####: 1070:		char *linkname = (char *)NULL;
        -: 1071:
    #####: 1072:		if (*suffix == 'n' && !suffix[1]) {
    %%%%%: 1072-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1072-block  1
branch  2 never executed
branch  3 never executed
    #####: 1073:			linkname = args[i];
    %%%%%: 1073-block  0
unconditional  0 never executed
        -: 1074:		} else {
    #####: 1075:			snprintf(tmp, NAME_MAX, "%s%s", args[i], suffix);
    #####: 1076:			linkname = tmp;
    %%%%%: 1076-block  0
unconditional  0 never executed
        -: 1077:		}
        -: 1078:
    #####: 1079:		char *ptr = strrchr(linkname, '/');
    #####: 1080:		if (symlinkat(args[i], AT_FDCWD, ptr ? ++ptr : linkname) == -1) {
    %%%%%: 1080-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1080-block  1
unconditional  2 never executed
    %%%%%: 1080-block  2
unconditional  3 never executed
    %%%%%: 1080-block  3
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1081:			exit_status = EXIT_FAILURE;
    #####: 1082:			fprintf(stderr, _("%s: %s: Cannot create symlink: %s\n"),
branch  0 never executed
branch  1 never executed
    %%%%%: 1082-block  0
unconditional  2 never executed
    %%%%%: 1082-block  1
unconditional  3 never executed
    %%%%%: 1082-block  2
call    4 never executed
call    5 never executed
unconditional  6 never executed
    #####: 1083:			    PROGRAM_NAME, ptr ? ptr : linkname, strerror(errno));
    %%%%%: 1083-block  0
call    0 never executed
        -: 1084:		}
        -: 1085:	}
        -: 1086:
        -: 1087:#ifdef __HAIKU__
        -: 1088:	if (exit_status == EXIT_SUCCESS && cd_lists_on_the_fly) {
        -: 1089:		free_dirlist();
        -: 1090:
        -: 1091:		if (list_dir() != EXIT_SUCCESS)
        -: 1092:			exit_status = EXIT_FAILURE;
        -: 1093:	}
        -: 1094:#endif
        -: 1095:
    #####: 1096:	free(suffix);
    #####: 1097:	return exit_status;
    %%%%%: 1097-block  0
unconditional  0 never executed
        -: 1098:}
